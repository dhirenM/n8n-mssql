diff --git a/driver/DriverFactory.js b/driver/DriverFactory.js
index 7cb1455a4c17a51f34b87c83f10b6b6e4b3832cf..9c7c260f1902e0ec04e270773602b3e2812a5a29 100644
--- a/driver/DriverFactory.js
+++ b/driver/DriverFactory.js
@@ -47,9 +47,12 @@ const getDriver = async (type) => {
         case "sqlite-pooled":
             return (await Promise.resolve().then(() => __importStar(require("./sqlite-pooled/SqliteReadWriteDriver"))))
                 .SqliteReadWriteDriver;
+        case "mssql":
+            return (await Promise.resolve().then(() => __importStar(require("./sqlserver/SqlServerDriver")))).SqlServerDriver;
         default:
             throw new MissingDriverError_1.MissingDriverError(type, [
                 "mariadb",
+                "mssql",
                 "mysql",
                 "postgres",
                 "sqlite",
diff --git a/driver/sqlserver/MssqlParameter.d.ts b/driver/sqlserver/MssqlParameter.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5a527b38e55626c20f37393caba5d2eaa6e9dff8
--- /dev/null
+++ b/driver/sqlserver/MssqlParameter.d.ts
@@ -0,0 +1,44 @@
+/**
+ * Sql server driver requires parameter types to be specified fo input parameters used in the query.
+ *
+ * @see https://github.com/patriksimek/node-mssql#data-types
+ */
+export declare class MssqlParameter {
+    value: any;
+    type: string;
+    readonly "@instanceof": symbol;
+    params: any[];
+    constructor(value: any, type: "bit");
+    constructor(value: any, type: "bigint");
+    constructor(value: any, type: "decimal", precision?: number, scale?: number);
+    constructor(value: any, type: "float");
+    constructor(value: any, type: "int");
+    constructor(value: any, type: "money");
+    constructor(value: any, type: "numeric", precision?: number, scale?: number);
+    constructor(value: any, type: "smallint");
+    constructor(value: any, type: "smallmoney");
+    constructor(value: any, type: "real");
+    constructor(value: any, type: "tinyint");
+    constructor(value: any, type: "char", length?: number);
+    constructor(value: any, type: "nchar", length?: number);
+    constructor(value: any, type: "text");
+    constructor(value: any, type: "ntext");
+    constructor(value: any, type: "varchar", length?: number);
+    constructor(value: any, type: "nvarchar", length?: number);
+    constructor(value: any, type: "xml");
+    constructor(value: any, type: "time", scale?: number);
+    constructor(value: any, type: "date");
+    constructor(value: any, type: "datetime");
+    constructor(value: any, type: "datetime2", scale?: number);
+    constructor(value: any, type: "datetimeoffset", scale?: number);
+    constructor(value: any, type: "smalldatetime");
+    constructor(value: any, type: "uniqueidentifier");
+    constructor(value: any, type: "variant");
+    constructor(value: any, type: "binary");
+    constructor(value: any, type: "varbinary", length?: number);
+    constructor(value: any, type: "image");
+    constructor(value: any, type: "udt");
+    constructor(value: any, type: "geography");
+    constructor(value: any, type: "geometry");
+    constructor(value: any, type: "rowversion");
+}
diff --git a/driver/sqlserver/MssqlParameter.js b/driver/sqlserver/MssqlParameter.js
new file mode 100644
index 0000000000000000000000000000000000000000..7941a08eee492156f65eb65333d439235fe1116f
--- /dev/null
+++ b/driver/sqlserver/MssqlParameter.js
@@ -0,0 +1,23 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.MssqlParameter = void 0;
+/**
+ * Sql server driver requires parameter types to be specified fo input parameters used in the query.
+ *
+ * @see https://github.com/patriksimek/node-mssql#data-types
+ */
+class MssqlParameter {
+    constructor(value, type, ...params) {
+        this.value = value;
+        this.type = type;
+        this["@instanceof"] = Symbol.for("MssqlParameter");
+        // -------------------------------------------------------------------------
+        // Public Properties
+        // -------------------------------------------------------------------------
+        this.params = [];
+        this.params = params || [];
+    }
+}
+exports.MssqlParameter = MssqlParameter;
+
+//# sourceMappingURL=MssqlParameter.js.map
diff --git a/driver/sqlserver/MssqlParameter.js.map b/driver/sqlserver/MssqlParameter.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..7e1fc95fe855197447855d7c7c6f110dcc3529a1
--- /dev/null
+++ b/driver/sqlserver/MssqlParameter.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/MssqlParameter.ts"],"names":[],"mappings":";;;AAAA;;;;GAIG;AACH,MAAa,cAAc;IA8CvB,YAAmB,KAAU,EAAS,IAAY,EAAE,GAAG,MAAgB;QAApD,UAAK,GAAL,KAAK,CAAK;QAAS,SAAI,GAAJ,IAAI,CAAQ;QA7CzC,mBAAa,GAAG,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAA;QAErD,4EAA4E;QAC5E,oBAAoB;QACpB,4EAA4E;QAErE,WAAM,GAAU,EAAE,CAAA;QAwCrB,IAAI,CAAC,MAAM,GAAG,MAAM,IAAI,EAAE,CAAA;IAC9B,CAAC;CACJ;AAjDD,wCAiDC","file":"MssqlParameter.js","sourcesContent":["/**\n * Sql server driver requires parameter types to be specified fo input parameters used in the query.\n *\n * @see https://github.com/patriksimek/node-mssql#data-types\n */\nexport class MssqlParameter {\n    readonly \"@instanceof\" = Symbol.for(\"MssqlParameter\")\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    public params: any[] = []\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(value: any, type: \"bit\")\n    constructor(value: any, type: \"bigint\")\n    constructor(value: any, type: \"decimal\", precision?: number, scale?: number)\n    constructor(value: any, type: \"float\")\n    constructor(value: any, type: \"int\")\n    constructor(value: any, type: \"money\")\n    constructor(value: any, type: \"numeric\", precision?: number, scale?: number)\n    constructor(value: any, type: \"smallint\")\n    constructor(value: any, type: \"smallmoney\")\n    constructor(value: any, type: \"real\")\n    constructor(value: any, type: \"tinyint\")\n    constructor(value: any, type: \"char\", length?: number)\n    constructor(value: any, type: \"nchar\", length?: number)\n    constructor(value: any, type: \"text\")\n    constructor(value: any, type: \"ntext\")\n    constructor(value: any, type: \"varchar\", length?: number)\n    constructor(value: any, type: \"nvarchar\", length?: number)\n    constructor(value: any, type: \"xml\")\n    constructor(value: any, type: \"time\", scale?: number)\n    constructor(value: any, type: \"date\")\n    constructor(value: any, type: \"datetime\")\n    constructor(value: any, type: \"datetime2\", scale?: number)\n    constructor(value: any, type: \"datetimeoffset\", scale?: number)\n    constructor(value: any, type: \"smalldatetime\")\n    constructor(value: any, type: \"uniqueidentifier\")\n    constructor(value: any, type: \"variant\")\n    constructor(value: any, type: \"binary\")\n    constructor(value: any, type: \"varbinary\", length?: number)\n    constructor(value: any, type: \"image\")\n    constructor(value: any, type: \"udt\")\n    constructor(value: any, type: \"geography\")\n    constructor(value: any, type: \"geometry\")\n    constructor(value: any, type: \"rowversion\")\n    constructor(public value: any, public type: string, ...params: number[]) {\n        this.params = params || []\n    }\n}\n"],"sourceRoot":"../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/MssqlParameter.ts b/driver/sqlserver/MssqlParameter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7fa171419d347c509108aba5beae5d811c72efdf
--- /dev/null
+++ b/driver/sqlserver/MssqlParameter.ts
@@ -0,0 +1,55 @@
+/**
+ * Sql server driver requires parameter types to be specified fo input parameters used in the query.
+ *
+ * @see https://github.com/patriksimek/node-mssql#data-types
+ */
+export class MssqlParameter {
+    readonly "@instanceof" = Symbol.for("MssqlParameter")
+
+    // -------------------------------------------------------------------------
+    // Public Properties
+    // -------------------------------------------------------------------------
+
+    public params: any[] = []
+
+    // -------------------------------------------------------------------------
+    // Constructor
+    // -------------------------------------------------------------------------
+
+    constructor(value: any, type: "bit")
+    constructor(value: any, type: "bigint")
+    constructor(value: any, type: "decimal", precision?: number, scale?: number)
+    constructor(value: any, type: "float")
+    constructor(value: any, type: "int")
+    constructor(value: any, type: "money")
+    constructor(value: any, type: "numeric", precision?: number, scale?: number)
+    constructor(value: any, type: "smallint")
+    constructor(value: any, type: "smallmoney")
+    constructor(value: any, type: "real")
+    constructor(value: any, type: "tinyint")
+    constructor(value: any, type: "char", length?: number)
+    constructor(value: any, type: "nchar", length?: number)
+    constructor(value: any, type: "text")
+    constructor(value: any, type: "ntext")
+    constructor(value: any, type: "varchar", length?: number)
+    constructor(value: any, type: "nvarchar", length?: number)
+    constructor(value: any, type: "xml")
+    constructor(value: any, type: "time", scale?: number)
+    constructor(value: any, type: "date")
+    constructor(value: any, type: "datetime")
+    constructor(value: any, type: "datetime2", scale?: number)
+    constructor(value: any, type: "datetimeoffset", scale?: number)
+    constructor(value: any, type: "smalldatetime")
+    constructor(value: any, type: "uniqueidentifier")
+    constructor(value: any, type: "variant")
+    constructor(value: any, type: "binary")
+    constructor(value: any, type: "varbinary", length?: number)
+    constructor(value: any, type: "image")
+    constructor(value: any, type: "udt")
+    constructor(value: any, type: "geography")
+    constructor(value: any, type: "geometry")
+    constructor(value: any, type: "rowversion")
+    constructor(public value: any, public type: string, ...params: number[]) {
+        this.params = params || []
+    }
+}
diff --git a/driver/sqlserver/SqlServerConnectionCredentialsOptions.d.ts b/driver/sqlserver/SqlServerConnectionCredentialsOptions.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..366bdae6032be73dae49966bcb8e861aaced3aed
--- /dev/null
+++ b/driver/sqlserver/SqlServerConnectionCredentialsOptions.d.ts
@@ -0,0 +1,50 @@
+import { DefaultAuthentication } from "./authentication/DefaultAuthentication";
+import { AzureActiveDirectoryAccessTokenAuthentication } from "./authentication/AzureActiveDirectoryAccessTokenAuthentication";
+import { AzureActiveDirectoryDefaultAuthentication } from "./authentication/AzureActiveDirectoryDefaultAuthentication";
+import { AzureActiveDirectoryMsiAppServiceAuthentication } from "./authentication/AzureActiveDirectoryMsiAppServiceAuthentication";
+import { AzureActiveDirectoryMsiVmAuthentication } from "./authentication/AzureActiveDirectoryMsiVmAuthentication";
+import { AzureActiveDirectoryPasswordAuthentication } from "./authentication/AzureActiveDirectoryPasswordAuthentication";
+import { AzureActiveDirectoryServicePrincipalSecret } from "./authentication/AzureActiveDirectoryServicePrincipalSecret";
+import { NtlmAuthentication } from "./authentication/NtlmAuthentication";
+export type SqlServerConnectionCredentialsAuthenticationOptions = DefaultAuthentication | NtlmAuthentication | AzureActiveDirectoryAccessTokenAuthentication | AzureActiveDirectoryDefaultAuthentication | AzureActiveDirectoryMsiAppServiceAuthentication | AzureActiveDirectoryMsiVmAuthentication | AzureActiveDirectoryPasswordAuthentication | AzureActiveDirectoryServicePrincipalSecret;
+/**
+ * SqlServer specific connection credential options.
+ */
+export interface SqlServerConnectionCredentialsOptions {
+    /**
+     * Connection url where perform connection to.
+     */
+    readonly url?: string;
+    /**
+     * Database host.
+     */
+    readonly host?: string;
+    /**
+     * Database host port.
+     */
+    readonly port?: number;
+    /**
+     * Database name to connect to.
+     */
+    readonly database?: string;
+    /**
+     * Database username.
+     */
+    readonly username?: string;
+    /**
+     * Database password.
+     */
+    readonly password?: string;
+    /**
+     * Authentication settings
+     * It overrides username and password, when passed.
+     */
+    readonly authentication?: SqlServerConnectionCredentialsAuthenticationOptions;
+    /**
+     * Once you set domain, driver will connect to SQL Server using domain login.
+     * @see SqlServerConnectionCredentialsOptions.authentication
+     * @see NtlmAuthentication
+     * @deprecated
+     */
+    readonly domain?: string;
+}
diff --git a/driver/sqlserver/SqlServerConnectionCredentialsOptions.js b/driver/sqlserver/SqlServerConnectionCredentialsOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..587febc469b598e0cfd4321500c3e8d559fb4c92
--- /dev/null
+++ b/driver/sqlserver/SqlServerConnectionCredentialsOptions.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+
+//# sourceMappingURL=SqlServerConnectionCredentialsOptions.js.map
diff --git a/driver/sqlserver/SqlServerConnectionCredentialsOptions.js.map b/driver/sqlserver/SqlServerConnectionCredentialsOptions.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..6b00ad035345b28558a7886f04facff8398916cc
--- /dev/null
+++ b/driver/sqlserver/SqlServerConnectionCredentialsOptions.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/SqlServerConnectionCredentialsOptions.ts"],"names":[],"mappings":"","file":"SqlServerConnectionCredentialsOptions.js","sourcesContent":["import { DefaultAuthentication } from \"./authentication/DefaultAuthentication\"\nimport { AzureActiveDirectoryAccessTokenAuthentication } from \"./authentication/AzureActiveDirectoryAccessTokenAuthentication\"\nimport { AzureActiveDirectoryDefaultAuthentication } from \"./authentication/AzureActiveDirectoryDefaultAuthentication\"\nimport { AzureActiveDirectoryMsiAppServiceAuthentication } from \"./authentication/AzureActiveDirectoryMsiAppServiceAuthentication\"\nimport { AzureActiveDirectoryMsiVmAuthentication } from \"./authentication/AzureActiveDirectoryMsiVmAuthentication\"\nimport { AzureActiveDirectoryPasswordAuthentication } from \"./authentication/AzureActiveDirectoryPasswordAuthentication\"\nimport { AzureActiveDirectoryServicePrincipalSecret } from \"./authentication/AzureActiveDirectoryServicePrincipalSecret\"\nimport { NtlmAuthentication } from \"./authentication/NtlmAuthentication\"\n\nexport type SqlServerConnectionCredentialsAuthenticationOptions =\n    | DefaultAuthentication\n    | NtlmAuthentication\n    | AzureActiveDirectoryAccessTokenAuthentication\n    | AzureActiveDirectoryDefaultAuthentication\n    | AzureActiveDirectoryMsiAppServiceAuthentication\n    | AzureActiveDirectoryMsiVmAuthentication\n    | AzureActiveDirectoryPasswordAuthentication\n    | AzureActiveDirectoryServicePrincipalSecret\n\n/**\n * SqlServer specific connection credential options.\n */\nexport interface SqlServerConnectionCredentialsOptions {\n    /**\n     * Connection url where perform connection to.\n     */\n    readonly url?: string\n\n    /**\n     * Database host.\n     */\n    readonly host?: string\n\n    /**\n     * Database host port.\n     */\n    readonly port?: number\n\n    /**\n     * Database name to connect to.\n     */\n    readonly database?: string\n\n    /**\n     * Database username.\n     */\n    readonly username?: string\n\n    /**\n     * Database password.\n     */\n    readonly password?: string\n\n    /**\n     * Authentication settings\n     * It overrides username and password, when passed.\n     */\n    readonly authentication?: SqlServerConnectionCredentialsAuthenticationOptions\n\n    /**\n     * Once you set domain, driver will connect to SQL Server using domain login.\n     * @see SqlServerConnectionCredentialsOptions.authentication\n     * @see NtlmAuthentication\n     * @deprecated\n     */\n    readonly domain?: string\n}\n"],"sourceRoot":"../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/SqlServerConnectionCredentialsOptions.ts b/driver/sqlserver/SqlServerConnectionCredentialsOptions.ts
new file mode 100644
index 0000000000000000000000000000000000000000..06eb866825226887f810d51cc7cc3d702bfd9ff0
--- /dev/null
+++ b/driver/sqlserver/SqlServerConnectionCredentialsOptions.ts
@@ -0,0 +1,67 @@
+import { DefaultAuthentication } from "./authentication/DefaultAuthentication"
+import { AzureActiveDirectoryAccessTokenAuthentication } from "./authentication/AzureActiveDirectoryAccessTokenAuthentication"
+import { AzureActiveDirectoryDefaultAuthentication } from "./authentication/AzureActiveDirectoryDefaultAuthentication"
+import { AzureActiveDirectoryMsiAppServiceAuthentication } from "./authentication/AzureActiveDirectoryMsiAppServiceAuthentication"
+import { AzureActiveDirectoryMsiVmAuthentication } from "./authentication/AzureActiveDirectoryMsiVmAuthentication"
+import { AzureActiveDirectoryPasswordAuthentication } from "./authentication/AzureActiveDirectoryPasswordAuthentication"
+import { AzureActiveDirectoryServicePrincipalSecret } from "./authentication/AzureActiveDirectoryServicePrincipalSecret"
+import { NtlmAuthentication } from "./authentication/NtlmAuthentication"
+
+export type SqlServerConnectionCredentialsAuthenticationOptions =
+    | DefaultAuthentication
+    | NtlmAuthentication
+    | AzureActiveDirectoryAccessTokenAuthentication
+    | AzureActiveDirectoryDefaultAuthentication
+    | AzureActiveDirectoryMsiAppServiceAuthentication
+    | AzureActiveDirectoryMsiVmAuthentication
+    | AzureActiveDirectoryPasswordAuthentication
+    | AzureActiveDirectoryServicePrincipalSecret
+
+/**
+ * SqlServer specific connection credential options.
+ */
+export interface SqlServerConnectionCredentialsOptions {
+    /**
+     * Connection url where perform connection to.
+     */
+    readonly url?: string
+
+    /**
+     * Database host.
+     */
+    readonly host?: string
+
+    /**
+     * Database host port.
+     */
+    readonly port?: number
+
+    /**
+     * Database name to connect to.
+     */
+    readonly database?: string
+
+    /**
+     * Database username.
+     */
+    readonly username?: string
+
+    /**
+     * Database password.
+     */
+    readonly password?: string
+
+    /**
+     * Authentication settings
+     * It overrides username and password, when passed.
+     */
+    readonly authentication?: SqlServerConnectionCredentialsAuthenticationOptions
+
+    /**
+     * Once you set domain, driver will connect to SQL Server using domain login.
+     * @see SqlServerConnectionCredentialsOptions.authentication
+     * @see NtlmAuthentication
+     * @deprecated
+     */
+    readonly domain?: string
+}
diff --git a/driver/sqlserver/SqlServerConnectionOptions.d.ts b/driver/sqlserver/SqlServerConnectionOptions.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f680eb8150178a67e56ad3c7820c6f6754d5f836
--- /dev/null
+++ b/driver/sqlserver/SqlServerConnectionOptions.d.ts
@@ -0,0 +1,252 @@
+import { BaseDataSourceOptions } from "../../data-source/BaseDataSourceOptions";
+import { ReplicationMode } from "../types/ReplicationMode";
+import { SqlServerConnectionCredentialsOptions } from "./SqlServerConnectionCredentialsOptions";
+/**
+ * Microsoft Sql Server specific connection options.
+ */
+export interface SqlServerConnectionOptions extends BaseDataSourceOptions, SqlServerConnectionCredentialsOptions {
+    /**
+     * Database type.
+     */
+    readonly type: "mssql";
+    /**
+     * Connection timeout in ms (default: 15000).
+     */
+    readonly connectionTimeout?: number;
+    /**
+     * Request timeout in ms (default: 15000). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second.
+     */
+    readonly requestTimeout?: number;
+    /**
+     * Stream recordsets/rows instead of returning them all at once as an argument of callback (default: false).
+     * You can also enable streaming for each request independently (request.stream = true).
+     * Always set to true if you plan to work with large amount of rows.
+     */
+    readonly stream?: boolean;
+    /**
+     * Database schema.
+     */
+    readonly schema?: string;
+    /**
+     * The driver object
+     * This defaults to `require("mssql")`
+     */
+    readonly driver?: any;
+    /**
+     * An optional object/dictionary with the any of the properties
+     */
+    readonly pool?: {
+        /**
+         * Maximum number of resources to create at any given time. (default=1)
+         */
+        readonly max?: number;
+        /**
+         * Minimum number of resources to keep in pool at any given time. If this is set >= max, the pool will silently
+         * set the min to equal max. (default=0)
+         */
+        readonly min?: number;
+        /**
+         * Maximum number of queued requests allowed, additional acquire calls will be callback with an err in a future
+         * cycle of the event loop.
+         */
+        readonly maxWaitingClients?: number;
+        /**
+         * Max milliseconds an acquire call will wait for a resource before timing out. (default no limit), if supplied should non-zero positive integer.
+         */
+        readonly acquireTimeoutMillis?: number;
+        /**
+         * If true the oldest resources will be first to be allocated. If false the most recently released resources will
+         * be the first to be allocated. This in effect turns the pool's behaviour from a queue into a stack. boolean,
+         * (default true)
+         */
+        readonly fifo?: boolean;
+        /**
+         * Int between 1 and x - if set, borrowers can specify their relative priority in the queue if no resources
+         * are available. see example. (default 1)
+         */
+        readonly priorityRange?: number;
+        /**
+         * How often to run eviction checks. Default: 0 (does not run).
+         */
+        readonly evictionRunIntervalMillis?: number;
+        /**
+         * Number of resources to check each eviction run. Default: 3.
+         */
+        readonly numTestsPerRun?: number;
+        /**
+         * Amount of time an object may sit idle in the pool before it is eligible for eviction by the idle object
+         * evictor (if any), with the extra condition that at least "min idle" object instances remain in the pool.
+         * Default -1 (nothing can get evicted)
+         */
+        readonly softIdleTimeoutMillis?: number;
+        /**
+         * The minimum amount of time that an object may sit idle in the pool before it is eligible for eviction due
+         * to idle time. Supercedes softIdleTimeoutMillis Default: 30000
+         */
+        readonly idleTimeoutMillis?: number;
+        readonly errorHandler?: (err: any) => any;
+    };
+    /**
+     * Extra options
+     */
+    readonly options?: {
+        /**
+         * The named instance to connect to
+         */
+        readonly instanceName?: string;
+        /**
+         * By default, if the database requestion by options.database cannot be accessed, the connection will fail with
+         * an error. However, if options.fallbackToDefaultDb is set to true, then the user's default database will
+         * be used instead (Default: false).
+         */
+        readonly fallbackToDefaultDb?: boolean;
+        /**
+         * If true, SET ANSI_NULL_DFLT_ON ON will be set in the initial sql. This means new columns will be nullable by
+         * default. See the T-SQL documentation for more details. (Default: true).
+         */
+        readonly enableAnsiNullDefault?: boolean;
+        /**
+         * The number of milliseconds before the attempt to connect is considered failed (default: 15000).
+         */
+        readonly connectTimeout?: number;
+        /**
+         * The number of milliseconds before the cancel (abort) of a request is considered failed (default: 5000).
+         */
+        readonly cancelTimeout?: number;
+        /**
+         * The size of TDS packets (subject to negotiation with the server). Should be a power of 2. (default: 4096).
+         */
+        readonly packetSize?: number;
+        /**
+         * A boolean determining whether to pass time values in UTC or local time. (default: false).
+         */
+        readonly useUTC?: boolean;
+        /**
+         * A boolean determining whether to rollback a transaction automatically if any error is encountered during
+         * the given transaction's execution. This sets the value for SET XACT_ABORT during the initial SQL phase
+         * of a connection (documentation).
+         */
+        readonly abortTransactionOnError?: boolean;
+        /**
+         * A string indicating which network interface (ip address) to use when connecting to SQL Server.
+         */
+        readonly localAddress?: string;
+        /**
+         * A boolean determining whether to return rows as arrays or key-value collections. (default: false).
+         */
+        readonly useColumnNames?: boolean;
+        /**
+         * A boolean, controlling whether the column names returned will have the first letter converted to lower case
+         * (true) or not. This value is ignored if you provide a columnNameReplacer. (default: false).
+         */
+        readonly camelCaseColumns?: boolean;
+        /**
+         * A boolean, controlling whatever to disable RETURNING / OUTPUT statements.
+         */
+        readonly disableOutputReturning?: boolean;
+        /**
+         * A boolean, controlling whether MssqlParameter types char, varchar, and text are converted to their unicode equivalents, nchar, nvarchar, and ntext.
+         * (default: false, meaning that char/varchar/text parameters will be converted to nchar/nvarchar/ntext)
+         */
+        readonly disableAsciiToUnicodeParamConversion?: boolean;
+        /**
+         * Debug options
+         */
+        readonly debug?: {
+            /**
+             * A boolean, controlling whether debug events will be emitted with text describing packet details
+             * (default: false).
+             */
+            readonly packet?: boolean;
+            /**
+             * A boolean, controlling whether debug events will be emitted with text describing packet data details
+             * (default: false).
+             */
+            readonly data?: boolean;
+            /**
+             * A boolean, controlling whether debug events will be emitted with text describing packet payload details
+             * (default: false).
+             */
+            readonly payload?: boolean;
+            /**
+             * A boolean, controlling whether debug events will be emitted with text describing token stream tokens
+             * (default: false).
+             */
+            readonly token?: boolean;
+        };
+        /**
+         * The default isolation level that transactions will be run with. The isolation levels are available
+         * from require('tedious').ISOLATION_LEVEL. (default: READ_COMMITTED).
+         */
+        readonly isolation?: "READ_UNCOMMITTED" | "READ_COMMITTED" | "REPEATABLE_READ" | "SERIALIZABLE" | "SNAPSHOT";
+        /**
+         * The default isolation level for new connections. All out-of-transaction queries are executed with this
+         * setting. The isolation levels are available from require('tedious').ISOLATION_LEVEL .
+         */
+        readonly connectionIsolationLevel?: "READ_UNCOMMITTED" | "READ_COMMITTED" | "REPEATABLE_READ" | "SERIALIZABLE" | "SNAPSHOT";
+        /**
+         * A boolean, determining whether the connection will request read only access from a SQL Server
+         * Availability Group. For more information, see here. (default: false).
+         */
+        readonly readOnlyIntent?: boolean;
+        /**
+         * A boolean determining whether or not the connection will be encrypted. Set to true if you're on
+         * Windows Azure. (default: true).
+         */
+        readonly encrypt?: boolean;
+        /**
+         * When encryption is used, an object may be supplied that will be used for the first argument when calling
+         * tls.createSecurePair (default: {}).
+         */
+        readonly cryptoCredentialsDetails?: any;
+        /**
+         * A boolean, that when true will expose received rows in Requests' done* events. See done, doneInProc and
+         * doneProc. (default: false)
+         * Caution: If many row are received, enabling this option could result in excessive memory usage.
+         */
+        readonly rowCollectionOnDone?: boolean;
+        /**
+         * A boolean, that when true will expose received rows in Requests' completion callback. See new Request. (default: false)
+         * Caution: If many row are received, enabling this option could result in excessive memory usage.
+         */
+        readonly rowCollectionOnRequestCompletion?: boolean;
+        /**
+         * The version of TDS to use. If server doesn't support specified version, negotiated version is used instead.
+         * The versions are available from require('tedious').TDS_VERSION. (default: 7_4).
+         */
+        readonly tdsVersion?: string;
+        /**
+         * A boolean, that when true will abort a query when an overflow or divide-by-zero error occurs during query execution.
+         */
+        readonly enableArithAbort?: boolean;
+        /**
+         * Application name used for identifying a specific application in profiling, logging or tracing tools of SQL Server.
+         * (default: node-mssql)
+         */
+        readonly appName?: string;
+        /**
+         * A boolean, controlling whether encryption occurs if there is no verifiable server certificate.
+         * (default: false)
+         */
+        readonly trustServerCertificate?: boolean;
+    };
+    /**
+     * Replication setup.
+     */
+    readonly replication?: {
+        /**
+         * Master server used by orm to perform writes.
+         */
+        readonly master: SqlServerConnectionCredentialsOptions;
+        /**
+         * List of read-from severs (slaves).
+         */
+        readonly slaves: SqlServerConnectionCredentialsOptions[];
+        /**
+         * Default connection pool to use for SELECT queries
+         * @default "slave"
+         */
+        readonly defaultMode?: ReplicationMode;
+    };
+    readonly poolSize?: never;
+}
diff --git a/driver/sqlserver/SqlServerConnectionOptions.js b/driver/sqlserver/SqlServerConnectionOptions.js
new file mode 100644
index 0000000000000000000000000000000000000000..7aacaf07c5df90e0b91aac83a09f1dee323750db
--- /dev/null
+++ b/driver/sqlserver/SqlServerConnectionOptions.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+
+//# sourceMappingURL=SqlServerConnectionOptions.js.map
diff --git a/driver/sqlserver/SqlServerConnectionOptions.js.map b/driver/sqlserver/SqlServerConnectionOptions.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..0a0c17f625af0db088b2fcf7cd2032b389f0ff54
--- /dev/null
+++ b/driver/sqlserver/SqlServerConnectionOptions.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/SqlServerConnectionOptions.ts"],"names":[],"mappings":"","file":"SqlServerConnectionOptions.js","sourcesContent":["import { BaseDataSourceOptions } from \"../../data-source/BaseDataSourceOptions\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { SqlServerConnectionCredentialsOptions } from \"./SqlServerConnectionCredentialsOptions\"\n\n/**\n * Microsoft Sql Server specific connection options.\n */\nexport interface SqlServerConnectionOptions\n    extends BaseDataSourceOptions,\n        SqlServerConnectionCredentialsOptions {\n    /**\n     * Database type.\n     */\n    readonly type: \"mssql\"\n\n    /**\n     * Connection timeout in ms (default: 15000).\n     */\n    readonly connectionTimeout?: number\n\n    /**\n     * Request timeout in ms (default: 15000). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second.\n     */\n    readonly requestTimeout?: number\n\n    /**\n     * Stream recordsets/rows instead of returning them all at once as an argument of callback (default: false).\n     * You can also enable streaming for each request independently (request.stream = true).\n     * Always set to true if you plan to work with large amount of rows.\n     */\n    readonly stream?: boolean\n\n    /**\n     * Database schema.\n     */\n    readonly schema?: string\n\n    /**\n     * The driver object\n     * This defaults to `require(\"mssql\")`\n     */\n    readonly driver?: any\n\n    /**\n     * An optional object/dictionary with the any of the properties\n     */\n    readonly pool?: {\n        /**\n         * Maximum number of resources to create at any given time. (default=1)\n         */\n        readonly max?: number\n\n        /**\n         * Minimum number of resources to keep in pool at any given time. If this is set >= max, the pool will silently\n         * set the min to equal max. (default=0)\n         */\n        readonly min?: number\n\n        /**\n         * Maximum number of queued requests allowed, additional acquire calls will be callback with an err in a future\n         * cycle of the event loop.\n         */\n        readonly maxWaitingClients?: number\n\n        /**\n         * Max milliseconds an acquire call will wait for a resource before timing out. (default no limit), if supplied should non-zero positive integer.\n         */\n        readonly acquireTimeoutMillis?: number\n\n        /**\n         * If true the oldest resources will be first to be allocated. If false the most recently released resources will\n         * be the first to be allocated. This in effect turns the pool's behaviour from a queue into a stack. boolean,\n         * (default true)\n         */\n        readonly fifo?: boolean\n\n        /**\n         * Int between 1 and x - if set, borrowers can specify their relative priority in the queue if no resources\n         * are available. see example. (default 1)\n         */\n        readonly priorityRange?: number\n\n        /**\n         * How often to run eviction checks. Default: 0 (does not run).\n         */\n        readonly evictionRunIntervalMillis?: number\n\n        /**\n         * Number of resources to check each eviction run. Default: 3.\n         */\n        readonly numTestsPerRun?: number\n\n        /**\n         * Amount of time an object may sit idle in the pool before it is eligible for eviction by the idle object\n         * evictor (if any), with the extra condition that at least \"min idle\" object instances remain in the pool.\n         * Default -1 (nothing can get evicted)\n         */\n        readonly softIdleTimeoutMillis?: number\n\n        /**\n         * The minimum amount of time that an object may sit idle in the pool before it is eligible for eviction due\n         * to idle time. Supercedes softIdleTimeoutMillis Default: 30000\n         */\n        readonly idleTimeoutMillis?: number\n\n        /*\n         * Function handling errors thrown by drivers pool.\n         * Defaults to logging error with `warn` level.\n         */\n        readonly errorHandler?: (err: any) => any\n    }\n\n    /**\n     * Extra options\n     */\n    readonly options?: {\n        /**\n         * The named instance to connect to\n         */\n        readonly instanceName?: string\n\n        /**\n         * By default, if the database requestion by options.database cannot be accessed, the connection will fail with\n         * an error. However, if options.fallbackToDefaultDb is set to true, then the user's default database will\n         * be used instead (Default: false).\n         */\n        readonly fallbackToDefaultDb?: boolean\n\n        /**\n         * If true, SET ANSI_NULL_DFLT_ON ON will be set in the initial sql. This means new columns will be nullable by\n         * default. See the T-SQL documentation for more details. (Default: true).\n         */\n        readonly enableAnsiNullDefault?: boolean\n\n        /**\n         * The number of milliseconds before the attempt to connect is considered failed (default: 15000).\n         */\n        readonly connectTimeout?: number\n\n        /**\n         * The number of milliseconds before the cancel (abort) of a request is considered failed (default: 5000).\n         */\n        readonly cancelTimeout?: number\n\n        /**\n         * The size of TDS packets (subject to negotiation with the server). Should be a power of 2. (default: 4096).\n         */\n        readonly packetSize?: number\n\n        /**\n         * A boolean determining whether to pass time values in UTC or local time. (default: false).\n         */\n        readonly useUTC?: boolean\n\n        /**\n         * A boolean determining whether to rollback a transaction automatically if any error is encountered during\n         * the given transaction's execution. This sets the value for SET XACT_ABORT during the initial SQL phase\n         * of a connection (documentation).\n         */\n        readonly abortTransactionOnError?: boolean\n\n        /**\n         * A string indicating which network interface (ip address) to use when connecting to SQL Server.\n         */\n        readonly localAddress?: string\n\n        /**\n         * A boolean determining whether to return rows as arrays or key-value collections. (default: false).\n         */\n        readonly useColumnNames?: boolean\n\n        /**\n         * A boolean, controlling whether the column names returned will have the first letter converted to lower case\n         * (true) or not. This value is ignored if you provide a columnNameReplacer. (default: false).\n         */\n        readonly camelCaseColumns?: boolean\n\n        /**\n         * A boolean, controlling whatever to disable RETURNING / OUTPUT statements.\n         */\n        readonly disableOutputReturning?: boolean\n\n        /**\n         * A boolean, controlling whether MssqlParameter types char, varchar, and text are converted to their unicode equivalents, nchar, nvarchar, and ntext.\n         * (default: false, meaning that char/varchar/text parameters will be converted to nchar/nvarchar/ntext)\n         */\n        readonly disableAsciiToUnicodeParamConversion?: boolean\n\n        /**\n         * Debug options\n         */\n        readonly debug?: {\n            /**\n             * A boolean, controlling whether debug events will be emitted with text describing packet details\n             * (default: false).\n             */\n            readonly packet?: boolean\n\n            /**\n             * A boolean, controlling whether debug events will be emitted with text describing packet data details\n             * (default: false).\n             */\n            readonly data?: boolean\n\n            /**\n             * A boolean, controlling whether debug events will be emitted with text describing packet payload details\n             * (default: false).\n             */\n            readonly payload?: boolean\n\n            /**\n             * A boolean, controlling whether debug events will be emitted with text describing token stream tokens\n             * (default: false).\n             */\n            readonly token?: boolean\n        }\n\n        /**\n         * The default isolation level that transactions will be run with. The isolation levels are available\n         * from require('tedious').ISOLATION_LEVEL. (default: READ_COMMITTED).\n         */\n        readonly isolation?:\n            | \"READ_UNCOMMITTED\"\n            | \"READ_COMMITTED\"\n            | \"REPEATABLE_READ\"\n            | \"SERIALIZABLE\"\n            | \"SNAPSHOT\"\n\n        /**\n         * The default isolation level for new connections. All out-of-transaction queries are executed with this\n         * setting. The isolation levels are available from require('tedious').ISOLATION_LEVEL .\n         */\n        readonly connectionIsolationLevel?:\n            | \"READ_UNCOMMITTED\"\n            | \"READ_COMMITTED\"\n            | \"REPEATABLE_READ\"\n            | \"SERIALIZABLE\"\n            | \"SNAPSHOT\"\n\n        /**\n         * A boolean, determining whether the connection will request read only access from a SQL Server\n         * Availability Group. For more information, see here. (default: false).\n         */\n        readonly readOnlyIntent?: boolean\n\n        /**\n         * A boolean determining whether or not the connection will be encrypted. Set to true if you're on\n         * Windows Azure. (default: true).\n         */\n        readonly encrypt?: boolean\n\n        /**\n         * When encryption is used, an object may be supplied that will be used for the first argument when calling\n         * tls.createSecurePair (default: {}).\n         */\n        readonly cryptoCredentialsDetails?: any\n\n        /**\n         * A boolean, that when true will expose received rows in Requests' done* events. See done, doneInProc and\n         * doneProc. (default: false)\n         * Caution: If many row are received, enabling this option could result in excessive memory usage.\n         */\n        readonly rowCollectionOnDone?: boolean\n\n        /**\n         * A boolean, that when true will expose received rows in Requests' completion callback. See new Request. (default: false)\n         * Caution: If many row are received, enabling this option could result in excessive memory usage.\n         */\n        readonly rowCollectionOnRequestCompletion?: boolean\n\n        /**\n         * The version of TDS to use. If server doesn't support specified version, negotiated version is used instead.\n         * The versions are available from require('tedious').TDS_VERSION. (default: 7_4).\n         */\n        readonly tdsVersion?: string\n\n        /**\n         * A boolean, that when true will abort a query when an overflow or divide-by-zero error occurs during query execution.\n         */\n        readonly enableArithAbort?: boolean\n\n        /**\n         * Application name used for identifying a specific application in profiling, logging or tracing tools of SQL Server.\n         * (default: node-mssql)\n         */\n        readonly appName?: string\n\n        /**\n         * A boolean, controlling whether encryption occurs if there is no verifiable server certificate.\n         * (default: false)\n         */\n        readonly trustServerCertificate?: boolean\n    }\n\n    /**\n     * Replication setup.\n     */\n    readonly replication?: {\n        /**\n         * Master server used by orm to perform writes.\n         */\n        readonly master: SqlServerConnectionCredentialsOptions\n\n        /**\n         * List of read-from severs (slaves).\n         */\n        readonly slaves: SqlServerConnectionCredentialsOptions[]\n\n        /**\n         * Default connection pool to use for SELECT queries\n         * @default \"slave\"\n         */\n        readonly defaultMode?: ReplicationMode\n    }\n\n    readonly poolSize?: never\n}\n"],"sourceRoot":"../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/SqlServerConnectionOptions.ts b/driver/sqlserver/SqlServerConnectionOptions.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a0435c041bfc788763f8f94f097e9de8b63646f1
--- /dev/null
+++ b/driver/sqlserver/SqlServerConnectionOptions.ts
@@ -0,0 +1,317 @@
+import { BaseDataSourceOptions } from "../../data-source/BaseDataSourceOptions"
+import { ReplicationMode } from "../types/ReplicationMode"
+import { SqlServerConnectionCredentialsOptions } from "./SqlServerConnectionCredentialsOptions"
+
+/**
+ * Microsoft Sql Server specific connection options.
+ */
+export interface SqlServerConnectionOptions
+    extends BaseDataSourceOptions,
+        SqlServerConnectionCredentialsOptions {
+    /**
+     * Database type.
+     */
+    readonly type: "mssql"
+
+    /**
+     * Connection timeout in ms (default: 15000).
+     */
+    readonly connectionTimeout?: number
+
+    /**
+     * Request timeout in ms (default: 15000). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second.
+     */
+    readonly requestTimeout?: number
+
+    /**
+     * Stream recordsets/rows instead of returning them all at once as an argument of callback (default: false).
+     * You can also enable streaming for each request independently (request.stream = true).
+     * Always set to true if you plan to work with large amount of rows.
+     */
+    readonly stream?: boolean
+
+    /**
+     * Database schema.
+     */
+    readonly schema?: string
+
+    /**
+     * The driver object
+     * This defaults to `require("mssql")`
+     */
+    readonly driver?: any
+
+    /**
+     * An optional object/dictionary with the any of the properties
+     */
+    readonly pool?: {
+        /**
+         * Maximum number of resources to create at any given time. (default=1)
+         */
+        readonly max?: number
+
+        /**
+         * Minimum number of resources to keep in pool at any given time. If this is set >= max, the pool will silently
+         * set the min to equal max. (default=0)
+         */
+        readonly min?: number
+
+        /**
+         * Maximum number of queued requests allowed, additional acquire calls will be callback with an err in a future
+         * cycle of the event loop.
+         */
+        readonly maxWaitingClients?: number
+
+        /**
+         * Max milliseconds an acquire call will wait for a resource before timing out. (default no limit), if supplied should non-zero positive integer.
+         */
+        readonly acquireTimeoutMillis?: number
+
+        /**
+         * If true the oldest resources will be first to be allocated. If false the most recently released resources will
+         * be the first to be allocated. This in effect turns the pool's behaviour from a queue into a stack. boolean,
+         * (default true)
+         */
+        readonly fifo?: boolean
+
+        /**
+         * Int between 1 and x - if set, borrowers can specify their relative priority in the queue if no resources
+         * are available. see example. (default 1)
+         */
+        readonly priorityRange?: number
+
+        /**
+         * How often to run eviction checks. Default: 0 (does not run).
+         */
+        readonly evictionRunIntervalMillis?: number
+
+        /**
+         * Number of resources to check each eviction run. Default: 3.
+         */
+        readonly numTestsPerRun?: number
+
+        /**
+         * Amount of time an object may sit idle in the pool before it is eligible for eviction by the idle object
+         * evictor (if any), with the extra condition that at least "min idle" object instances remain in the pool.
+         * Default -1 (nothing can get evicted)
+         */
+        readonly softIdleTimeoutMillis?: number
+
+        /**
+         * The minimum amount of time that an object may sit idle in the pool before it is eligible for eviction due
+         * to idle time. Supercedes softIdleTimeoutMillis Default: 30000
+         */
+        readonly idleTimeoutMillis?: number
+
+        /*
+         * Function handling errors thrown by drivers pool.
+         * Defaults to logging error with `warn` level.
+         */
+        readonly errorHandler?: (err: any) => any
+    }
+
+    /**
+     * Extra options
+     */
+    readonly options?: {
+        /**
+         * The named instance to connect to
+         */
+        readonly instanceName?: string
+
+        /**
+         * By default, if the database requestion by options.database cannot be accessed, the connection will fail with
+         * an error. However, if options.fallbackToDefaultDb is set to true, then the user's default database will
+         * be used instead (Default: false).
+         */
+        readonly fallbackToDefaultDb?: boolean
+
+        /**
+         * If true, SET ANSI_NULL_DFLT_ON ON will be set in the initial sql. This means new columns will be nullable by
+         * default. See the T-SQL documentation for more details. (Default: true).
+         */
+        readonly enableAnsiNullDefault?: boolean
+
+        /**
+         * The number of milliseconds before the attempt to connect is considered failed (default: 15000).
+         */
+        readonly connectTimeout?: number
+
+        /**
+         * The number of milliseconds before the cancel (abort) of a request is considered failed (default: 5000).
+         */
+        readonly cancelTimeout?: number
+
+        /**
+         * The size of TDS packets (subject to negotiation with the server). Should be a power of 2. (default: 4096).
+         */
+        readonly packetSize?: number
+
+        /**
+         * A boolean determining whether to pass time values in UTC or local time. (default: false).
+         */
+        readonly useUTC?: boolean
+
+        /**
+         * A boolean determining whether to rollback a transaction automatically if any error is encountered during
+         * the given transaction's execution. This sets the value for SET XACT_ABORT during the initial SQL phase
+         * of a connection (documentation).
+         */
+        readonly abortTransactionOnError?: boolean
+
+        /**
+         * A string indicating which network interface (ip address) to use when connecting to SQL Server.
+         */
+        readonly localAddress?: string
+
+        /**
+         * A boolean determining whether to return rows as arrays or key-value collections. (default: false).
+         */
+        readonly useColumnNames?: boolean
+
+        /**
+         * A boolean, controlling whether the column names returned will have the first letter converted to lower case
+         * (true) or not. This value is ignored if you provide a columnNameReplacer. (default: false).
+         */
+        readonly camelCaseColumns?: boolean
+
+        /**
+         * A boolean, controlling whatever to disable RETURNING / OUTPUT statements.
+         */
+        readonly disableOutputReturning?: boolean
+
+        /**
+         * A boolean, controlling whether MssqlParameter types char, varchar, and text are converted to their unicode equivalents, nchar, nvarchar, and ntext.
+         * (default: false, meaning that char/varchar/text parameters will be converted to nchar/nvarchar/ntext)
+         */
+        readonly disableAsciiToUnicodeParamConversion?: boolean
+
+        /**
+         * Debug options
+         */
+        readonly debug?: {
+            /**
+             * A boolean, controlling whether debug events will be emitted with text describing packet details
+             * (default: false).
+             */
+            readonly packet?: boolean
+
+            /**
+             * A boolean, controlling whether debug events will be emitted with text describing packet data details
+             * (default: false).
+             */
+            readonly data?: boolean
+
+            /**
+             * A boolean, controlling whether debug events will be emitted with text describing packet payload details
+             * (default: false).
+             */
+            readonly payload?: boolean
+
+            /**
+             * A boolean, controlling whether debug events will be emitted with text describing token stream tokens
+             * (default: false).
+             */
+            readonly token?: boolean
+        }
+
+        /**
+         * The default isolation level that transactions will be run with. The isolation levels are available
+         * from require('tedious').ISOLATION_LEVEL. (default: READ_COMMITTED).
+         */
+        readonly isolation?:
+            | "READ_UNCOMMITTED"
+            | "READ_COMMITTED"
+            | "REPEATABLE_READ"
+            | "SERIALIZABLE"
+            | "SNAPSHOT"
+
+        /**
+         * The default isolation level for new connections. All out-of-transaction queries are executed with this
+         * setting. The isolation levels are available from require('tedious').ISOLATION_LEVEL .
+         */
+        readonly connectionIsolationLevel?:
+            | "READ_UNCOMMITTED"
+            | "READ_COMMITTED"
+            | "REPEATABLE_READ"
+            | "SERIALIZABLE"
+            | "SNAPSHOT"
+
+        /**
+         * A boolean, determining whether the connection will request read only access from a SQL Server
+         * Availability Group. For more information, see here. (default: false).
+         */
+        readonly readOnlyIntent?: boolean
+
+        /**
+         * A boolean determining whether or not the connection will be encrypted. Set to true if you're on
+         * Windows Azure. (default: true).
+         */
+        readonly encrypt?: boolean
+
+        /**
+         * When encryption is used, an object may be supplied that will be used for the first argument when calling
+         * tls.createSecurePair (default: {}).
+         */
+        readonly cryptoCredentialsDetails?: any
+
+        /**
+         * A boolean, that when true will expose received rows in Requests' done* events. See done, doneInProc and
+         * doneProc. (default: false)
+         * Caution: If many row are received, enabling this option could result in excessive memory usage.
+         */
+        readonly rowCollectionOnDone?: boolean
+
+        /**
+         * A boolean, that when true will expose received rows in Requests' completion callback. See new Request. (default: false)
+         * Caution: If many row are received, enabling this option could result in excessive memory usage.
+         */
+        readonly rowCollectionOnRequestCompletion?: boolean
+
+        /**
+         * The version of TDS to use. If server doesn't support specified version, negotiated version is used instead.
+         * The versions are available from require('tedious').TDS_VERSION. (default: 7_4).
+         */
+        readonly tdsVersion?: string
+
+        /**
+         * A boolean, that when true will abort a query when an overflow or divide-by-zero error occurs during query execution.
+         */
+        readonly enableArithAbort?: boolean
+
+        /**
+         * Application name used for identifying a specific application in profiling, logging or tracing tools of SQL Server.
+         * (default: node-mssql)
+         */
+        readonly appName?: string
+
+        /**
+         * A boolean, controlling whether encryption occurs if there is no verifiable server certificate.
+         * (default: false)
+         */
+        readonly trustServerCertificate?: boolean
+    }
+
+    /**
+     * Replication setup.
+     */
+    readonly replication?: {
+        /**
+         * Master server used by orm to perform writes.
+         */
+        readonly master: SqlServerConnectionCredentialsOptions
+
+        /**
+         * List of read-from severs (slaves).
+         */
+        readonly slaves: SqlServerConnectionCredentialsOptions[]
+
+        /**
+         * Default connection pool to use for SELECT queries
+         * @default "slave"
+         */
+        readonly defaultMode?: ReplicationMode
+    }
+
+    readonly poolSize?: never
+}
diff --git a/driver/sqlserver/SqlServerDriver.d.ts b/driver/sqlserver/SqlServerDriver.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..221674284f68b18e7af07384240e94a5ba356c7f
--- /dev/null
+++ b/driver/sqlserver/SqlServerDriver.d.ts
@@ -0,0 +1,262 @@
+import { Driver } from "../Driver";
+import { CteCapabilities } from "../types/CteCapabilities";
+import { SqlServerQueryRunner } from "./SqlServerQueryRunner";
+import { ObjectLiteral } from "../../common/ObjectLiteral";
+import { ColumnMetadata } from "../../metadata/ColumnMetadata";
+import { DataSource } from "../../data-source/DataSource";
+import { RdbmsSchemaBuilder } from "../../schema-builder/RdbmsSchemaBuilder";
+import { SqlServerConnectionOptions } from "./SqlServerConnectionOptions";
+import { MappedColumnTypes } from "../types/MappedColumnTypes";
+import { ColumnType } from "../types/ColumnTypes";
+import { DataTypeDefaults } from "../types/DataTypeDefaults";
+import { MssqlParameter } from "./MssqlParameter";
+import { TableColumn } from "../../schema-builder/table/TableColumn";
+import { SqlServerConnectionCredentialsOptions } from "./SqlServerConnectionCredentialsOptions";
+import { EntityMetadata } from "../../metadata/EntityMetadata";
+import { ReplicationMode } from "../types/ReplicationMode";
+import { Table } from "../../schema-builder/table/Table";
+import { View } from "../../schema-builder/view/View";
+import { TableForeignKey } from "../../schema-builder/table/TableForeignKey";
+import { UpsertType } from "../types/UpsertType";
+/**
+ * Organizes communication with SQL Server DBMS.
+ */
+export declare class SqlServerDriver implements Driver {
+    /**
+     * Connection used by driver.
+     */
+    connection: DataSource;
+    /**
+     * SQL Server library.
+     */
+    mssql: any;
+    /**
+     * Pool for master database.
+     */
+    master: any;
+    /**
+     * Pool for slave databases.
+     * Used in replication.
+     */
+    slaves: any[];
+    /**
+     * Connection options.
+     */
+    options: SqlServerConnectionOptions;
+    /**
+     * Database name used to perform all write queries.
+     */
+    database?: string;
+    /**
+     * Schema name used to perform all write queries.
+     */
+    schema?: string;
+    /**
+     * Schema that's used internally by SQL Server for object resolution.
+     *
+     * Because we never set this we have to track it in separately from the `schema` so
+     * we know when we have to specify the full schema or not.
+     *
+     * In most cases this will be `dbo`.
+     */
+    searchSchema?: string;
+    /**
+     * Indicates if replication is enabled.
+     */
+    isReplicated: boolean;
+    /**
+     * Indicates if tree tables are supported by this driver.
+     */
+    treeSupport: boolean;
+    /**
+     * Represent transaction support by this driver
+     */
+    transactionSupport: "simple";
+    /**
+     * Gets list of supported column data types by a driver.
+     *
+     * @see https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql
+     */
+    supportedDataTypes: ColumnType[];
+    /**
+     * Returns type of upsert supported by driver if any
+     */
+    supportedUpsertTypes: UpsertType[];
+    /**
+     * Gets list of spatial column data types.
+     */
+    spatialTypes: ColumnType[];
+    /**
+     * Gets list of column data types that support length by a driver.
+     */
+    withLengthColumnTypes: ColumnType[];
+    /**
+     * Gets list of column data types that support precision by a driver.
+     */
+    withPrecisionColumnTypes: ColumnType[];
+    /**
+     * Gets list of column data types that support scale by a driver.
+     */
+    withScaleColumnTypes: ColumnType[];
+    /**
+     * Orm has special columns and we need to know what database column types should be for those types.
+     * Column types are driver dependant.
+     */
+    mappedDataTypes: MappedColumnTypes;
+    /**
+     * The prefix used for the parameters
+     */
+    parametersPrefix: string;
+    /**
+     * Default values of length, precision and scale depends on column data type.
+     * Used in the cases when length/precision/scale is not specified by user.
+     */
+    dataTypeDefaults: DataTypeDefaults;
+    cteCapabilities: CteCapabilities;
+    /**
+     * Max length allowed by MSSQL Server for aliases (identifiers).
+     * @see https://docs.microsoft.com/en-us/sql/sql-server/maximum-capacity-specifications-for-sql-server
+     */
+    maxAliasLength: number;
+    constructor(connection: DataSource);
+    /**
+     * Performs connection to the database.
+     * Based on pooling options, it can either create connection immediately,
+     * either create a pool and create connection when needed.
+     */
+    connect(): Promise<void>;
+    /**
+     * Makes any action after connection (e.g. create extensions in Postgres driver).
+     */
+    afterConnect(): Promise<void>;
+    /**
+     * Closes connection with the database.
+     */
+    disconnect(): Promise<void>;
+    /**
+     * Closes connection pool.
+     */
+    protected closePool(pool: any): Promise<void>;
+    /**
+     * Creates a schema builder used to build and sync a schema.
+     */
+    createSchemaBuilder(): RdbmsSchemaBuilder;
+    /**
+     * Creates a query runner used to execute database queries.
+     */
+    createQueryRunner(mode: ReplicationMode): SqlServerQueryRunner;
+    /**
+     * Replaces parameters in the given sql with special escaping character
+     * and an array of parameter names to be passed to a query.
+     */
+    escapeQueryWithParameters(sql: string, parameters: ObjectLiteral, nativeParameters: ObjectLiteral): [string, any[]];
+    /**
+     * Escapes a column name.
+     */
+    escape(columnName: string): string;
+    /**
+     * Build full table name with database name, schema name and table name.
+     * E.g. myDB.mySchema.myTable
+     */
+    buildTableName(tableName: string, schema?: string, database?: string): string;
+    /**
+     * Parse a target table name or other types and return a normalized table definition.
+     */
+    parseTableName(target: EntityMetadata | Table | View | TableForeignKey | string): {
+        database?: string;
+        schema?: string;
+        tableName: string;
+    };
+    /**
+     * Prepares given value to a value to be persisted, based on its column type and metadata.
+     */
+    preparePersistentValue(value: any, columnMetadata: ColumnMetadata): any;
+    /**
+     * Prepares given value to a value to be persisted, based on its column type or metadata.
+     */
+    prepareHydratedValue(value: any, columnMetadata: ColumnMetadata): any;
+    /**
+     * Creates a database type from a given column metadata.
+     */
+    normalizeType(column: {
+        type?: ColumnType;
+        length?: number | string;
+        precision?: number | null;
+        scale?: number;
+    }): string;
+    /**
+     * Normalizes "default" value of the column.
+     */
+    normalizeDefault(columnMetadata: ColumnMetadata): string | undefined;
+    /**
+     * Normalizes "isUnique" value of the column.
+     */
+    normalizeIsUnique(column: ColumnMetadata): boolean;
+    /**
+     * Returns default column lengths, which is required on column creation.
+     */
+    getColumnLength(column: ColumnMetadata | TableColumn): string;
+    /**
+     * Creates column type definition including length, precision and scale
+     */
+    createFullType(column: TableColumn): string;
+    /**
+     * Obtains a new database connection to a master server.
+     * Used for replication.
+     * If replication is not setup then returns default connection's database connection.
+     */
+    obtainMasterConnection(): Promise<any>;
+    /**
+     * Obtains a new database connection to a slave server.
+     * Used for replication.
+     * If replication is not setup then returns master (default) connection's database connection.
+     */
+    obtainSlaveConnection(): Promise<any>;
+    /**
+     * Creates generated map of values generated or returned by database after INSERT query.
+     */
+    createGeneratedMap(metadata: EntityMetadata, insertResult: ObjectLiteral): ObjectLiteral | undefined;
+    /**
+     * Differentiate columns of this table and columns from the given column metadatas columns
+     * and returns only changed.
+     */
+    findChangedColumns(tableColumns: TableColumn[], columnMetadatas: ColumnMetadata[]): ColumnMetadata[];
+    /**
+     * Returns true if driver supports RETURNING / OUTPUT statement.
+     */
+    isReturningSqlSupported(): boolean;
+    /**
+     * Returns true if driver supports uuid values generation on its own.
+     */
+    isUUIDGenerationSupported(): boolean;
+    /**
+     * Returns true if driver supports fulltext indices.
+     */
+    isFullTextColumnTypeSupported(): boolean;
+    /**
+     * Creates an escaped parameter.
+     */
+    createParameter(parameterName: string, index: number): string;
+    /**
+     * Sql server's parameters needs to be wrapped into special object with type information about this value.
+     * This method wraps given value into MssqlParameter based on its column definition.
+     */
+    parametrizeValue(column: ColumnMetadata, value: any): MssqlParameter;
+    /**
+     * Sql server's parameters needs to be wrapped into special object with type information about this value.
+     * This method wraps all values of the given object into MssqlParameter based on their column definitions in the given table.
+     */
+    parametrizeMap(tablePath: string, map: ObjectLiteral): ObjectLiteral;
+    buildTableVariableDeclaration(identifier: string, columns: ColumnMetadata[]): string;
+    /**
+     * If driver dependency is not given explicitly, then try to load it via "require".
+     */
+    protected loadDependencies(): void;
+    protected compareColumnType(tableColumn: TableColumn, columnMetadata: ColumnMetadata): boolean;
+    protected compareColumnLength(tableColumn: TableColumn, columnMetadata: ColumnMetadata): boolean;
+    protected lowerDefaultValueIfNecessary(value: string | undefined): string | undefined;
+    /**
+     * Creates a new connection pool for a given database credentials.
+     */
+    protected createPool(options: SqlServerConnectionOptions, credentials: SqlServerConnectionCredentialsOptions): Promise<any>;
+}
diff --git a/driver/sqlserver/SqlServerDriver.js b/driver/sqlserver/SqlServerDriver.js
new file mode 100644
index 0000000000000000000000000000000000000000..ebab47a3f47bb79338a837ef3b94616c4503edd6
--- /dev/null
+++ b/driver/sqlserver/SqlServerDriver.js
@@ -0,0 +1,898 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.SqlServerDriver = void 0;
+const ConnectionIsNotSetError_1 = require("../../error/ConnectionIsNotSetError");
+const DriverPackageNotInstalledError_1 = require("../../error/DriverPackageNotInstalledError");
+const DriverUtils_1 = require("../DriverUtils");
+const SqlServerQueryRunner_1 = require("./SqlServerQueryRunner");
+const DateUtils_1 = require("../../util/DateUtils");
+const PlatformTools_1 = require("../../platform/PlatformTools");
+const RdbmsSchemaBuilder_1 = require("../../schema-builder/RdbmsSchemaBuilder");
+const MssqlParameter_1 = require("./MssqlParameter");
+const TableColumn_1 = require("../../schema-builder/table/TableColumn");
+const OrmUtils_1 = require("../../util/OrmUtils");
+const ApplyValueTransformers_1 = require("../../util/ApplyValueTransformers");
+const error_1 = require("../../error");
+const InstanceChecker_1 = require("../../util/InstanceChecker");
+/**
+ * Organizes communication with SQL Server DBMS.
+ */
+class SqlServerDriver {
+    // -------------------------------------------------------------------------
+    // Constructor
+    // -------------------------------------------------------------------------
+    constructor(connection) {
+        /**
+         * Pool for slave databases.
+         * Used in replication.
+         */
+        this.slaves = [];
+        /**
+         * Indicates if replication is enabled.
+         */
+        this.isReplicated = false;
+        /**
+         * Indicates if tree tables are supported by this driver.
+         */
+        this.treeSupport = true;
+        /**
+         * Represent transaction support by this driver
+         */
+        this.transactionSupport = "simple";
+        /**
+         * Gets list of supported column data types by a driver.
+         *
+         * @see https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql
+         */
+        this.supportedDataTypes = [
+            "int",
+            "bigint",
+            "bit",
+            "decimal",
+            "money",
+            "numeric",
+            "smallint",
+            "smallmoney",
+            "tinyint",
+            "float",
+            "real",
+            "date",
+            "datetime2",
+            "datetime",
+            "datetimeoffset",
+            "smalldatetime",
+            "time",
+            "char",
+            "varchar",
+            "text",
+            "nchar",
+            "nvarchar",
+            "ntext",
+            "binary",
+            "image",
+            "varbinary",
+            "hierarchyid",
+            "sql_variant",
+            "timestamp",
+            "uniqueidentifier",
+            "xml",
+            "geometry",
+            "geography",
+            "rowversion",
+        ];
+        /**
+         * Returns type of upsert supported by driver if any
+         */
+        this.supportedUpsertTypes = [];
+        /**
+         * Gets list of spatial column data types.
+         */
+        this.spatialTypes = ["geometry", "geography"];
+        /**
+         * Gets list of column data types that support length by a driver.
+         */
+        this.withLengthColumnTypes = [
+            "char",
+            "varchar",
+            "nchar",
+            "nvarchar",
+            "binary",
+            "varbinary",
+        ];
+        /**
+         * Gets list of column data types that support precision by a driver.
+         */
+        this.withPrecisionColumnTypes = [
+            "decimal",
+            "numeric",
+            "time",
+            "datetime2",
+            "datetimeoffset",
+        ];
+        /**
+         * Gets list of column data types that support scale by a driver.
+         */
+        this.withScaleColumnTypes = ["decimal", "numeric"];
+        /**
+         * Orm has special columns and we need to know what database column types should be for those types.
+         * Column types are driver dependant.
+         */
+        this.mappedDataTypes = {
+            createDate: "datetime2",
+            createDateDefault: "getdate()",
+            updateDate: "datetime2",
+            updateDateDefault: "getdate()",
+            deleteDate: "datetime2",
+            deleteDateNullable: true,
+            version: "int",
+            treeLevel: "int",
+            migrationId: "int",
+            migrationName: "varchar",
+            migrationTimestamp: "bigint",
+            cacheId: "int",
+            cacheIdentifier: "nvarchar",
+            cacheTime: "bigint",
+            cacheDuration: "int",
+            cacheQuery: "nvarchar(MAX)",
+            cacheResult: "nvarchar(MAX)",
+            metadataType: "varchar",
+            metadataDatabase: "varchar",
+            metadataSchema: "varchar",
+            metadataTable: "varchar",
+            metadataName: "varchar",
+            metadataValue: "nvarchar(MAX)",
+        };
+        /**
+         * The prefix used for the parameters
+         */
+        this.parametersPrefix = "@";
+        /**
+         * Default values of length, precision and scale depends on column data type.
+         * Used in the cases when length/precision/scale is not specified by user.
+         */
+        this.dataTypeDefaults = {
+            char: { length: 1 },
+            nchar: { length: 1 },
+            varchar: { length: 255 },
+            nvarchar: { length: 255 },
+            binary: { length: 1 },
+            varbinary: { length: 1 },
+            decimal: { precision: 18, scale: 0 },
+            numeric: { precision: 18, scale: 0 },
+            time: { precision: 7 },
+            datetime2: { precision: 7 },
+            datetimeoffset: { precision: 7 },
+        };
+        this.cteCapabilities = {
+            enabled: true,
+            // todo: enable it for SQL Server - it's partially supported, but there are issues with generation of non-standard OUTPUT clause
+            writable: false,
+        };
+        /**
+         * Max length allowed by MSSQL Server for aliases (identifiers).
+         * @see https://docs.microsoft.com/en-us/sql/sql-server/maximum-capacity-specifications-for-sql-server
+         */
+        this.maxAliasLength = 128;
+        this.connection = connection;
+        this.options = connection.options;
+        this.isReplicated = this.options.replication ? true : false;
+        // load mssql package
+        this.loadDependencies();
+        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options.replication
+            ? this.options.replication.master
+            : this.options).database;
+        this.schema = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).schema;
+        // Object.assign(connection.options, DriverUtils.buildDriverOptions(connection.options)); // todo: do it better way
+        // validate options to make sure everything is set
+        // if (!this.options.host)
+        // throw new DriverOptionNotSetError("host");
+        // if (!this.options.username)
+        //     throw new DriverOptionNotSetError("username");
+        // if (!this.options.database)
+        //     throw new DriverOptionNotSetError("database");
+    }
+    // -------------------------------------------------------------------------
+    // Public Implemented Methods
+    // -------------------------------------------------------------------------
+    /**
+     * Performs connection to the database.
+     * Based on pooling options, it can either create connection immediately,
+     * either create a pool and create connection when needed.
+     */
+    async connect() {
+        if (this.options.replication) {
+            this.slaves = await Promise.all(this.options.replication.slaves.map((slave) => {
+                return this.createPool(this.options, slave);
+            }));
+            this.master = await this.createPool(this.options, this.options.replication.master);
+        }
+        else {
+            this.master = await this.createPool(this.options, this.options);
+        }
+        if (!this.database || !this.searchSchema) {
+            const queryRunner = await this.createQueryRunner("master");
+            if (!this.database) {
+                this.database = await queryRunner.getCurrentDatabase();
+            }
+            if (!this.searchSchema) {
+                this.searchSchema = await queryRunner.getCurrentSchema();
+            }
+            await queryRunner.release();
+        }
+        if (!this.schema) {
+            this.schema = this.searchSchema;
+        }
+    }
+    /**
+     * Makes any action after connection (e.g. create extensions in Postgres driver).
+     */
+    afterConnect() {
+        return Promise.resolve();
+    }
+    /**
+     * Closes connection with the database.
+     */
+    async disconnect() {
+        if (!this.master)
+            return Promise.reject(new ConnectionIsNotSetError_1.ConnectionIsNotSetError("mssql"));
+        await this.closePool(this.master);
+        await Promise.all(this.slaves.map((slave) => this.closePool(slave)));
+        this.master = undefined;
+        this.slaves = [];
+    }
+    /**
+     * Closes connection pool.
+     */
+    async closePool(pool) {
+        return new Promise((ok, fail) => {
+            pool.close((err) => (err ? fail(err) : ok()));
+        });
+    }
+    /**
+     * Creates a schema builder used to build and sync a schema.
+     */
+    createSchemaBuilder() {
+        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
+    }
+    /**
+     * Creates a query runner used to execute database queries.
+     */
+    createQueryRunner(mode) {
+        return new SqlServerQueryRunner_1.SqlServerQueryRunner(this, mode);
+    }
+    /**
+     * Replaces parameters in the given sql with special escaping character
+     * and an array of parameter names to be passed to a query.
+     */
+    escapeQueryWithParameters(sql, parameters, nativeParameters) {
+        const escapedParameters = Object.keys(nativeParameters).map((key) => nativeParameters[key]);
+        if (!parameters || !Object.keys(parameters).length)
+            return [sql, escapedParameters];
+        const parameterIndexMap = new Map();
+        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {
+            if (!parameters.hasOwnProperty(key)) {
+                return full;
+            }
+            if (parameterIndexMap.has(key)) {
+                return this.parametersPrefix + parameterIndexMap.get(key);
+            }
+            let value = parameters[key];
+            if (isArray) {
+                return value
+                    .map((v) => {
+                    escapedParameters.push(v);
+                    return this.createParameter(key, escapedParameters.length - 1);
+                })
+                    .join(", ");
+            }
+            if (typeof value === "function") {
+                return value();
+            }
+            escapedParameters.push(value);
+            parameterIndexMap.set(key, escapedParameters.length - 1);
+            return this.createParameter(key, escapedParameters.length - 1);
+        }); // todo: make replace only in value statements, otherwise problems
+        return [sql, escapedParameters];
+    }
+    /**
+     * Escapes a column name.
+     */
+    escape(columnName) {
+        return `"${columnName}"`;
+    }
+    /**
+     * Build full table name with database name, schema name and table name.
+     * E.g. myDB.mySchema.myTable
+     */
+    buildTableName(tableName, schema, database) {
+        let tablePath = [tableName];
+        if (schema) {
+            tablePath.unshift(schema);
+        }
+        if (database) {
+            if (!schema) {
+                tablePath.unshift("");
+            }
+            tablePath.unshift(database);
+        }
+        return tablePath.join(".");
+    }
+    /**
+     * Parse a target table name or other types and return a normalized table definition.
+     */
+    parseTableName(target) {
+        const driverDatabase = this.database;
+        const driverSchema = this.schema;
+        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
+            const parsed = this.parseTableName(target.name);
+            return {
+                database: target.database || parsed.database || driverDatabase,
+                schema: target.schema || parsed.schema || driverSchema,
+                tableName: parsed.tableName,
+            };
+        }
+        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
+            const parsed = this.parseTableName(target.referencedTableName);
+            return {
+                database: target.referencedDatabase ||
+                    parsed.database ||
+                    driverDatabase,
+                schema: target.referencedSchema || parsed.schema || driverSchema,
+                tableName: parsed.tableName,
+            };
+        }
+        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
+            // EntityMetadata tableName is never a path
+            return {
+                database: target.database || driverDatabase,
+                schema: target.schema || driverSchema,
+                tableName: target.tableName,
+            };
+        }
+        const parts = target.split(".");
+        if (parts.length === 3) {
+            return {
+                database: parts[0] || driverDatabase,
+                schema: parts[1] || driverSchema,
+                tableName: parts[2],
+            };
+        }
+        else if (parts.length === 2) {
+            return {
+                database: driverDatabase,
+                schema: parts[0],
+                tableName: parts[1],
+            };
+        }
+        else {
+            return {
+                database: driverDatabase,
+                schema: driverSchema,
+                tableName: target,
+            };
+        }
+    }
+    /**
+     * Prepares given value to a value to be persisted, based on its column type and metadata.
+     */
+    preparePersistentValue(value, columnMetadata) {
+        if (columnMetadata.transformer)
+            value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
+        if (value === null || value === undefined)
+            return value;
+        if (columnMetadata.type === Boolean) {
+            return value === true ? 1 : 0;
+        }
+        else if (columnMetadata.type === "date") {
+            return DateUtils_1.DateUtils.mixedDateToDate(value);
+        }
+        else if (columnMetadata.type === "time") {
+            return DateUtils_1.DateUtils.mixedTimeToDate(value);
+        }
+        else if (columnMetadata.type === "datetime" ||
+            columnMetadata.type === "smalldatetime" ||
+            columnMetadata.type === Date) {
+            return DateUtils_1.DateUtils.mixedDateToDate(value, false, false);
+        }
+        else if (columnMetadata.type === "datetime2" ||
+            columnMetadata.type === "datetimeoffset") {
+            return DateUtils_1.DateUtils.mixedDateToDate(value, false, true);
+        }
+        else if (columnMetadata.type === "simple-array") {
+            return DateUtils_1.DateUtils.simpleArrayToString(value);
+        }
+        else if (columnMetadata.type === "simple-json") {
+            return DateUtils_1.DateUtils.simpleJsonToString(value);
+        }
+        else if (columnMetadata.type === "simple-enum") {
+            return DateUtils_1.DateUtils.simpleEnumToString(value);
+        }
+        return value;
+    }
+    /**
+     * Prepares given value to a value to be persisted, based on its column type or metadata.
+     */
+    prepareHydratedValue(value, columnMetadata) {
+        if (value === null || value === undefined)
+            return columnMetadata.transformer
+                ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value)
+                : value;
+        if (columnMetadata.type === Boolean) {
+            value = value ? true : false;
+        }
+        else if (columnMetadata.type === "datetime" ||
+            columnMetadata.type === Date ||
+            columnMetadata.type === "datetime2" ||
+            columnMetadata.type === "smalldatetime" ||
+            columnMetadata.type === "datetimeoffset") {
+            value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
+        }
+        else if (columnMetadata.type === "date") {
+            value = DateUtils_1.DateUtils.mixedDateToDateString(value);
+        }
+        else if (columnMetadata.type === "time") {
+            value = DateUtils_1.DateUtils.mixedTimeToString(value);
+        }
+        else if (columnMetadata.type === "simple-array") {
+            value = DateUtils_1.DateUtils.stringToSimpleArray(value);
+        }
+        else if (columnMetadata.type === "simple-json") {
+            value = DateUtils_1.DateUtils.stringToSimpleJson(value);
+        }
+        else if (columnMetadata.type === "simple-enum") {
+            value = DateUtils_1.DateUtils.stringToSimpleEnum(value, columnMetadata);
+        }
+        else if (columnMetadata.type === Number) {
+            // convert to number if number
+            value = !isNaN(+value) ? parseInt(value) : value;
+        }
+        if (columnMetadata.transformer)
+            value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
+        return value;
+    }
+    /**
+     * Creates a database type from a given column metadata.
+     */
+    normalizeType(column) {
+        if (column.type === Number || column.type === "integer") {
+            return "int";
+        }
+        else if (column.type === String) {
+            return "nvarchar";
+        }
+        else if (column.type === Date) {
+            return "datetime";
+        }
+        else if (column.type === Boolean) {
+            return "bit";
+        }
+        else if (column.type === Buffer) {
+            return "binary";
+        }
+        else if (column.type === "uuid") {
+            return "uniqueidentifier";
+        }
+        else if (column.type === "simple-array" ||
+            column.type === "simple-json") {
+            return "ntext";
+        }
+        else if (column.type === "simple-enum") {
+            return "nvarchar";
+        }
+        else if (column.type === "dec") {
+            return "decimal";
+        }
+        else if (column.type === "double precision") {
+            return "float";
+        }
+        else if (column.type === "rowversion") {
+            return "timestamp"; // the rowversion type's name in SQL server metadata is timestamp
+        }
+        else {
+            return column.type || "";
+        }
+    }
+    /**
+     * Normalizes "default" value of the column.
+     */
+    normalizeDefault(columnMetadata) {
+        const defaultValue = columnMetadata.default;
+        if (typeof defaultValue === "number") {
+            return `${defaultValue}`;
+        }
+        if (typeof defaultValue === "boolean") {
+            return defaultValue ? "1" : "0";
+        }
+        if (typeof defaultValue === "function") {
+            const value = defaultValue();
+            if (value.toUpperCase() === "CURRENT_TIMESTAMP") {
+                return "getdate()";
+            }
+            return value;
+        }
+        if (typeof defaultValue === "string") {
+            return `'${defaultValue}'`;
+        }
+        if (defaultValue === undefined || defaultValue === null) {
+            return undefined;
+        }
+        return `${defaultValue}`;
+    }
+    /**
+     * Normalizes "isUnique" value of the column.
+     */
+    normalizeIsUnique(column) {
+        return column.entityMetadata.uniques.some((uq) => uq.columns.length === 1 && uq.columns[0] === column);
+    }
+    /**
+     * Returns default column lengths, which is required on column creation.
+     */
+    getColumnLength(column) {
+        if (column.length)
+            return column.length.toString();
+        if (column.type === "varchar" ||
+            column.type === "nvarchar" ||
+            column.type === String)
+            return "255";
+        return "";
+    }
+    /**
+     * Creates column type definition including length, precision and scale
+     */
+    createFullType(column) {
+        // The Database Engine determines the data type of the computed column by applying the rules
+        // of data type precedence to the expressions specified in the formula.
+        if (column.asExpression)
+            return "";
+        let type = column.type;
+        // used 'getColumnLength()' method, because SqlServer sets `varchar` and `nvarchar` length to 1 by default.
+        if (this.getColumnLength(column)) {
+            type += `(${this.getColumnLength(column)})`;
+        }
+        else if (column.precision !== null &&
+            column.precision !== undefined &&
+            column.scale !== null &&
+            column.scale !== undefined) {
+            type += `(${column.precision},${column.scale})`;
+        }
+        else if (column.precision !== null &&
+            column.precision !== undefined) {
+            type += `(${column.precision})`;
+        }
+        if (column.isArray)
+            type += " array";
+        return type;
+    }
+    /**
+     * Obtains a new database connection to a master server.
+     * Used for replication.
+     * If replication is not setup then returns default connection's database connection.
+     */
+    obtainMasterConnection() {
+        if (!this.master) {
+            return Promise.reject(new error_1.TypeORMError("Driver not Connected"));
+        }
+        return Promise.resolve(this.master);
+    }
+    /**
+     * Obtains a new database connection to a slave server.
+     * Used for replication.
+     * If replication is not setup then returns master (default) connection's database connection.
+     */
+    obtainSlaveConnection() {
+        if (!this.slaves.length)
+            return this.obtainMasterConnection();
+        const random = Math.floor(Math.random() * this.slaves.length);
+        return Promise.resolve(this.slaves[random]);
+    }
+    /**
+     * Creates generated map of values generated or returned by database after INSERT query.
+     */
+    createGeneratedMap(metadata, insertResult) {
+        if (!insertResult)
+            return undefined;
+        return Object.keys(insertResult).reduce((map, key) => {
+            const column = metadata.findColumnWithDatabaseName(key);
+            if (column) {
+                OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column)));
+            }
+            return map;
+        }, {});
+    }
+    /**
+     * Differentiate columns of this table and columns from the given column metadatas columns
+     * and returns only changed.
+     */
+    findChangedColumns(tableColumns, columnMetadatas) {
+        return columnMetadatas.filter((columnMetadata) => {
+            const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);
+            if (!tableColumn)
+                return false; // we don't need new columns, we only need exist and changed
+            const isColumnChanged = tableColumn.name !== columnMetadata.databaseName ||
+                this.compareColumnType(tableColumn, columnMetadata) ||
+                this.compareColumnLength(tableColumn, columnMetadata) ||
+                tableColumn.precision !== columnMetadata.precision ||
+                tableColumn.scale !== columnMetadata.scale ||
+                // || tableColumn.comment !== columnMetadata.comment || // todo
+                tableColumn.isGenerated !== columnMetadata.isGenerated ||
+                (!tableColumn.isGenerated &&
+                    this.lowerDefaultValueIfNecessary(this.normalizeDefault(columnMetadata)) !==
+                        this.lowerDefaultValueIfNecessary(tableColumn.default)) || // we included check for generated here, because generated columns already can have default values
+                tableColumn.isPrimary !== columnMetadata.isPrimary ||
+                tableColumn.isNullable !== columnMetadata.isNullable ||
+                tableColumn.asExpression !== columnMetadata.asExpression ||
+                tableColumn.generatedType !== columnMetadata.generatedType ||
+                tableColumn.isUnique !==
+                    this.normalizeIsUnique(columnMetadata) ||
+                (tableColumn.enum &&
+                    columnMetadata.enum &&
+                    !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val) => val + "")));
+            // DEBUG SECTION
+            // if (isColumnChanged) {
+            //     console.log("table:", columnMetadata.entityMetadata.tableName)
+            //     console.log(
+            //         "name:",
+            //         tableColumn.name,
+            //         columnMetadata.databaseName,
+            //     )
+            //     console.log(
+            //         "type:",
+            //         tableColumn.type,
+            //         this.normalizeType(columnMetadata),
+            //         this.compareColumnType(tableColumn, columnMetadata),
+            //     )
+            //     console.log(
+            //         "length:",
+            //         tableColumn.length,
+            //         columnMetadata.length,
+            //         this.compareColumnLength(tableColumn, columnMetadata),
+            //     )
+            //     console.log(
+            //         "precision:",
+            //         tableColumn.precision,
+            //         columnMetadata.precision,
+            //     )
+            //     console.log("scale:", tableColumn.scale, columnMetadata.scale)
+            //     console.log(
+            //         "isGenerated:",
+            //         tableColumn.isGenerated,
+            //         columnMetadata.isGenerated,
+            //     )
+            //     console.log(
+            //         "isGenerated 2:",
+            //         !tableColumn.isGenerated &&
+            //             this.lowerDefaultValueIfNecessary(
+            //                 this.normalizeDefault(columnMetadata),
+            //             ) !==
+            //                 this.lowerDefaultValueIfNecessary(
+            //                     tableColumn.default,
+            //                 ),
+            //     )
+            //     console.log(
+            //         "isPrimary:",
+            //         tableColumn.isPrimary,
+            //         columnMetadata.isPrimary,
+            //     )
+            //     console.log(
+            //         "isNullable:",
+            //         tableColumn.isNullable,
+            //         columnMetadata.isNullable,
+            //     )
+            //     console.log(
+            //         "asExpression:",
+            //         tableColumn.asExpression,
+            //         columnMetadata.asExpression,
+            //     )
+            //     console.log(
+            //         "generatedType:",
+            //         tableColumn.generatedType,
+            //         columnMetadata.generatedType,
+            //     )
+            //     console.log(
+            //         "isUnique:",
+            //         tableColumn.isUnique,
+            //         this.normalizeIsUnique(columnMetadata),
+            //     )
+            //     console.log("==========================================")
+            // }
+            return isColumnChanged;
+        });
+    }
+    /**
+     * Returns true if driver supports RETURNING / OUTPUT statement.
+     */
+    isReturningSqlSupported() {
+        if (this.options.options &&
+            this.options.options.disableOutputReturning) {
+            return false;
+        }
+        return true;
+    }
+    /**
+     * Returns true if driver supports uuid values generation on its own.
+     */
+    isUUIDGenerationSupported() {
+        return true;
+    }
+    /**
+     * Returns true if driver supports fulltext indices.
+     */
+    isFullTextColumnTypeSupported() {
+        return false;
+    }
+    /**
+     * Creates an escaped parameter.
+     */
+    createParameter(parameterName, index) {
+        return this.parametersPrefix + index;
+    }
+    // -------------------------------------------------------------------------
+    // Public Methods
+    // -------------------------------------------------------------------------
+    /**
+     * Sql server's parameters needs to be wrapped into special object with type information about this value.
+     * This method wraps given value into MssqlParameter based on its column definition.
+     */
+    parametrizeValue(column, value) {
+        // if its already MssqlParameter then simply return it
+        if (InstanceChecker_1.InstanceChecker.isMssqlParameter(value))
+            return value;
+        const normalizedType = this.normalizeType({ type: column.type });
+        if (column.length) {
+            return new MssqlParameter_1.MssqlParameter(value, normalizedType, column.length);
+        }
+        else if (column.precision !== null &&
+            column.precision !== undefined &&
+            column.scale !== null &&
+            column.scale !== undefined) {
+            return new MssqlParameter_1.MssqlParameter(value, normalizedType, column.precision, column.scale);
+        }
+        else if (column.precision !== null &&
+            column.precision !== undefined) {
+            return new MssqlParameter_1.MssqlParameter(value, normalizedType, column.precision);
+        }
+        else if (column.scale !== null && column.scale !== undefined) {
+            return new MssqlParameter_1.MssqlParameter(value, normalizedType, column.scale);
+        }
+        return new MssqlParameter_1.MssqlParameter(value, normalizedType);
+    }
+    /**
+     * Sql server's parameters needs to be wrapped into special object with type information about this value.
+     * This method wraps all values of the given object into MssqlParameter based on their column definitions in the given table.
+     */
+    parametrizeMap(tablePath, map) {
+        // find metadata for the given table
+        if (!this.connection.hasMetadata(tablePath))
+            // if no metadata found then we can't proceed because we don't have columns and their types
+            return map;
+        const metadata = this.connection.getMetadata(tablePath);
+        return Object.keys(map).reduce((newMap, key) => {
+            const value = map[key];
+            // find column metadata
+            const column = metadata.findColumnWithDatabaseName(key);
+            if (!column)
+                // if we didn't find a column then we can't proceed because we don't have a column type
+                return value;
+            newMap[key] = this.parametrizeValue(column, value);
+            return newMap;
+        }, {});
+    }
+    buildTableVariableDeclaration(identifier, columns) {
+        const outputColumns = columns.map((column) => {
+            return `${this.escape(column.databaseName)} ${this.createFullType(new TableColumn_1.TableColumn({
+                name: column.databaseName,
+                type: this.normalizeType(column),
+                length: column.length,
+                isNullable: column.isNullable,
+                isArray: column.isArray,
+            }))}`;
+        });
+        return `DECLARE ${identifier} TABLE (${outputColumns.join(", ")})`;
+    }
+    // -------------------------------------------------------------------------
+    // Protected Methods
+    // -------------------------------------------------------------------------
+    /**
+     * If driver dependency is not given explicitly, then try to load it via "require".
+     */
+    loadDependencies() {
+        try {
+            const mssql = this.options.driver || require("mssql");
+            this.mssql = mssql;
+        }
+        catch (e) {
+            // todo: better error for browser env
+            throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("SQL Server", "mssql");
+        }
+    }
+    compareColumnType(tableColumn, columnMetadata) {
+        // The Database Engine determines the data type of the computed column by applying the rules
+        // of data type precedence to the expressions specified in the formula.
+        if (columnMetadata.asExpression)
+            return false;
+        return tableColumn.type !== this.normalizeType(columnMetadata);
+    }
+    compareColumnLength(tableColumn, columnMetadata) {
+        // The Database Engine determines the data type of the computed column by applying the rules
+        // of data type precedence to the expressions specified in the formula.
+        if (columnMetadata.asExpression)
+            return false;
+        return (tableColumn.length.toUpperCase() !==
+            this.getColumnLength(columnMetadata).toUpperCase());
+    }
+    lowerDefaultValueIfNecessary(value) {
+        // SqlServer saves function calls in default value as lowercase https://github.com/typeorm/typeorm/issues/2733
+        if (!value) {
+            return value;
+        }
+        return value
+            .split(`'`)
+            .map((v, i) => {
+            return i % 2 === 1 ? v : v.toLowerCase();
+        })
+            .join(`'`);
+    }
+    /**
+     * Creates a new connection pool for a given database credentials.
+     */
+    createPool(options, credentials) {
+        credentials = Object.assign({}, credentials, DriverUtils_1.DriverUtils.buildDriverOptions(credentials)); // todo: do it better way
+        // todo: credentials.domain is deprecation. remove it in future
+        const authentication = !credentials.domain
+            ? credentials.authentication
+            : {
+                type: "ntlm",
+                options: {
+                    domain: credentials.domain,
+                    userName: credentials.username,
+                    password: credentials.password,
+                },
+            };
+        // build connection options for the driver
+        const connectionOptions = Object.assign({}, {
+            connectionTimeout: this.options.connectionTimeout,
+            requestTimeout: this.options.requestTimeout,
+            stream: this.options.stream,
+            pool: this.options.pool,
+            options: this.options.options,
+        }, {
+            server: credentials.host,
+            database: credentials.database,
+            port: credentials.port,
+            user: credentials.username,
+            password: credentials.password,
+            authentication: authentication,
+        }, options.extra || {});
+        // set default useUTC option if it hasn't been set
+        if (!connectionOptions.options) {
+            connectionOptions.options = { useUTC: false };
+        }
+        else if (!connectionOptions.options.useUTC) {
+            Object.assign(connectionOptions.options, { useUTC: false });
+        }
+        // Match the next release of tedious for configuration options
+        // Also prevents warning messages.
+        Object.assign(connectionOptions.options, { enableArithAbort: true });
+        // pooling is enabled either when its set explicitly to true,
+        // either when its not defined at all (e.g. enabled by default)
+        return new Promise((ok, fail) => {
+            const pool = new this.mssql.ConnectionPool(connectionOptions);
+            const { logger } = this.connection;
+            const poolErrorHandler = (options.pool && options.pool.errorHandler) ||
+                ((error) => logger.log("warn", `MSSQL pool raised an error. ${error}`));
+            /**
+             * Attaching an error handler to pool errors is essential, as, otherwise, errors raised will go unhandled and
+             * cause the hosting app to crash.
+             */
+            pool.on("error", poolErrorHandler);
+            const connection = pool.connect((err) => {
+                if (err)
+                    return fail(err);
+                ok(connection);
+            });
+        });
+    }
+}
+exports.SqlServerDriver = SqlServerDriver;
+
+//# sourceMappingURL=SqlServerDriver.js.map
diff --git a/driver/sqlserver/SqlServerDriver.js.map b/driver/sqlserver/SqlServerDriver.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f10ae256abe777f95ceca3f8582365030a8fb76e
--- /dev/null
+++ b/driver/sqlserver/SqlServerDriver.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/SqlServerDriver.ts"],"names":[],"mappings":"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","file":"SqlServerDriver.js","sourcesContent":["import { Driver } from \"../Driver\"\nimport { ConnectionIsNotSetError } from \"../../error/ConnectionIsNotSetError\"\nimport { DriverPackageNotInstalledError } from \"../../error/DriverPackageNotInstalledError\"\nimport { DriverUtils } from \"../DriverUtils\"\nimport { CteCapabilities } from \"../types/CteCapabilities\"\nimport { SqlServerQueryRunner } from \"./SqlServerQueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { DateUtils } from \"../../util/DateUtils\"\nimport { PlatformTools } from \"../../platform/PlatformTools\"\nimport { DataSource } from \"../../data-source/DataSource\"\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\"\nimport { SqlServerConnectionOptions } from \"./SqlServerConnectionOptions\"\nimport { MappedColumnTypes } from \"../types/MappedColumnTypes\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { DataTypeDefaults } from \"../types/DataTypeDefaults\"\nimport { MssqlParameter } from \"./MssqlParameter\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { SqlServerConnectionCredentialsOptions } from \"./SqlServerConnectionCredentialsOptions\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { TypeORMError } from \"../../error\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\nimport { UpsertType } from \"../types/UpsertType\"\n\n/**\n * Organizes communication with SQL Server DBMS.\n */\nexport class SqlServerDriver implements Driver {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by driver.\n     */\n    connection: DataSource\n\n    /**\n     * SQL Server library.\n     */\n    mssql: any\n\n    /**\n     * Pool for master database.\n     */\n    master: any\n\n    /**\n     * Pool for slave databases.\n     * Used in replication.\n     */\n    slaves: any[] = []\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection options.\n     */\n    options: SqlServerConnectionOptions\n\n    /**\n     * Database name used to perform all write queries.\n     */\n    database?: string\n\n    /**\n     * Schema name used to perform all write queries.\n     */\n    schema?: string\n\n    /**\n     * Schema that's used internally by SQL Server for object resolution.\n     *\n     * Because we never set this we have to track it in separately from the `schema` so\n     * we know when we have to specify the full schema or not.\n     *\n     * In most cases this will be `dbo`.\n     */\n    searchSchema?: string\n\n    /**\n     * Indicates if replication is enabled.\n     */\n    isReplicated: boolean = false\n\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    treeSupport = true\n\n    /**\n     * Represent transaction support by this driver\n     */\n    transactionSupport = \"simple\" as const\n\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql\n     */\n    supportedDataTypes: ColumnType[] = [\n        \"int\",\n        \"bigint\",\n        \"bit\",\n        \"decimal\",\n        \"money\",\n        \"numeric\",\n        \"smallint\",\n        \"smallmoney\",\n        \"tinyint\",\n        \"float\",\n        \"real\",\n        \"date\",\n        \"datetime2\",\n        \"datetime\",\n        \"datetimeoffset\",\n        \"smalldatetime\",\n        \"time\",\n        \"char\",\n        \"varchar\",\n        \"text\",\n        \"nchar\",\n        \"nvarchar\",\n        \"ntext\",\n        \"binary\",\n        \"image\",\n        \"varbinary\",\n        \"hierarchyid\",\n        \"sql_variant\",\n        \"timestamp\",\n        \"uniqueidentifier\",\n        \"xml\",\n        \"geometry\",\n        \"geography\",\n        \"rowversion\",\n    ]\n\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n    supportedUpsertTypes: UpsertType[] = []\n\n    /**\n     * Gets list of spatial column data types.\n     */\n    spatialTypes: ColumnType[] = [\"geometry\", \"geography\"]\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withLengthColumnTypes: ColumnType[] = [\n        \"char\",\n        \"varchar\",\n        \"nchar\",\n        \"nvarchar\",\n        \"binary\",\n        \"varbinary\",\n    ]\n\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    withPrecisionColumnTypes: ColumnType[] = [\n        \"decimal\",\n        \"numeric\",\n        \"time\",\n        \"datetime2\",\n        \"datetimeoffset\",\n    ]\n\n    /**\n     * Gets list of column data types that support scale by a driver.\n     */\n    withScaleColumnTypes: ColumnType[] = [\"decimal\", \"numeric\"]\n\n    /**\n     * Orm has special columns and we need to know what database column types should be for those types.\n     * Column types are driver dependant.\n     */\n    mappedDataTypes: MappedColumnTypes = {\n        createDate: \"datetime2\",\n        createDateDefault: \"getdate()\",\n        updateDate: \"datetime2\",\n        updateDateDefault: \"getdate()\",\n        deleteDate: \"datetime2\",\n        deleteDateNullable: true,\n        version: \"int\",\n        treeLevel: \"int\",\n        migrationId: \"int\",\n        migrationName: \"varchar\",\n        migrationTimestamp: \"bigint\",\n        cacheId: \"int\",\n        cacheIdentifier: \"nvarchar\",\n        cacheTime: \"bigint\",\n        cacheDuration: \"int\",\n        cacheQuery: \"nvarchar(MAX)\" as any,\n        cacheResult: \"nvarchar(MAX)\" as any,\n        metadataType: \"varchar\",\n        metadataDatabase: \"varchar\",\n        metadataSchema: \"varchar\",\n        metadataTable: \"varchar\",\n        metadataName: \"varchar\",\n        metadataValue: \"nvarchar(MAX)\" as any,\n    }\n\n    /**\n     * The prefix used for the parameters\n     */\n    parametersPrefix: string = \"@\"\n\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    dataTypeDefaults: DataTypeDefaults = {\n        char: { length: 1 },\n        nchar: { length: 1 },\n        varchar: { length: 255 },\n        nvarchar: { length: 255 },\n        binary: { length: 1 },\n        varbinary: { length: 1 },\n        decimal: { precision: 18, scale: 0 },\n        numeric: { precision: 18, scale: 0 },\n        time: { precision: 7 },\n        datetime2: { precision: 7 },\n        datetimeoffset: { precision: 7 },\n    }\n\n    cteCapabilities: CteCapabilities = {\n        enabled: true,\n        // todo: enable it for SQL Server - it's partially supported, but there are issues with generation of non-standard OUTPUT clause\n        writable: false,\n    }\n\n    /**\n     * Max length allowed by MSSQL Server for aliases (identifiers).\n     * @see https://docs.microsoft.com/en-us/sql/sql-server/maximum-capacity-specifications-for-sql-server\n     */\n    maxAliasLength = 128\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: DataSource) {\n        this.connection = connection\n        this.options = connection.options as SqlServerConnectionOptions\n        this.isReplicated = this.options.replication ? true : false\n\n        // load mssql package\n        this.loadDependencies()\n\n        this.database = DriverUtils.buildDriverOptions(\n            this.options.replication\n                ? this.options.replication.master\n                : this.options,\n        ).database\n        this.schema = DriverUtils.buildDriverOptions(this.options).schema\n\n        // Object.assign(connection.options, DriverUtils.buildDriverOptions(connection.options)); // todo: do it better way\n        // validate options to make sure everything is set\n        // if (!this.options.host)\n        // throw new DriverOptionNotSetError(\"host\");\n        // if (!this.options.username)\n        //     throw new DriverOptionNotSetError(\"username\");\n        // if (!this.options.database)\n        //     throw new DriverOptionNotSetError(\"database\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs connection to the database.\n     * Based on pooling options, it can either create connection immediately,\n     * either create a pool and create connection when needed.\n     */\n    async connect(): Promise<void> {\n        if (this.options.replication) {\n            this.slaves = await Promise.all(\n                this.options.replication.slaves.map((slave) => {\n                    return this.createPool(this.options, slave)\n                }),\n            )\n            this.master = await this.createPool(\n                this.options,\n                this.options.replication.master,\n            )\n        } else {\n            this.master = await this.createPool(this.options, this.options)\n        }\n\n        if (!this.database || !this.searchSchema) {\n            const queryRunner = await this.createQueryRunner(\"master\")\n\n            if (!this.database) {\n                this.database = await queryRunner.getCurrentDatabase()\n            }\n\n            if (!this.searchSchema) {\n                this.searchSchema = await queryRunner.getCurrentSchema()\n            }\n\n            await queryRunner.release()\n        }\n\n        if (!this.schema) {\n            this.schema = this.searchSchema\n        }\n    }\n\n    /**\n     * Makes any action after connection (e.g. create extensions in Postgres driver).\n     */\n    afterConnect(): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Closes connection with the database.\n     */\n    async disconnect(): Promise<void> {\n        if (!this.master)\n            return Promise.reject(new ConnectionIsNotSetError(\"mssql\"))\n\n        await this.closePool(this.master)\n        await Promise.all(this.slaves.map((slave) => this.closePool(slave)))\n        this.master = undefined\n        this.slaves = []\n    }\n\n    /**\n     * Closes connection pool.\n     */\n    protected async closePool(pool: any): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            pool.close((err: any) => (err ? fail(err) : ok()))\n        })\n    }\n\n    /**\n     * Creates a schema builder used to build and sync a schema.\n     */\n    createSchemaBuilder() {\n        return new RdbmsSchemaBuilder(this.connection)\n    }\n\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    createQueryRunner(mode: ReplicationMode) {\n        return new SqlServerQueryRunner(this, mode)\n    }\n\n    /**\n     * Replaces parameters in the given sql with special escaping character\n     * and an array of parameter names to be passed to a query.\n     */\n    escapeQueryWithParameters(\n        sql: string,\n        parameters: ObjectLiteral,\n        nativeParameters: ObjectLiteral,\n    ): [string, any[]] {\n        const escapedParameters: any[] = Object.keys(nativeParameters).map(\n            (key) => nativeParameters[key],\n        )\n        if (!parameters || !Object.keys(parameters).length)\n            return [sql, escapedParameters]\n\n        const parameterIndexMap = new Map<string, number>()\n        sql = sql.replace(\n            /:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g,\n            (full, isArray: string, key: string): string => {\n                if (!parameters.hasOwnProperty(key)) {\n                    return full\n                }\n\n                if (parameterIndexMap.has(key)) {\n                    return this.parametersPrefix + parameterIndexMap.get(key)\n                }\n\n                let value: any = parameters[key]\n\n                if (isArray) {\n                    return value\n                        .map((v: any) => {\n                            escapedParameters.push(v)\n                            return this.createParameter(\n                                key,\n                                escapedParameters.length - 1,\n                            )\n                        })\n                        .join(\", \")\n                }\n\n                if (typeof value === \"function\") {\n                    return value()\n                }\n\n                escapedParameters.push(value)\n                parameterIndexMap.set(key, escapedParameters.length - 1)\n                return this.createParameter(key, escapedParameters.length - 1)\n            },\n        ) // todo: make replace only in value statements, otherwise problems\n        return [sql, escapedParameters]\n    }\n\n    /**\n     * Escapes a column name.\n     */\n    escape(columnName: string): string {\n        return `\"${columnName}\"`\n    }\n\n    /**\n     * Build full table name with database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     */\n    buildTableName(\n        tableName: string,\n        schema?: string,\n        database?: string,\n    ): string {\n        let tablePath = [tableName]\n\n        if (schema) {\n            tablePath.unshift(schema)\n        }\n\n        if (database) {\n            if (!schema) {\n                tablePath.unshift(\"\")\n            }\n\n            tablePath.unshift(database)\n        }\n\n        return tablePath.join(\".\")\n    }\n\n    /**\n     * Parse a target table name or other types and return a normalized table definition.\n     */\n    parseTableName(\n        target: EntityMetadata | Table | View | TableForeignKey | string,\n    ): { database?: string; schema?: string; tableName: string } {\n        const driverDatabase = this.database\n        const driverSchema = this.schema\n\n        if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {\n            const parsed = this.parseTableName(target.name)\n\n            return {\n                database: target.database || parsed.database || driverDatabase,\n                schema: target.schema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (InstanceChecker.isTableForeignKey(target)) {\n            const parsed = this.parseTableName(target.referencedTableName)\n\n            return {\n                database:\n                    target.referencedDatabase ||\n                    parsed.database ||\n                    driverDatabase,\n                schema:\n                    target.referencedSchema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (InstanceChecker.isEntityMetadata(target)) {\n            // EntityMetadata tableName is never a path\n\n            return {\n                database: target.database || driverDatabase,\n                schema: target.schema || driverSchema,\n                tableName: target.tableName,\n            }\n        }\n\n        const parts = target.split(\".\")\n\n        if (parts.length === 3) {\n            return {\n                database: parts[0] || driverDatabase,\n                schema: parts[1] || driverSchema,\n                tableName: parts[2],\n            }\n        } else if (parts.length === 2) {\n            return {\n                database: driverDatabase,\n                schema: parts[0],\n                tableName: parts[1],\n            }\n        } else {\n            return {\n                database: driverDatabase,\n                schema: driverSchema,\n                tableName: target,\n            }\n        }\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type and metadata.\n     */\n    preparePersistentValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformTo(\n                columnMetadata.transformer,\n                value,\n            )\n\n        if (value === null || value === undefined) return value\n\n        if (columnMetadata.type === Boolean) {\n            return value === true ? 1 : 0\n        } else if (columnMetadata.type === \"date\") {\n            return DateUtils.mixedDateToDate(value)\n        } else if (columnMetadata.type === \"time\") {\n            return DateUtils.mixedTimeToDate(value)\n        } else if (\n            columnMetadata.type === \"datetime\" ||\n            columnMetadata.type === \"smalldatetime\" ||\n            columnMetadata.type === Date\n        ) {\n            return DateUtils.mixedDateToDate(value, false, false)\n        } else if (\n            columnMetadata.type === \"datetime2\" ||\n            columnMetadata.type === \"datetimeoffset\"\n        ) {\n            return DateUtils.mixedDateToDate(value, false, true)\n        } else if (columnMetadata.type === \"simple-array\") {\n            return DateUtils.simpleArrayToString(value)\n        } else if (columnMetadata.type === \"simple-json\") {\n            return DateUtils.simpleJsonToString(value)\n        } else if (columnMetadata.type === \"simple-enum\") {\n            return DateUtils.simpleEnumToString(value)\n        }\n\n        return value\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type or metadata.\n     */\n    prepareHydratedValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (value === null || value === undefined)\n            return columnMetadata.transformer\n                ? ApplyValueTransformers.transformFrom(\n                      columnMetadata.transformer,\n                      value,\n                  )\n                : value\n\n        if (columnMetadata.type === Boolean) {\n            value = value ? true : false\n        } else if (\n            columnMetadata.type === \"datetime\" ||\n            columnMetadata.type === Date ||\n            columnMetadata.type === \"datetime2\" ||\n            columnMetadata.type === \"smalldatetime\" ||\n            columnMetadata.type === \"datetimeoffset\"\n        ) {\n            value = DateUtils.normalizeHydratedDate(value)\n        } else if (columnMetadata.type === \"date\") {\n            value = DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"time\") {\n            value = DateUtils.mixedTimeToString(value)\n        } else if (columnMetadata.type === \"simple-array\") {\n            value = DateUtils.stringToSimpleArray(value)\n        } else if (columnMetadata.type === \"simple-json\") {\n            value = DateUtils.stringToSimpleJson(value)\n        } else if (columnMetadata.type === \"simple-enum\") {\n            value = DateUtils.stringToSimpleEnum(value, columnMetadata)\n        } else if (columnMetadata.type === Number) {\n            // convert to number if number\n            value = !isNaN(+value) ? parseInt(value) : value\n        }\n\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformFrom(\n                columnMetadata.transformer,\n                value,\n            )\n\n        return value\n    }\n\n    /**\n     * Creates a database type from a given column metadata.\n     */\n    normalizeType(column: {\n        type?: ColumnType\n        length?: number | string\n        precision?: number | null\n        scale?: number\n    }): string {\n        if (column.type === Number || column.type === \"integer\") {\n            return \"int\"\n        } else if (column.type === String) {\n            return \"nvarchar\"\n        } else if (column.type === Date) {\n            return \"datetime\"\n        } else if (column.type === Boolean) {\n            return \"bit\"\n        } else if ((column.type as any) === Buffer) {\n            return \"binary\"\n        } else if (column.type === \"uuid\") {\n            return \"uniqueidentifier\"\n        } else if (\n            column.type === \"simple-array\" ||\n            column.type === \"simple-json\"\n        ) {\n            return \"ntext\"\n        } else if (column.type === \"simple-enum\") {\n            return \"nvarchar\"\n        } else if (column.type === \"dec\") {\n            return \"decimal\"\n        } else if (column.type === \"double precision\") {\n            return \"float\"\n        } else if (column.type === \"rowversion\") {\n            return \"timestamp\" // the rowversion type's name in SQL server metadata is timestamp\n        } else {\n            return (column.type as string) || \"\"\n        }\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     */\n    normalizeDefault(columnMetadata: ColumnMetadata): string | undefined {\n        const defaultValue = columnMetadata.default\n\n        if (typeof defaultValue === \"number\") {\n            return `${defaultValue}`\n        }\n\n        if (typeof defaultValue === \"boolean\") {\n            return defaultValue ? \"1\" : \"0\"\n        }\n\n        if (typeof defaultValue === \"function\") {\n            const value = defaultValue()\n            if (value.toUpperCase() === \"CURRENT_TIMESTAMP\") {\n                return \"getdate()\"\n            }\n            return value\n        }\n\n        if (typeof defaultValue === \"string\") {\n            return `'${defaultValue}'`\n        }\n\n        if (defaultValue === undefined || defaultValue === null) {\n            return undefined\n        }\n\n        return `${defaultValue}`\n    }\n\n    /**\n     * Normalizes \"isUnique\" value of the column.\n     */\n    normalizeIsUnique(column: ColumnMetadata): boolean {\n        return column.entityMetadata.uniques.some(\n            (uq) => uq.columns.length === 1 && uq.columns[0] === column,\n        )\n    }\n\n    /**\n     * Returns default column lengths, which is required on column creation.\n     */\n    getColumnLength(column: ColumnMetadata | TableColumn): string {\n        if (column.length) return column.length.toString()\n\n        if (\n            column.type === \"varchar\" ||\n            column.type === \"nvarchar\" ||\n            column.type === String\n        )\n            return \"255\"\n\n        return \"\"\n    }\n\n    /**\n     * Creates column type definition including length, precision and scale\n     */\n    createFullType(column: TableColumn): string {\n        // The Database Engine determines the data type of the computed column by applying the rules\n        // of data type precedence to the expressions specified in the formula.\n        if (column.asExpression) return \"\"\n\n        let type = column.type\n\n        // used 'getColumnLength()' method, because SqlServer sets `varchar` and `nvarchar` length to 1 by default.\n        if (this.getColumnLength(column)) {\n            type += `(${this.getColumnLength(column)})`\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined &&\n            column.scale !== null &&\n            column.scale !== undefined\n        ) {\n            type += `(${column.precision},${column.scale})`\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined\n        ) {\n            type += `(${column.precision})`\n        }\n\n        if (column.isArray) type += \" array\"\n\n        return type\n    }\n\n    /**\n     * Obtains a new database connection to a master server.\n     * Used for replication.\n     * If replication is not setup then returns default connection's database connection.\n     */\n    obtainMasterConnection(): Promise<any> {\n        if (!this.master) {\n            return Promise.reject(new TypeORMError(\"Driver not Connected\"))\n        }\n\n        return Promise.resolve(this.master)\n    }\n\n    /**\n     * Obtains a new database connection to a slave server.\n     * Used for replication.\n     * If replication is not setup then returns master (default) connection's database connection.\n     */\n    obtainSlaveConnection(): Promise<any> {\n        if (!this.slaves.length) return this.obtainMasterConnection()\n\n        const random = Math.floor(Math.random() * this.slaves.length)\n        return Promise.resolve(this.slaves[random])\n    }\n\n    /**\n     * Creates generated map of values generated or returned by database after INSERT query.\n     */\n    createGeneratedMap(metadata: EntityMetadata, insertResult: ObjectLiteral) {\n        if (!insertResult) return undefined\n\n        return Object.keys(insertResult).reduce((map, key) => {\n            const column = metadata.findColumnWithDatabaseName(key)\n            if (column) {\n                OrmUtils.mergeDeep(\n                    map,\n                    column.createValueMap(\n                        this.prepareHydratedValue(insertResult[key], column),\n                    ),\n                )\n            }\n            return map\n        }, {} as ObjectLiteral)\n    }\n\n    /**\n     * Differentiate columns of this table and columns from the given column metadatas columns\n     * and returns only changed.\n     */\n    findChangedColumns(\n        tableColumns: TableColumn[],\n        columnMetadatas: ColumnMetadata[],\n    ): ColumnMetadata[] {\n        return columnMetadatas.filter((columnMetadata) => {\n            const tableColumn = tableColumns.find(\n                (c) => c.name === columnMetadata.databaseName,\n            )\n            if (!tableColumn) return false // we don't need new columns, we only need exist and changed\n\n            const isColumnChanged =\n                tableColumn.name !== columnMetadata.databaseName ||\n                this.compareColumnType(tableColumn, columnMetadata) ||\n                this.compareColumnLength(tableColumn, columnMetadata) ||\n                tableColumn.precision !== columnMetadata.precision ||\n                tableColumn.scale !== columnMetadata.scale ||\n                // || tableColumn.comment !== columnMetadata.comment || // todo\n                tableColumn.isGenerated !== columnMetadata.isGenerated ||\n                (!tableColumn.isGenerated &&\n                    this.lowerDefaultValueIfNecessary(\n                        this.normalizeDefault(columnMetadata),\n                    ) !==\n                        this.lowerDefaultValueIfNecessary(\n                            tableColumn.default,\n                        )) || // we included check for generated here, because generated columns already can have default values\n                tableColumn.isPrimary !== columnMetadata.isPrimary ||\n                tableColumn.isNullable !== columnMetadata.isNullable ||\n                tableColumn.asExpression !== columnMetadata.asExpression ||\n                tableColumn.generatedType !== columnMetadata.generatedType ||\n                tableColumn.isUnique !==\n                    this.normalizeIsUnique(columnMetadata) ||\n                (tableColumn.enum &&\n                    columnMetadata.enum &&\n                    !OrmUtils.isArraysEqual(\n                        tableColumn.enum,\n                        columnMetadata.enum.map((val) => val + \"\"),\n                    ))\n\n            // DEBUG SECTION\n            // if (isColumnChanged) {\n            //     console.log(\"table:\", columnMetadata.entityMetadata.tableName)\n            //     console.log(\n            //         \"name:\",\n            //         tableColumn.name,\n            //         columnMetadata.databaseName,\n            //     )\n            //     console.log(\n            //         \"type:\",\n            //         tableColumn.type,\n            //         this.normalizeType(columnMetadata),\n            //         this.compareColumnType(tableColumn, columnMetadata),\n            //     )\n            //     console.log(\n            //         \"length:\",\n            //         tableColumn.length,\n            //         columnMetadata.length,\n            //         this.compareColumnLength(tableColumn, columnMetadata),\n            //     )\n            //     console.log(\n            //         \"precision:\",\n            //         tableColumn.precision,\n            //         columnMetadata.precision,\n            //     )\n            //     console.log(\"scale:\", tableColumn.scale, columnMetadata.scale)\n            //     console.log(\n            //         \"isGenerated:\",\n            //         tableColumn.isGenerated,\n            //         columnMetadata.isGenerated,\n            //     )\n            //     console.log(\n            //         \"isGenerated 2:\",\n            //         !tableColumn.isGenerated &&\n            //             this.lowerDefaultValueIfNecessary(\n            //                 this.normalizeDefault(columnMetadata),\n            //             ) !==\n            //                 this.lowerDefaultValueIfNecessary(\n            //                     tableColumn.default,\n            //                 ),\n            //     )\n            //     console.log(\n            //         \"isPrimary:\",\n            //         tableColumn.isPrimary,\n            //         columnMetadata.isPrimary,\n            //     )\n            //     console.log(\n            //         \"isNullable:\",\n            //         tableColumn.isNullable,\n            //         columnMetadata.isNullable,\n            //     )\n            //     console.log(\n            //         \"asExpression:\",\n            //         tableColumn.asExpression,\n            //         columnMetadata.asExpression,\n            //     )\n            //     console.log(\n            //         \"generatedType:\",\n            //         tableColumn.generatedType,\n            //         columnMetadata.generatedType,\n            //     )\n            //     console.log(\n            //         \"isUnique:\",\n            //         tableColumn.isUnique,\n            //         this.normalizeIsUnique(columnMetadata),\n            //     )\n            //     console.log(\"==========================================\")\n            // }\n\n            return isColumnChanged\n        })\n    }\n\n    /**\n     * Returns true if driver supports RETURNING / OUTPUT statement.\n     */\n    isReturningSqlSupported(): boolean {\n        if (\n            this.options.options &&\n            this.options.options.disableOutputReturning\n        ) {\n            return false\n        }\n        return true\n    }\n\n    /**\n     * Returns true if driver supports uuid values generation on its own.\n     */\n    isUUIDGenerationSupported(): boolean {\n        return true\n    }\n\n    /**\n     * Returns true if driver supports fulltext indices.\n     */\n    isFullTextColumnTypeSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Creates an escaped parameter.\n     */\n    createParameter(parameterName: string, index: number): string {\n        return this.parametersPrefix + index\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sql server's parameters needs to be wrapped into special object with type information about this value.\n     * This method wraps given value into MssqlParameter based on its column definition.\n     */\n    parametrizeValue(column: ColumnMetadata, value: any) {\n        // if its already MssqlParameter then simply return it\n        if (InstanceChecker.isMssqlParameter(value)) return value\n\n        const normalizedType = this.normalizeType({ type: column.type })\n        if (column.length) {\n            return new MssqlParameter(\n                value,\n                normalizedType as any,\n                column.length as any,\n            )\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined &&\n            column.scale !== null &&\n            column.scale !== undefined\n        ) {\n            return new MssqlParameter(\n                value,\n                normalizedType as any,\n                column.precision,\n                column.scale,\n            )\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined\n        ) {\n            return new MssqlParameter(\n                value,\n                normalizedType as any,\n                column.precision,\n            )\n        } else if (column.scale !== null && column.scale !== undefined) {\n            return new MssqlParameter(\n                value,\n                normalizedType as any,\n                column.scale,\n            )\n        }\n\n        return new MssqlParameter(value, normalizedType as any)\n    }\n\n    /**\n     * Sql server's parameters needs to be wrapped into special object with type information about this value.\n     * This method wraps all values of the given object into MssqlParameter based on their column definitions in the given table.\n     */\n    parametrizeMap(tablePath: string, map: ObjectLiteral): ObjectLiteral {\n        // find metadata for the given table\n        if (!this.connection.hasMetadata(tablePath))\n            // if no metadata found then we can't proceed because we don't have columns and their types\n            return map\n        const metadata = this.connection.getMetadata(tablePath)\n\n        return Object.keys(map).reduce((newMap, key) => {\n            const value = map[key]\n\n            // find column metadata\n            const column = metadata.findColumnWithDatabaseName(key)\n            if (!column)\n                // if we didn't find a column then we can't proceed because we don't have a column type\n                return value\n\n            newMap[key] = this.parametrizeValue(column, value)\n            return newMap\n        }, {} as ObjectLiteral)\n    }\n\n    buildTableVariableDeclaration(\n        identifier: string,\n        columns: ColumnMetadata[],\n    ): string {\n        const outputColumns = columns.map((column) => {\n            return `${this.escape(column.databaseName)} ${this.createFullType(\n                new TableColumn({\n                    name: column.databaseName,\n                    type: this.normalizeType(column),\n                    length: column.length,\n                    isNullable: column.isNullable,\n                    isArray: column.isArray,\n                }),\n            )}`\n        })\n\n        return `DECLARE ${identifier} TABLE (${outputColumns.join(\", \")})`\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * If driver dependency is not given explicitly, then try to load it via \"require\".\n     */\n    protected loadDependencies(): void {\n        try {\n            const mssql = this.options.driver || PlatformTools.load(\"mssql\")\n            this.mssql = mssql\n        } catch (e) {\n            // todo: better error for browser env\n            throw new DriverPackageNotInstalledError(\"SQL Server\", \"mssql\")\n        }\n    }\n\n    protected compareColumnType(\n        tableColumn: TableColumn,\n        columnMetadata: ColumnMetadata,\n    ): boolean {\n        // The Database Engine determines the data type of the computed column by applying the rules\n        // of data type precedence to the expressions specified in the formula.\n        if (columnMetadata.asExpression) return false\n\n        return tableColumn.type !== this.normalizeType(columnMetadata)\n    }\n\n    protected compareColumnLength(\n        tableColumn: TableColumn,\n        columnMetadata: ColumnMetadata,\n    ): boolean {\n        // The Database Engine determines the data type of the computed column by applying the rules\n        // of data type precedence to the expressions specified in the formula.\n        if (columnMetadata.asExpression) return false\n\n        return (\n            tableColumn.length.toUpperCase() !==\n            this.getColumnLength(columnMetadata).toUpperCase()\n        )\n    }\n\n    protected lowerDefaultValueIfNecessary(value: string | undefined) {\n        // SqlServer saves function calls in default value as lowercase https://github.com/typeorm/typeorm/issues/2733\n        if (!value) {\n            return value\n        }\n        return value\n            .split(`'`)\n            .map((v, i) => {\n                return i % 2 === 1 ? v : v.toLowerCase()\n            })\n            .join(`'`)\n    }\n\n    /**\n     * Creates a new connection pool for a given database credentials.\n     */\n    protected createPool(\n        options: SqlServerConnectionOptions,\n        credentials: SqlServerConnectionCredentialsOptions,\n    ): Promise<any> {\n        credentials = Object.assign(\n            {},\n            credentials,\n            DriverUtils.buildDriverOptions(credentials),\n        ) // todo: do it better way\n\n        // todo: credentials.domain is deprecation. remove it in future\n        const authentication = !credentials.domain\n            ? credentials.authentication\n            : {\n                  type: \"ntlm\",\n                  options: {\n                      domain: credentials.domain,\n                      userName: credentials.username,\n                      password: credentials.password,\n                  },\n              }\n        // build connection options for the driver\n        const connectionOptions = Object.assign(\n            {},\n            {\n                connectionTimeout: this.options.connectionTimeout,\n                requestTimeout: this.options.requestTimeout,\n                stream: this.options.stream,\n                pool: this.options.pool,\n                options: this.options.options,\n            },\n            {\n                server: credentials.host,\n                database: credentials.database,\n                port: credentials.port,\n                user: credentials.username,\n                password: credentials.password,\n                authentication: authentication,\n            },\n            options.extra || {},\n        )\n\n        // set default useUTC option if it hasn't been set\n        if (!connectionOptions.options) {\n            connectionOptions.options = { useUTC: false }\n        } else if (!connectionOptions.options.useUTC) {\n            Object.assign(connectionOptions.options, { useUTC: false })\n        }\n\n        // Match the next release of tedious for configuration options\n        // Also prevents warning messages.\n        Object.assign(connectionOptions.options, { enableArithAbort: true })\n\n        // pooling is enabled either when its set explicitly to true,\n        // either when its not defined at all (e.g. enabled by default)\n        return new Promise<void>((ok, fail) => {\n            const pool = new this.mssql.ConnectionPool(connectionOptions)\n\n            const { logger } = this.connection\n\n            const poolErrorHandler =\n                (options.pool && options.pool.errorHandler) ||\n                ((error: any) =>\n                    logger.log(\"warn\", `MSSQL pool raised an error. ${error}`))\n            /**\n             * Attaching an error handler to pool errors is essential, as, otherwise, errors raised will go unhandled and\n             * cause the hosting app to crash.\n             */\n            pool.on(\"error\", poolErrorHandler)\n\n            const connection = pool.connect((err: any) => {\n                if (err) return fail(err)\n                ok(connection)\n            })\n        })\n    }\n}\n"],"sourceRoot":"../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/SqlServerDriver.ts b/driver/sqlserver/SqlServerDriver.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b42d1ef00c151a1675826959b9373393cb3ce45d
--- /dev/null
+++ b/driver/sqlserver/SqlServerDriver.ts
@@ -0,0 +1,1154 @@
+import { Driver } from "../Driver"
+import { ConnectionIsNotSetError } from "../../error/ConnectionIsNotSetError"
+import { DriverPackageNotInstalledError } from "../../error/DriverPackageNotInstalledError"
+import { DriverUtils } from "../DriverUtils"
+import { CteCapabilities } from "../types/CteCapabilities"
+import { SqlServerQueryRunner } from "./SqlServerQueryRunner"
+import { ObjectLiteral } from "../../common/ObjectLiteral"
+import { ColumnMetadata } from "../../metadata/ColumnMetadata"
+import { DateUtils } from "../../util/DateUtils"
+import { PlatformTools } from "../../platform/PlatformTools"
+import { DataSource } from "../../data-source/DataSource"
+import { RdbmsSchemaBuilder } from "../../schema-builder/RdbmsSchemaBuilder"
+import { SqlServerConnectionOptions } from "./SqlServerConnectionOptions"
+import { MappedColumnTypes } from "../types/MappedColumnTypes"
+import { ColumnType } from "../types/ColumnTypes"
+import { DataTypeDefaults } from "../types/DataTypeDefaults"
+import { MssqlParameter } from "./MssqlParameter"
+import { TableColumn } from "../../schema-builder/table/TableColumn"
+import { SqlServerConnectionCredentialsOptions } from "./SqlServerConnectionCredentialsOptions"
+import { EntityMetadata } from "../../metadata/EntityMetadata"
+import { OrmUtils } from "../../util/OrmUtils"
+import { ApplyValueTransformers } from "../../util/ApplyValueTransformers"
+import { ReplicationMode } from "../types/ReplicationMode"
+import { Table } from "../../schema-builder/table/Table"
+import { View } from "../../schema-builder/view/View"
+import { TableForeignKey } from "../../schema-builder/table/TableForeignKey"
+import { TypeORMError } from "../../error"
+import { InstanceChecker } from "../../util/InstanceChecker"
+import { UpsertType } from "../types/UpsertType"
+
+/**
+ * Organizes communication with SQL Server DBMS.
+ */
+export class SqlServerDriver implements Driver {
+    // -------------------------------------------------------------------------
+    // Public Properties
+    // -------------------------------------------------------------------------
+
+    /**
+     * Connection used by driver.
+     */
+    connection: DataSource
+
+    /**
+     * SQL Server library.
+     */
+    mssql: any
+
+    /**
+     * Pool for master database.
+     */
+    master: any
+
+    /**
+     * Pool for slave databases.
+     * Used in replication.
+     */
+    slaves: any[] = []
+
+    // -------------------------------------------------------------------------
+    // Public Implemented Properties
+    // -------------------------------------------------------------------------
+
+    /**
+     * Connection options.
+     */
+    options: SqlServerConnectionOptions
+
+    /**
+     * Database name used to perform all write queries.
+     */
+    database?: string
+
+    /**
+     * Schema name used to perform all write queries.
+     */
+    schema?: string
+
+    /**
+     * Schema that's used internally by SQL Server for object resolution.
+     *
+     * Because we never set this we have to track it in separately from the `schema` so
+     * we know when we have to specify the full schema or not.
+     *
+     * In most cases this will be `dbo`.
+     */
+    searchSchema?: string
+
+    /**
+     * Indicates if replication is enabled.
+     */
+    isReplicated: boolean = false
+
+    /**
+     * Indicates if tree tables are supported by this driver.
+     */
+    treeSupport = true
+
+    /**
+     * Represent transaction support by this driver
+     */
+    transactionSupport = "simple" as const
+
+    /**
+     * Gets list of supported column data types by a driver.
+     *
+     * @see https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql
+     */
+    supportedDataTypes: ColumnType[] = [
+        "int",
+        "bigint",
+        "bit",
+        "decimal",
+        "money",
+        "numeric",
+        "smallint",
+        "smallmoney",
+        "tinyint",
+        "float",
+        "real",
+        "date",
+        "datetime2",
+        "datetime",
+        "datetimeoffset",
+        "smalldatetime",
+        "time",
+        "char",
+        "varchar",
+        "text",
+        "nchar",
+        "nvarchar",
+        "ntext",
+        "binary",
+        "image",
+        "varbinary",
+        "hierarchyid",
+        "sql_variant",
+        "timestamp",
+        "uniqueidentifier",
+        "xml",
+        "geometry",
+        "geography",
+        "rowversion",
+    ]
+
+    /**
+     * Returns type of upsert supported by driver if any
+     */
+    supportedUpsertTypes: UpsertType[] = []
+
+    /**
+     * Gets list of spatial column data types.
+     */
+    spatialTypes: ColumnType[] = ["geometry", "geography"]
+
+    /**
+     * Gets list of column data types that support length by a driver.
+     */
+    withLengthColumnTypes: ColumnType[] = [
+        "char",
+        "varchar",
+        "nchar",
+        "nvarchar",
+        "binary",
+        "varbinary",
+    ]
+
+    /**
+     * Gets list of column data types that support precision by a driver.
+     */
+    withPrecisionColumnTypes: ColumnType[] = [
+        "decimal",
+        "numeric",
+        "time",
+        "datetime2",
+        "datetimeoffset",
+    ]
+
+    /**
+     * Gets list of column data types that support scale by a driver.
+     */
+    withScaleColumnTypes: ColumnType[] = ["decimal", "numeric"]
+
+    /**
+     * Orm has special columns and we need to know what database column types should be for those types.
+     * Column types are driver dependant.
+     */
+    mappedDataTypes: MappedColumnTypes = {
+        createDate: "datetime2",
+        createDateDefault: "getdate()",
+        updateDate: "datetime2",
+        updateDateDefault: "getdate()",
+        deleteDate: "datetime2",
+        deleteDateNullable: true,
+        version: "int",
+        treeLevel: "int",
+        migrationId: "int",
+        migrationName: "varchar",
+        migrationTimestamp: "bigint",
+        cacheId: "int",
+        cacheIdentifier: "nvarchar",
+        cacheTime: "bigint",
+        cacheDuration: "int",
+        cacheQuery: "nvarchar(MAX)" as any,
+        cacheResult: "nvarchar(MAX)" as any,
+        metadataType: "varchar",
+        metadataDatabase: "varchar",
+        metadataSchema: "varchar",
+        metadataTable: "varchar",
+        metadataName: "varchar",
+        metadataValue: "nvarchar(MAX)" as any,
+    }
+
+    /**
+     * The prefix used for the parameters
+     */
+    parametersPrefix: string = "@"
+
+    /**
+     * Default values of length, precision and scale depends on column data type.
+     * Used in the cases when length/precision/scale is not specified by user.
+     */
+    dataTypeDefaults: DataTypeDefaults = {
+        char: { length: 1 },
+        nchar: { length: 1 },
+        varchar: { length: 255 },
+        nvarchar: { length: 255 },
+        binary: { length: 1 },
+        varbinary: { length: 1 },
+        decimal: { precision: 18, scale: 0 },
+        numeric: { precision: 18, scale: 0 },
+        time: { precision: 7 },
+        datetime2: { precision: 7 },
+        datetimeoffset: { precision: 7 },
+    }
+
+    cteCapabilities: CteCapabilities = {
+        enabled: true,
+        // todo: enable it for SQL Server - it's partially supported, but there are issues with generation of non-standard OUTPUT clause
+        writable: false,
+    }
+
+    /**
+     * Max length allowed by MSSQL Server for aliases (identifiers).
+     * @see https://docs.microsoft.com/en-us/sql/sql-server/maximum-capacity-specifications-for-sql-server
+     */
+    maxAliasLength = 128
+
+    // -------------------------------------------------------------------------
+    // Constructor
+    // -------------------------------------------------------------------------
+
+    constructor(connection: DataSource) {
+        this.connection = connection
+        this.options = connection.options as SqlServerConnectionOptions
+        this.isReplicated = this.options.replication ? true : false
+
+        // load mssql package
+        this.loadDependencies()
+
+        this.database = DriverUtils.buildDriverOptions(
+            this.options.replication
+                ? this.options.replication.master
+                : this.options,
+        ).database
+        this.schema = DriverUtils.buildDriverOptions(this.options).schema
+
+        // Object.assign(connection.options, DriverUtils.buildDriverOptions(connection.options)); // todo: do it better way
+        // validate options to make sure everything is set
+        // if (!this.options.host)
+        // throw new DriverOptionNotSetError("host");
+        // if (!this.options.username)
+        //     throw new DriverOptionNotSetError("username");
+        // if (!this.options.database)
+        //     throw new DriverOptionNotSetError("database");
+    }
+
+    // -------------------------------------------------------------------------
+    // Public Implemented Methods
+    // -------------------------------------------------------------------------
+
+    /**
+     * Performs connection to the database.
+     * Based on pooling options, it can either create connection immediately,
+     * either create a pool and create connection when needed.
+     */
+    async connect(): Promise<void> {
+        if (this.options.replication) {
+            this.slaves = await Promise.all(
+                this.options.replication.slaves.map((slave) => {
+                    return this.createPool(this.options, slave)
+                }),
+            )
+            this.master = await this.createPool(
+                this.options,
+                this.options.replication.master,
+            )
+        } else {
+            this.master = await this.createPool(this.options, this.options)
+        }
+
+        if (!this.database || !this.searchSchema) {
+            const queryRunner = await this.createQueryRunner("master")
+
+            if (!this.database) {
+                this.database = await queryRunner.getCurrentDatabase()
+            }
+
+            if (!this.searchSchema) {
+                this.searchSchema = await queryRunner.getCurrentSchema()
+            }
+
+            await queryRunner.release()
+        }
+
+        if (!this.schema) {
+            this.schema = this.searchSchema
+        }
+    }
+
+    /**
+     * Makes any action after connection (e.g. create extensions in Postgres driver).
+     */
+    afterConnect(): Promise<void> {
+        return Promise.resolve()
+    }
+
+    /**
+     * Closes connection with the database.
+     */
+    async disconnect(): Promise<void> {
+        if (!this.master)
+            return Promise.reject(new ConnectionIsNotSetError("mssql"))
+
+        await this.closePool(this.master)
+        await Promise.all(this.slaves.map((slave) => this.closePool(slave)))
+        this.master = undefined
+        this.slaves = []
+    }
+
+    /**
+     * Closes connection pool.
+     */
+    protected async closePool(pool: any): Promise<void> {
+        return new Promise<void>((ok, fail) => {
+            pool.close((err: any) => (err ? fail(err) : ok()))
+        })
+    }
+
+    /**
+     * Creates a schema builder used to build and sync a schema.
+     */
+    createSchemaBuilder() {
+        return new RdbmsSchemaBuilder(this.connection)
+    }
+
+    /**
+     * Creates a query runner used to execute database queries.
+     */
+    createQueryRunner(mode: ReplicationMode) {
+        return new SqlServerQueryRunner(this, mode)
+    }
+
+    /**
+     * Replaces parameters in the given sql with special escaping character
+     * and an array of parameter names to be passed to a query.
+     */
+    escapeQueryWithParameters(
+        sql: string,
+        parameters: ObjectLiteral,
+        nativeParameters: ObjectLiteral,
+    ): [string, any[]] {
+        const escapedParameters: any[] = Object.keys(nativeParameters).map(
+            (key) => nativeParameters[key],
+        )
+        if (!parameters || !Object.keys(parameters).length)
+            return [sql, escapedParameters]
+
+        const parameterIndexMap = new Map<string, number>()
+        sql = sql.replace(
+            /:(\.\.\.)?([A-Za-z0-9_.]+)/g,
+            (full, isArray: string, key: string): string => {
+                if (!parameters.hasOwnProperty(key)) {
+                    return full
+                }
+
+                if (parameterIndexMap.has(key)) {
+                    return this.parametersPrefix + parameterIndexMap.get(key)
+                }
+
+                let value: any = parameters[key]
+
+                if (isArray) {
+                    return value
+                        .map((v: any) => {
+                            escapedParameters.push(v)
+                            return this.createParameter(
+                                key,
+                                escapedParameters.length - 1,
+                            )
+                        })
+                        .join(", ")
+                }
+
+                if (typeof value === "function") {
+                    return value()
+                }
+
+                escapedParameters.push(value)
+                parameterIndexMap.set(key, escapedParameters.length - 1)
+                return this.createParameter(key, escapedParameters.length - 1)
+            },
+        ) // todo: make replace only in value statements, otherwise problems
+        return [sql, escapedParameters]
+    }
+
+    /**
+     * Escapes a column name.
+     */
+    escape(columnName: string): string {
+        return `"${columnName}"`
+    }
+
+    /**
+     * Build full table name with database name, schema name and table name.
+     * E.g. myDB.mySchema.myTable
+     */
+    buildTableName(
+        tableName: string,
+        schema?: string,
+        database?: string,
+    ): string {
+        let tablePath = [tableName]
+
+        if (schema) {
+            tablePath.unshift(schema)
+        }
+
+        if (database) {
+            if (!schema) {
+                tablePath.unshift("")
+            }
+
+            tablePath.unshift(database)
+        }
+
+        return tablePath.join(".")
+    }
+
+    /**
+     * Parse a target table name or other types and return a normalized table definition.
+     */
+    parseTableName(
+        target: EntityMetadata | Table | View | TableForeignKey | string,
+    ): { database?: string; schema?: string; tableName: string } {
+        const driverDatabase = this.database
+        const driverSchema = this.schema
+
+        if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {
+            const parsed = this.parseTableName(target.name)
+
+            return {
+                database: target.database || parsed.database || driverDatabase,
+                schema: target.schema || parsed.schema || driverSchema,
+                tableName: parsed.tableName,
+            }
+        }
+
+        if (InstanceChecker.isTableForeignKey(target)) {
+            const parsed = this.parseTableName(target.referencedTableName)
+
+            return {
+                database:
+                    target.referencedDatabase ||
+                    parsed.database ||
+                    driverDatabase,
+                schema:
+                    target.referencedSchema || parsed.schema || driverSchema,
+                tableName: parsed.tableName,
+            }
+        }
+
+        if (InstanceChecker.isEntityMetadata(target)) {
+            // EntityMetadata tableName is never a path
+
+            return {
+                database: target.database || driverDatabase,
+                schema: target.schema || driverSchema,
+                tableName: target.tableName,
+            }
+        }
+
+        const parts = target.split(".")
+
+        if (parts.length === 3) {
+            return {
+                database: parts[0] || driverDatabase,
+                schema: parts[1] || driverSchema,
+                tableName: parts[2],
+            }
+        } else if (parts.length === 2) {
+            return {
+                database: driverDatabase,
+                schema: parts[0],
+                tableName: parts[1],
+            }
+        } else {
+            return {
+                database: driverDatabase,
+                schema: driverSchema,
+                tableName: target,
+            }
+        }
+    }
+
+    /**
+     * Prepares given value to a value to be persisted, based on its column type and metadata.
+     */
+    preparePersistentValue(value: any, columnMetadata: ColumnMetadata): any {
+        if (columnMetadata.transformer)
+            value = ApplyValueTransformers.transformTo(
+                columnMetadata.transformer,
+                value,
+            )
+
+        if (value === null || value === undefined) return value
+
+        if (columnMetadata.type === Boolean) {
+            return value === true ? 1 : 0
+        } else if (columnMetadata.type === "date") {
+            return DateUtils.mixedDateToDate(value)
+        } else if (columnMetadata.type === "time") {
+            return DateUtils.mixedTimeToDate(value)
+        } else if (
+            columnMetadata.type === "datetime" ||
+            columnMetadata.type === "smalldatetime" ||
+            columnMetadata.type === Date
+        ) {
+            return DateUtils.mixedDateToDate(value, false, false)
+        } else if (
+            columnMetadata.type === "datetime2" ||
+            columnMetadata.type === "datetimeoffset"
+        ) {
+            return DateUtils.mixedDateToDate(value, false, true)
+        } else if (columnMetadata.type === "simple-array") {
+            return DateUtils.simpleArrayToString(value)
+        } else if (columnMetadata.type === "simple-json") {
+            return DateUtils.simpleJsonToString(value)
+        } else if (columnMetadata.type === "simple-enum") {
+            return DateUtils.simpleEnumToString(value)
+        }
+
+        return value
+    }
+
+    /**
+     * Prepares given value to a value to be persisted, based on its column type or metadata.
+     */
+    prepareHydratedValue(value: any, columnMetadata: ColumnMetadata): any {
+        if (value === null || value === undefined)
+            return columnMetadata.transformer
+                ? ApplyValueTransformers.transformFrom(
+                      columnMetadata.transformer,
+                      value,
+                  )
+                : value
+
+        if (columnMetadata.type === Boolean) {
+            value = value ? true : false
+        } else if (
+            columnMetadata.type === "datetime" ||
+            columnMetadata.type === Date ||
+            columnMetadata.type === "datetime2" ||
+            columnMetadata.type === "smalldatetime" ||
+            columnMetadata.type === "datetimeoffset"
+        ) {
+            value = DateUtils.normalizeHydratedDate(value)
+        } else if (columnMetadata.type === "date") {
+            value = DateUtils.mixedDateToDateString(value)
+        } else if (columnMetadata.type === "time") {
+            value = DateUtils.mixedTimeToString(value)
+        } else if (columnMetadata.type === "simple-array") {
+            value = DateUtils.stringToSimpleArray(value)
+        } else if (columnMetadata.type === "simple-json") {
+            value = DateUtils.stringToSimpleJson(value)
+        } else if (columnMetadata.type === "simple-enum") {
+            value = DateUtils.stringToSimpleEnum(value, columnMetadata)
+        } else if (columnMetadata.type === Number) {
+            // convert to number if number
+            value = !isNaN(+value) ? parseInt(value) : value
+        }
+
+        if (columnMetadata.transformer)
+            value = ApplyValueTransformers.transformFrom(
+                columnMetadata.transformer,
+                value,
+            )
+
+        return value
+    }
+
+    /**
+     * Creates a database type from a given column metadata.
+     */
+    normalizeType(column: {
+        type?: ColumnType
+        length?: number | string
+        precision?: number | null
+        scale?: number
+    }): string {
+        if (column.type === Number || column.type === "integer") {
+            return "int"
+        } else if (column.type === String) {
+            return "nvarchar"
+        } else if (column.type === Date) {
+            return "datetime"
+        } else if (column.type === Boolean) {
+            return "bit"
+        } else if ((column.type as any) === Buffer) {
+            return "binary"
+        } else if (column.type === "uuid") {
+            return "uniqueidentifier"
+        } else if (
+            column.type === "simple-array" ||
+            column.type === "simple-json"
+        ) {
+            return "ntext"
+        } else if (column.type === "simple-enum") {
+            return "nvarchar"
+        } else if (column.type === "dec") {
+            return "decimal"
+        } else if (column.type === "double precision") {
+            return "float"
+        } else if (column.type === "rowversion") {
+            return "timestamp" // the rowversion type's name in SQL server metadata is timestamp
+        } else {
+            return (column.type as string) || ""
+        }
+    }
+
+    /**
+     * Normalizes "default" value of the column.
+     */
+    normalizeDefault(columnMetadata: ColumnMetadata): string | undefined {
+        const defaultValue = columnMetadata.default
+
+        if (typeof defaultValue === "number") {
+            return `${defaultValue}`
+        }
+
+        if (typeof defaultValue === "boolean") {
+            return defaultValue ? "1" : "0"
+        }
+
+        if (typeof defaultValue === "function") {
+            const value = defaultValue()
+            if (value.toUpperCase() === "CURRENT_TIMESTAMP") {
+                return "getdate()"
+            }
+            return value
+        }
+
+        if (typeof defaultValue === "string") {
+            return `'${defaultValue}'`
+        }
+
+        if (defaultValue === undefined || defaultValue === null) {
+            return undefined
+        }
+
+        return `${defaultValue}`
+    }
+
+    /**
+     * Normalizes "isUnique" value of the column.
+     */
+    normalizeIsUnique(column: ColumnMetadata): boolean {
+        return column.entityMetadata.uniques.some(
+            (uq) => uq.columns.length === 1 && uq.columns[0] === column,
+        )
+    }
+
+    /**
+     * Returns default column lengths, which is required on column creation.
+     */
+    getColumnLength(column: ColumnMetadata | TableColumn): string {
+        if (column.length) return column.length.toString()
+
+        if (
+            column.type === "varchar" ||
+            column.type === "nvarchar" ||
+            column.type === String
+        )
+            return "255"
+
+        return ""
+    }
+
+    /**
+     * Creates column type definition including length, precision and scale
+     */
+    createFullType(column: TableColumn): string {
+        // The Database Engine determines the data type of the computed column by applying the rules
+        // of data type precedence to the expressions specified in the formula.
+        if (column.asExpression) return ""
+
+        let type = column.type
+
+        // used 'getColumnLength()' method, because SqlServer sets `varchar` and `nvarchar` length to 1 by default.
+        if (this.getColumnLength(column)) {
+            type += `(${this.getColumnLength(column)})`
+        } else if (
+            column.precision !== null &&
+            column.precision !== undefined &&
+            column.scale !== null &&
+            column.scale !== undefined
+        ) {
+            type += `(${column.precision},${column.scale})`
+        } else if (
+            column.precision !== null &&
+            column.precision !== undefined
+        ) {
+            type += `(${column.precision})`
+        }
+
+        if (column.isArray) type += " array"
+
+        return type
+    }
+
+    /**
+     * Obtains a new database connection to a master server.
+     * Used for replication.
+     * If replication is not setup then returns default connection's database connection.
+     */
+    obtainMasterConnection(): Promise<any> {
+        if (!this.master) {
+            return Promise.reject(new TypeORMError("Driver not Connected"))
+        }
+
+        return Promise.resolve(this.master)
+    }
+
+    /**
+     * Obtains a new database connection to a slave server.
+     * Used for replication.
+     * If replication is not setup then returns master (default) connection's database connection.
+     */
+    obtainSlaveConnection(): Promise<any> {
+        if (!this.slaves.length) return this.obtainMasterConnection()
+
+        const random = Math.floor(Math.random() * this.slaves.length)
+        return Promise.resolve(this.slaves[random])
+    }
+
+    /**
+     * Creates generated map of values generated or returned by database after INSERT query.
+     */
+    createGeneratedMap(metadata: EntityMetadata, insertResult: ObjectLiteral) {
+        if (!insertResult) return undefined
+
+        return Object.keys(insertResult).reduce((map, key) => {
+            const column = metadata.findColumnWithDatabaseName(key)
+            if (column) {
+                OrmUtils.mergeDeep(
+                    map,
+                    column.createValueMap(
+                        this.prepareHydratedValue(insertResult[key], column),
+                    ),
+                )
+            }
+            return map
+        }, {} as ObjectLiteral)
+    }
+
+    /**
+     * Differentiate columns of this table and columns from the given column metadatas columns
+     * and returns only changed.
+     */
+    findChangedColumns(
+        tableColumns: TableColumn[],
+        columnMetadatas: ColumnMetadata[],
+    ): ColumnMetadata[] {
+        return columnMetadatas.filter((columnMetadata) => {
+            const tableColumn = tableColumns.find(
+                (c) => c.name === columnMetadata.databaseName,
+            )
+            if (!tableColumn) return false // we don't need new columns, we only need exist and changed
+
+            const isColumnChanged =
+                tableColumn.name !== columnMetadata.databaseName ||
+                this.compareColumnType(tableColumn, columnMetadata) ||
+                this.compareColumnLength(tableColumn, columnMetadata) ||
+                tableColumn.precision !== columnMetadata.precision ||
+                tableColumn.scale !== columnMetadata.scale ||
+                // || tableColumn.comment !== columnMetadata.comment || // todo
+                tableColumn.isGenerated !== columnMetadata.isGenerated ||
+                (!tableColumn.isGenerated &&
+                    this.lowerDefaultValueIfNecessary(
+                        this.normalizeDefault(columnMetadata),
+                    ) !==
+                        this.lowerDefaultValueIfNecessary(
+                            tableColumn.default,
+                        )) || // we included check for generated here, because generated columns already can have default values
+                tableColumn.isPrimary !== columnMetadata.isPrimary ||
+                tableColumn.isNullable !== columnMetadata.isNullable ||
+                tableColumn.asExpression !== columnMetadata.asExpression ||
+                tableColumn.generatedType !== columnMetadata.generatedType ||
+                tableColumn.isUnique !==
+                    this.normalizeIsUnique(columnMetadata) ||
+                (tableColumn.enum &&
+                    columnMetadata.enum &&
+                    !OrmUtils.isArraysEqual(
+                        tableColumn.enum,
+                        columnMetadata.enum.map((val) => val + ""),
+                    ))
+
+            // DEBUG SECTION
+            // if (isColumnChanged) {
+            //     console.log("table:", columnMetadata.entityMetadata.tableName)
+            //     console.log(
+            //         "name:",
+            //         tableColumn.name,
+            //         columnMetadata.databaseName,
+            //     )
+            //     console.log(
+            //         "type:",
+            //         tableColumn.type,
+            //         this.normalizeType(columnMetadata),
+            //         this.compareColumnType(tableColumn, columnMetadata),
+            //     )
+            //     console.log(
+            //         "length:",
+            //         tableColumn.length,
+            //         columnMetadata.length,
+            //         this.compareColumnLength(tableColumn, columnMetadata),
+            //     )
+            //     console.log(
+            //         "precision:",
+            //         tableColumn.precision,
+            //         columnMetadata.precision,
+            //     )
+            //     console.log("scale:", tableColumn.scale, columnMetadata.scale)
+            //     console.log(
+            //         "isGenerated:",
+            //         tableColumn.isGenerated,
+            //         columnMetadata.isGenerated,
+            //     )
+            //     console.log(
+            //         "isGenerated 2:",
+            //         !tableColumn.isGenerated &&
+            //             this.lowerDefaultValueIfNecessary(
+            //                 this.normalizeDefault(columnMetadata),
+            //             ) !==
+            //                 this.lowerDefaultValueIfNecessary(
+            //                     tableColumn.default,
+            //                 ),
+            //     )
+            //     console.log(
+            //         "isPrimary:",
+            //         tableColumn.isPrimary,
+            //         columnMetadata.isPrimary,
+            //     )
+            //     console.log(
+            //         "isNullable:",
+            //         tableColumn.isNullable,
+            //         columnMetadata.isNullable,
+            //     )
+            //     console.log(
+            //         "asExpression:",
+            //         tableColumn.asExpression,
+            //         columnMetadata.asExpression,
+            //     )
+            //     console.log(
+            //         "generatedType:",
+            //         tableColumn.generatedType,
+            //         columnMetadata.generatedType,
+            //     )
+            //     console.log(
+            //         "isUnique:",
+            //         tableColumn.isUnique,
+            //         this.normalizeIsUnique(columnMetadata),
+            //     )
+            //     console.log("==========================================")
+            // }
+
+            return isColumnChanged
+        })
+    }
+
+    /**
+     * Returns true if driver supports RETURNING / OUTPUT statement.
+     */
+    isReturningSqlSupported(): boolean {
+        if (
+            this.options.options &&
+            this.options.options.disableOutputReturning
+        ) {
+            return false
+        }
+        return true
+    }
+
+    /**
+     * Returns true if driver supports uuid values generation on its own.
+     */
+    isUUIDGenerationSupported(): boolean {
+        return true
+    }
+
+    /**
+     * Returns true if driver supports fulltext indices.
+     */
+    isFullTextColumnTypeSupported(): boolean {
+        return false
+    }
+
+    /**
+     * Creates an escaped parameter.
+     */
+    createParameter(parameterName: string, index: number): string {
+        return this.parametersPrefix + index
+    }
+
+    // -------------------------------------------------------------------------
+    // Public Methods
+    // -------------------------------------------------------------------------
+
+    /**
+     * Sql server's parameters needs to be wrapped into special object with type information about this value.
+     * This method wraps given value into MssqlParameter based on its column definition.
+     */
+    parametrizeValue(column: ColumnMetadata, value: any) {
+        // if its already MssqlParameter then simply return it
+        if (InstanceChecker.isMssqlParameter(value)) return value
+
+        const normalizedType = this.normalizeType({ type: column.type })
+        if (column.length) {
+            return new MssqlParameter(
+                value,
+                normalizedType as any,
+                column.length as any,
+            )
+        } else if (
+            column.precision !== null &&
+            column.precision !== undefined &&
+            column.scale !== null &&
+            column.scale !== undefined
+        ) {
+            return new MssqlParameter(
+                value,
+                normalizedType as any,
+                column.precision,
+                column.scale,
+            )
+        } else if (
+            column.precision !== null &&
+            column.precision !== undefined
+        ) {
+            return new MssqlParameter(
+                value,
+                normalizedType as any,
+                column.precision,
+            )
+        } else if (column.scale !== null && column.scale !== undefined) {
+            return new MssqlParameter(
+                value,
+                normalizedType as any,
+                column.scale,
+            )
+        }
+
+        return new MssqlParameter(value, normalizedType as any)
+    }
+
+    /**
+     * Sql server's parameters needs to be wrapped into special object with type information about this value.
+     * This method wraps all values of the given object into MssqlParameter based on their column definitions in the given table.
+     */
+    parametrizeMap(tablePath: string, map: ObjectLiteral): ObjectLiteral {
+        // find metadata for the given table
+        if (!this.connection.hasMetadata(tablePath))
+            // if no metadata found then we can't proceed because we don't have columns and their types
+            return map
+        const metadata = this.connection.getMetadata(tablePath)
+
+        return Object.keys(map).reduce((newMap, key) => {
+            const value = map[key]
+
+            // find column metadata
+            const column = metadata.findColumnWithDatabaseName(key)
+            if (!column)
+                // if we didn't find a column then we can't proceed because we don't have a column type
+                return value
+
+            newMap[key] = this.parametrizeValue(column, value)
+            return newMap
+        }, {} as ObjectLiteral)
+    }
+
+    buildTableVariableDeclaration(
+        identifier: string,
+        columns: ColumnMetadata[],
+    ): string {
+        const outputColumns = columns.map((column) => {
+            return `${this.escape(column.databaseName)} ${this.createFullType(
+                new TableColumn({
+                    name: column.databaseName,
+                    type: this.normalizeType(column),
+                    length: column.length,
+                    isNullable: column.isNullable,
+                    isArray: column.isArray,
+                }),
+            )}`
+        })
+
+        return `DECLARE ${identifier} TABLE (${outputColumns.join(", ")})`
+    }
+
+    // -------------------------------------------------------------------------
+    // Protected Methods
+    // -------------------------------------------------------------------------
+
+    /**
+     * If driver dependency is not given explicitly, then try to load it via "require".
+     */
+    protected loadDependencies(): void {
+        try {
+            const mssql = this.options.driver || PlatformTools.load("mssql")
+            this.mssql = mssql
+        } catch (e) {
+            // todo: better error for browser env
+            throw new DriverPackageNotInstalledError("SQL Server", "mssql")
+        }
+    }
+
+    protected compareColumnType(
+        tableColumn: TableColumn,
+        columnMetadata: ColumnMetadata,
+    ): boolean {
+        // The Database Engine determines the data type of the computed column by applying the rules
+        // of data type precedence to the expressions specified in the formula.
+        if (columnMetadata.asExpression) return false
+
+        return tableColumn.type !== this.normalizeType(columnMetadata)
+    }
+
+    protected compareColumnLength(
+        tableColumn: TableColumn,
+        columnMetadata: ColumnMetadata,
+    ): boolean {
+        // The Database Engine determines the data type of the computed column by applying the rules
+        // of data type precedence to the expressions specified in the formula.
+        if (columnMetadata.asExpression) return false
+
+        return (
+            tableColumn.length.toUpperCase() !==
+            this.getColumnLength(columnMetadata).toUpperCase()
+        )
+    }
+
+    protected lowerDefaultValueIfNecessary(value: string | undefined) {
+        // SqlServer saves function calls in default value as lowercase https://github.com/typeorm/typeorm/issues/2733
+        if (!value) {
+            return value
+        }
+        return value
+            .split(`'`)
+            .map((v, i) => {
+                return i % 2 === 1 ? v : v.toLowerCase()
+            })
+            .join(`'`)
+    }
+
+    /**
+     * Creates a new connection pool for a given database credentials.
+     */
+    protected createPool(
+        options: SqlServerConnectionOptions,
+        credentials: SqlServerConnectionCredentialsOptions,
+    ): Promise<any> {
+        credentials = Object.assign(
+            {},
+            credentials,
+            DriverUtils.buildDriverOptions(credentials),
+        ) // todo: do it better way
+
+        // todo: credentials.domain is deprecation. remove it in future
+        const authentication = !credentials.domain
+            ? credentials.authentication
+            : {
+                  type: "ntlm",
+                  options: {
+                      domain: credentials.domain,
+                      userName: credentials.username,
+                      password: credentials.password,
+                  },
+              }
+        // build connection options for the driver
+        const connectionOptions = Object.assign(
+            {},
+            {
+                connectionTimeout: this.options.connectionTimeout,
+                requestTimeout: this.options.requestTimeout,
+                stream: this.options.stream,
+                pool: this.options.pool,
+                options: this.options.options,
+            },
+            {
+                server: credentials.host,
+                database: credentials.database,
+                port: credentials.port,
+                user: credentials.username,
+                password: credentials.password,
+                authentication: authentication,
+            },
+            options.extra || {},
+        )
+
+        // set default useUTC option if it hasn't been set
+        if (!connectionOptions.options) {
+            connectionOptions.options = { useUTC: false }
+        } else if (!connectionOptions.options.useUTC) {
+            Object.assign(connectionOptions.options, { useUTC: false })
+        }
+
+        // Match the next release of tedious for configuration options
+        // Also prevents warning messages.
+        Object.assign(connectionOptions.options, { enableArithAbort: true })
+
+        // pooling is enabled either when its set explicitly to true,
+        // either when its not defined at all (e.g. enabled by default)
+        return new Promise<void>((ok, fail) => {
+            const pool = new this.mssql.ConnectionPool(connectionOptions)
+
+            const { logger } = this.connection
+
+            const poolErrorHandler =
+                (options.pool && options.pool.errorHandler) ||
+                ((error: any) =>
+                    logger.log("warn", `MSSQL pool raised an error. ${error}`))
+            /**
+             * Attaching an error handler to pool errors is essential, as, otherwise, errors raised will go unhandled and
+             * cause the hosting app to crash.
+             */
+            pool.on("error", poolErrorHandler)
+
+            const connection = pool.connect((err: any) => {
+                if (err) return fail(err)
+                ok(connection)
+            })
+        })
+    }
+}
diff --git a/driver/sqlserver/SqlServerQueryRunner.d.ts b/driver/sqlserver/SqlServerQueryRunner.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e41dbdf3bbca81cc066687231721f42dd6aaaa23
--- /dev/null
+++ b/driver/sqlserver/SqlServerQueryRunner.d.ts
@@ -0,0 +1,362 @@
+
+import { ReadStream } from "../../platform/PlatformTools";
+import { BaseQueryRunner } from "../../query-runner/BaseQueryRunner";
+import { QueryRunner } from "../../query-runner/QueryRunner";
+import { Table } from "../../schema-builder/table/Table";
+import { TableCheck } from "../../schema-builder/table/TableCheck";
+import { TableColumn } from "../../schema-builder/table/TableColumn";
+import { TableExclusion } from "../../schema-builder/table/TableExclusion";
+import { TableForeignKey } from "../../schema-builder/table/TableForeignKey";
+import { TableIndex } from "../../schema-builder/table/TableIndex";
+import { TableUnique } from "../../schema-builder/table/TableUnique";
+import { View } from "../../schema-builder/view/View";
+import { Query } from "../Query";
+import { IsolationLevel } from "../types/IsolationLevel";
+import { MssqlParameter } from "./MssqlParameter";
+import { SqlServerDriver } from "./SqlServerDriver";
+import { ReplicationMode } from "../types/ReplicationMode";
+/**
+ * Runs queries on a single SQL Server database connection.
+ */
+export declare class SqlServerQueryRunner extends BaseQueryRunner implements QueryRunner {
+    /**
+     * Database driver used by connection.
+     */
+    driver: SqlServerDriver;
+    private lock;
+    constructor(driver: SqlServerDriver, mode: ReplicationMode);
+    /**
+     * Creates/uses database connection from the connection pool to perform further operations.
+     * Returns obtained database connection.
+     */
+    connect(): Promise<void>;
+    /**
+     * Releases used database connection.
+     * You cannot use query runner methods once its released.
+     */
+    release(): Promise<void>;
+    /**
+     * Starts transaction.
+     */
+    startTransaction(isolationLevel?: IsolationLevel): Promise<void>;
+    /**
+     * Commits transaction.
+     * Error will be thrown if transaction was not started.
+     */
+    commitTransaction(): Promise<void>;
+    /**
+     * Rollbacks transaction.
+     * Error will be thrown if transaction was not started.
+     */
+    rollbackTransaction(): Promise<void>;
+    /**
+     * Executes a given SQL query.
+     */
+    query(query: string, parameters?: any[], useStructuredResult?: boolean): Promise<any>;
+    /**
+     * Returns raw data stream.
+     */
+    stream(query: string, parameters?: any[], onEnd?: Function, onError?: Function): Promise<ReadStream>;
+    /**
+     * Returns all available database names including system databases.
+     */
+    getDatabases(): Promise<string[]>;
+    /**
+     * Returns all available schema names including system schemas.
+     * If database parameter specified, returns schemas of that database.
+     */
+    getSchemas(database?: string): Promise<string[]>;
+    /**
+     * Checks if database with the given name exist.
+     */
+    hasDatabase(database: string): Promise<boolean>;
+    /**
+     * Loads currently using database
+     */
+    getCurrentDatabase(): Promise<string>;
+    /**
+     * Checks if schema with the given name exist.
+     */
+    hasSchema(schema: string): Promise<boolean>;
+    /**
+     * Loads currently using database schema
+     */
+    getCurrentSchema(): Promise<string>;
+    /**
+     * Checks if table with the given name exist in the database.
+     */
+    hasTable(tableOrName: Table | string): Promise<boolean>;
+    /**
+     * Checks if column exist in the table.
+     */
+    hasColumn(tableOrName: Table | string, columnName: string): Promise<boolean>;
+    /**
+     * Creates a new database.
+     */
+    createDatabase(database: string, ifNotExist?: boolean): Promise<void>;
+    /**
+     * Drops database.
+     */
+    dropDatabase(database: string, ifExist?: boolean): Promise<void>;
+    /**
+     * Creates table schema.
+     * If database name also specified (e.g. 'dbName.schemaName') schema will be created in specified database.
+     */
+    createSchema(schemaPath: string, ifNotExist?: boolean): Promise<void>;
+    /**
+     * Drops table schema.
+     * If database name also specified (e.g. 'dbName.schemaName') schema will be dropped in specified database.
+     */
+    dropSchema(schemaPath: string, ifExist?: boolean): Promise<void>;
+    /**
+     * Creates a new table.
+     */
+    createTable(table: Table, ifNotExist?: boolean, createForeignKeys?: boolean, createIndices?: boolean): Promise<void>;
+    /**
+     * Drops the table.
+     */
+    dropTable(tableOrName: Table | string, ifExist?: boolean, dropForeignKeys?: boolean, dropIndices?: boolean): Promise<void>;
+    /**
+     * Creates a new view.
+     */
+    createView(view: View, syncWithMetadata?: boolean): Promise<void>;
+    /**
+     * Drops the view.
+     */
+    dropView(target: View | string): Promise<void>;
+    /**
+     * Renames a table.
+     */
+    renameTable(oldTableOrName: Table | string, newTableName: string): Promise<void>;
+    /**
+     * Creates a new column from the column in the table.
+     */
+    addColumn(tableOrName: Table | string, column: TableColumn): Promise<void>;
+    /**
+     * Creates a new columns from the column in the table.
+     */
+    addColumns(tableOrName: Table | string, columns: TableColumn[]): Promise<void>;
+    /**
+     * Renames column in the given table.
+     */
+    renameColumn(tableOrName: Table | string, oldTableColumnOrName: TableColumn | string, newTableColumnOrName: TableColumn | string): Promise<void>;
+    /**
+     * Changes a column in the table.
+     */
+    changeColumn(tableOrName: Table | string, oldTableColumnOrName: TableColumn | string, newColumn: TableColumn): Promise<void>;
+    /**
+     * Changes a column in the table.
+     */
+    changeColumns(tableOrName: Table | string, changedColumns: {
+        newColumn: TableColumn;
+        oldColumn: TableColumn;
+    }[]): Promise<void>;
+    /**
+     * Drops column in the table.
+     */
+    dropColumn(tableOrName: Table | string, columnOrName: TableColumn | string): Promise<void>;
+    /**
+     * Drops the columns in the table.
+     */
+    dropColumns(tableOrName: Table | string, columns: TableColumn[] | string[]): Promise<void>;
+    /**
+     * Creates a new primary key.
+     */
+    createPrimaryKey(tableOrName: Table | string, columnNames: string[], constraintName?: string): Promise<void>;
+    /**
+     * Updates composite primary keys.
+     */
+    updatePrimaryKeys(tableOrName: Table | string, columns: TableColumn[]): Promise<void>;
+    /**
+     * Drops a primary key.
+     */
+    dropPrimaryKey(tableOrName: Table | string, constraintName?: string): Promise<void>;
+    /**
+     * Creates a new unique constraint.
+     */
+    createUniqueConstraint(tableOrName: Table | string, uniqueConstraint: TableUnique): Promise<void>;
+    /**
+     * Creates a new unique constraints.
+     */
+    createUniqueConstraints(tableOrName: Table | string, uniqueConstraints: TableUnique[]): Promise<void>;
+    /**
+     * Drops unique constraint.
+     */
+    dropUniqueConstraint(tableOrName: Table | string, uniqueOrName: TableUnique | string): Promise<void>;
+    /**
+     * Drops an unique constraints.
+     */
+    dropUniqueConstraints(tableOrName: Table | string, uniqueConstraints: TableUnique[]): Promise<void>;
+    /**
+     * Creates a new check constraint.
+     */
+    createCheckConstraint(tableOrName: Table | string, checkConstraint: TableCheck): Promise<void>;
+    /**
+     * Creates a new check constraints.
+     */
+    createCheckConstraints(tableOrName: Table | string, checkConstraints: TableCheck[]): Promise<void>;
+    /**
+     * Drops check constraint.
+     */
+    dropCheckConstraint(tableOrName: Table | string, checkOrName: TableCheck | string): Promise<void>;
+    /**
+     * Drops check constraints.
+     */
+    dropCheckConstraints(tableOrName: Table | string, checkConstraints: TableCheck[]): Promise<void>;
+    /**
+     * Creates a new exclusion constraint.
+     */
+    createExclusionConstraint(tableOrName: Table | string, exclusionConstraint: TableExclusion): Promise<void>;
+    /**
+     * Creates a new exclusion constraints.
+     */
+    createExclusionConstraints(tableOrName: Table | string, exclusionConstraints: TableExclusion[]): Promise<void>;
+    /**
+     * Drops exclusion constraint.
+     */
+    dropExclusionConstraint(tableOrName: Table | string, exclusionOrName: TableExclusion | string): Promise<void>;
+    /**
+     * Drops exclusion constraints.
+     */
+    dropExclusionConstraints(tableOrName: Table | string, exclusionConstraints: TableExclusion[]): Promise<void>;
+    /**
+     * Creates a new foreign key.
+     */
+    createForeignKey(tableOrName: Table | string, foreignKey: TableForeignKey): Promise<void>;
+    /**
+     * Creates a new foreign keys.
+     */
+    createForeignKeys(tableOrName: Table | string, foreignKeys: TableForeignKey[]): Promise<void>;
+    /**
+     * Drops a foreign key from the table.
+     */
+    dropForeignKey(tableOrName: Table | string, foreignKeyOrName: TableForeignKey | string): Promise<void>;
+    /**
+     * Drops a foreign keys from the table.
+     */
+    dropForeignKeys(tableOrName: Table | string, foreignKeys: TableForeignKey[]): Promise<void>;
+    /**
+     * Creates a new index.
+     */
+    createIndex(tableOrName: Table | string, index: TableIndex): Promise<void>;
+    /**
+     * Creates a new indices
+     */
+    createIndices(tableOrName: Table | string, indices: TableIndex[]): Promise<void>;
+    /**
+     * Drops an index.
+     */
+    dropIndex(tableOrName: Table | string, indexOrName: TableIndex | string): Promise<void>;
+    /**
+     * Drops an indices from the table.
+     */
+    dropIndices(tableOrName: Table | string, indices: TableIndex[]): Promise<void>;
+    /**
+     * Clears all table contents.
+     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
+     */
+    clearTable(tablePath: string): Promise<void>;
+    /**
+     * Removes all tables from the currently connected database.
+     */
+    clearDatabase(database?: string): Promise<void>;
+    protected loadViews(viewPaths?: string[]): Promise<View[]>;
+    /**
+     * Loads all tables (with given names) from the database and creates a Table from them.
+     */
+    protected loadTables(tableNames?: string[]): Promise<Table[]>;
+    /**
+     * Builds and returns SQL for create table.
+     */
+    protected createTableSql(table: Table, createForeignKeys?: boolean): Query;
+    /**
+     * Builds drop table sql.
+     */
+    protected dropTableSql(tableOrName: Table | string, ifExist?: boolean): Query;
+    protected createViewSql(view: View): Query;
+    protected insertViewDefinitionSql(view: View): Promise<Query>;
+    /**
+     * Builds drop view sql.
+     */
+    protected dropViewSql(viewOrPath: View | string): Query;
+    /**
+     * Builds remove view sql.
+     */
+    protected deleteViewDefinitionSql(viewOrPath: View | string): Promise<Query>;
+    /**
+     * Builds create index sql.
+     */
+    protected createIndexSql(table: Table, index: TableIndex): Query;
+    /**
+     * Builds drop index sql.
+     */
+    protected dropIndexSql(table: Table, indexOrName: TableIndex | string): Query;
+    /**
+     * Builds create primary key sql.
+     */
+    protected createPrimaryKeySql(table: Table, columnNames: string[], constraintName?: string): Query;
+    /**
+     * Builds drop primary key sql.
+     */
+    protected dropPrimaryKeySql(table: Table): Query;
+    /**
+     * Builds create unique constraint sql.
+     */
+    protected createUniqueConstraintSql(table: Table, uniqueConstraint: TableUnique): Query;
+    /**
+     * Builds drop unique constraint sql.
+     */
+    protected dropUniqueConstraintSql(table: Table, uniqueOrName: TableUnique | string): Query;
+    /**
+     * Builds create check constraint sql.
+     */
+    protected createCheckConstraintSql(table: Table, checkConstraint: TableCheck): Query;
+    /**
+     * Builds drop check constraint sql.
+     */
+    protected dropCheckConstraintSql(table: Table, checkOrName: TableCheck | string): Query;
+    /**
+     * Builds create foreign key sql.
+     */
+    protected createForeignKeySql(table: Table, foreignKey: TableForeignKey): Query;
+    /**
+     * Builds drop foreign key sql.
+     */
+    protected dropForeignKeySql(table: Table, foreignKeyOrName: TableForeignKey | string): Query;
+    /**
+     * Escapes given table or View path.
+     */
+    protected escapePath(target: Table | View | string): string;
+    /**
+     * Concat database name and schema name to the foreign key name.
+     * Needs because FK name is relevant to the schema and database.
+     */
+    protected buildForeignKeyName(fkName: string, schemaName: string | undefined, dbName: string | undefined): string;
+    /**
+     * Removes parenthesis around default value.
+     * Sql server returns default value with parenthesis around, e.g.
+     *  ('My text') - for string
+     *  ((1)) - for number
+     *  (newsequentialId()) - for function
+     */
+    protected removeParenthesisFromDefault(defaultValue: string): any;
+    /**
+     * Builds a query for create column.
+     */
+    protected buildCreateColumnSql(table: Table, column: TableColumn, skipIdentity: boolean, createDefault: boolean, skipEnum?: boolean): string;
+    private getEnumExpression;
+    protected isEnumCheckConstraint(name: string): boolean;
+    /**
+     * Converts MssqlParameter into real mssql parameter type.
+     */
+    protected mssqlParameterToNativeParameter(parameter: MssqlParameter): any;
+    /**
+     * Converts string literal of isolation level to enum.
+     * The underlying mssql driver requires an enum for the isolation level.
+     */
+    convertIsolationLevel(isolation: IsolationLevel): any;
+    /**
+     * Change table comment.
+     */
+    changeTableComment(tableOrName: Table | string, comment?: string): Promise<void>;
+}
diff --git a/driver/sqlserver/SqlServerQueryRunner.js b/driver/sqlserver/SqlServerQueryRunner.js
new file mode 100644
index 0000000000000000000000000000000000000000..ed782abadc0a1e70a287c9af2a5193e0a24da2be
--- /dev/null
+++ b/driver/sqlserver/SqlServerQueryRunner.js
@@ -0,0 +1,2485 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.SqlServerQueryRunner = void 0;
+const QueryResult_1 = require("../../query-runner/QueryResult");
+const QueryFailedError_1 = require("../../error/QueryFailedError");
+const QueryRunnerAlreadyReleasedError_1 = require("../../error/QueryRunnerAlreadyReleasedError");
+const TransactionNotStartedError_1 = require("../../error/TransactionNotStartedError");
+const BaseQueryRunner_1 = require("../../query-runner/BaseQueryRunner");
+const Table_1 = require("../../schema-builder/table/Table");
+const TableCheck_1 = require("../../schema-builder/table/TableCheck");
+const TableColumn_1 = require("../../schema-builder/table/TableColumn");
+const TableForeignKey_1 = require("../../schema-builder/table/TableForeignKey");
+const TableIndex_1 = require("../../schema-builder/table/TableIndex");
+const TableUnique_1 = require("../../schema-builder/table/TableUnique");
+const View_1 = require("../../schema-builder/view/View");
+const Broadcaster_1 = require("../../subscriber/Broadcaster");
+const OrmUtils_1 = require("../../util/OrmUtils");
+const Query_1 = require("../Query");
+const error_1 = require("../../error");
+const QueryLock_1 = require("../../query-runner/QueryLock");
+const MetadataTableType_1 = require("../types/MetadataTableType");
+const InstanceChecker_1 = require("../../util/InstanceChecker");
+const BroadcasterResult_1 = require("../../subscriber/BroadcasterResult");
+/**
+ * Runs queries on a single SQL Server database connection.
+ */
+class SqlServerQueryRunner extends BaseQueryRunner_1.BaseQueryRunner {
+    // -------------------------------------------------------------------------
+    // Constructor
+    // -------------------------------------------------------------------------
+    constructor(driver, mode) {
+        super();
+        // -------------------------------------------------------------------------
+        // Private Properties
+        // -------------------------------------------------------------------------
+        this.lock = new QueryLock_1.QueryLock();
+        this.driver = driver;
+        this.connection = driver.connection;
+        this.broadcaster = new Broadcaster_1.Broadcaster(this);
+        this.mode = mode;
+    }
+    // -------------------------------------------------------------------------
+    // Public Methods
+    // -------------------------------------------------------------------------
+    /**
+     * Creates/uses database connection from the connection pool to perform further operations.
+     * Returns obtained database connection.
+     */
+    connect() {
+        return Promise.resolve();
+    }
+    /**
+     * Releases used database connection.
+     * You cannot use query runner methods once its released.
+     */
+    release() {
+        this.isReleased = true;
+        return Promise.resolve();
+    }
+    /**
+     * Starts transaction.
+     */
+    async startTransaction(isolationLevel) {
+        if (this.isReleased)
+            throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
+        this.isTransactionActive = true;
+        try {
+            await this.broadcaster.broadcast("BeforeTransactionStart");
+        }
+        catch (err) {
+            this.isTransactionActive = false;
+            throw err;
+        }
+        await new Promise(async (ok, fail) => {
+            const transactionCallback = (err) => {
+                if (err) {
+                    this.isTransactionActive = false;
+                    return fail(err);
+                }
+                ok();
+            };
+            if (this.transactionDepth === 0) {
+                this.transactionDepth += 1;
+                const pool = await (this.mode === "slave"
+                    ? this.driver.obtainSlaveConnection()
+                    : this.driver.obtainMasterConnection());
+                this.databaseConnection = pool.transaction();
+                this.connection.logger.logQuery("BEGIN TRANSACTION");
+                if (isolationLevel) {
+                    this.databaseConnection.begin(this.convertIsolationLevel(isolationLevel), transactionCallback);
+                    this.connection.logger.logQuery("SET TRANSACTION ISOLATION LEVEL " + isolationLevel);
+                }
+                else {
+                    this.databaseConnection.begin(transactionCallback);
+                }
+            }
+            else {
+                this.transactionDepth += 1;
+                await this.query(`SAVE TRANSACTION typeorm_${this.transactionDepth - 1}`);
+                ok();
+            }
+        });
+        await this.broadcaster.broadcast("AfterTransactionStart");
+    }
+    /**
+     * Commits transaction.
+     * Error will be thrown if transaction was not started.
+     */
+    async commitTransaction() {
+        if (this.isReleased)
+            throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
+        if (!this.isTransactionActive)
+            throw new TransactionNotStartedError_1.TransactionNotStartedError();
+        await this.broadcaster.broadcast("BeforeTransactionCommit");
+        if (this.transactionDepth === 1) {
+            return new Promise((ok, fail) => {
+                this.transactionDepth -= 1;
+                this.databaseConnection.commit(async (err) => {
+                    if (err)
+                        return fail(err);
+                    this.isTransactionActive = false;
+                    this.databaseConnection = null;
+                    await this.broadcaster.broadcast("AfterTransactionCommit");
+                    ok();
+                    this.connection.logger.logQuery("COMMIT");
+                });
+            });
+        }
+        this.transactionDepth -= 1;
+    }
+    /**
+     * Rollbacks transaction.
+     * Error will be thrown if transaction was not started.
+     */
+    async rollbackTransaction() {
+        if (this.isReleased)
+            throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
+        if (!this.isTransactionActive)
+            throw new TransactionNotStartedError_1.TransactionNotStartedError();
+        await this.broadcaster.broadcast("BeforeTransactionRollback");
+        if (this.transactionDepth > 1) {
+            this.transactionDepth -= 1;
+            await this.query(`ROLLBACK TRANSACTION typeorm_${this.transactionDepth}`);
+        }
+        else {
+            return new Promise((ok, fail) => {
+                this.transactionDepth -= 1;
+                this.databaseConnection.rollback(async (err) => {
+                    if (err)
+                        return fail(err);
+                    this.isTransactionActive = false;
+                    this.databaseConnection = null;
+                    await this.broadcaster.broadcast("AfterTransactionRollback");
+                    ok();
+                    this.connection.logger.logQuery("ROLLBACK");
+                });
+            });
+        }
+    }
+    /**
+     * Executes a given SQL query.
+     */
+    async query(query, parameters, useStructuredResult = false) {
+        if (this.isReleased)
+            throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
+        const release = await this.lock.acquire();
+        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
+        try {
+            this.driver.connection.logger.logQuery(query, parameters, this);
+            this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);
+            const pool = await (this.mode === "slave"
+                ? this.driver.obtainSlaveConnection()
+                : this.driver.obtainMasterConnection());
+            const request = new this.driver.mssql.Request(this.isTransactionActive ? this.databaseConnection : pool);
+            if (parameters && parameters.length) {
+                parameters.forEach((parameter, index) => {
+                    const parameterName = index.toString();
+                    if (InstanceChecker_1.InstanceChecker.isMssqlParameter(parameter)) {
+                        const mssqlParameter = this.mssqlParameterToNativeParameter(parameter);
+                        if (mssqlParameter) {
+                            request.input(parameterName, mssqlParameter, parameter.value);
+                        }
+                        else {
+                            request.input(parameterName, parameter.value);
+                        }
+                    }
+                    else {
+                        request.input(parameterName, parameter);
+                    }
+                });
+            }
+            const queryStartTime = +new Date();
+            const raw = await new Promise((ok, fail) => {
+                request.query(query, (err, raw) => {
+                    // log slow queries if maxQueryExecution time is set
+                    const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
+                    const queryEndTime = +new Date();
+                    const queryExecutionTime = queryEndTime - queryStartTime;
+                    this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, undefined);
+                    if (maxQueryExecutionTime &&
+                        queryExecutionTime > maxQueryExecutionTime) {
+                        this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
+                    }
+                    if (err) {
+                        fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
+                    }
+                    ok(raw);
+                });
+            });
+            const result = new QueryResult_1.QueryResult();
+            if (raw?.hasOwnProperty("recordset")) {
+                result.records = raw.recordset;
+            }
+            if (raw?.hasOwnProperty("rowsAffected")) {
+                result.affected = raw.rowsAffected[0];
+            }
+            const queryType = query.slice(0, query.indexOf(" "));
+            switch (queryType) {
+                case "DELETE":
+                    // for DELETE query additionally return number of affected rows
+                    result.raw = [raw.recordset, raw.rowsAffected[0]];
+                    break;
+                default:
+                    result.raw = raw.recordset;
+            }
+            if (useStructuredResult) {
+                return result;
+            }
+            else {
+                return result.raw;
+            }
+        }
+        catch (err) {
+            this.driver.connection.logger.logQueryError(err, query, parameters, this);
+            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);
+            throw err;
+        }
+        finally {
+            await broadcasterResult.wait();
+            release();
+        }
+    }
+    /**
+     * Returns raw data stream.
+     */
+    async stream(query, parameters, onEnd, onError) {
+        if (this.isReleased)
+            throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
+        const release = await this.lock.acquire();
+        this.driver.connection.logger.logQuery(query, parameters, this);
+        const pool = await (this.mode === "slave"
+            ? this.driver.obtainSlaveConnection()
+            : this.driver.obtainMasterConnection());
+        const request = new this.driver.mssql.Request(this.isTransactionActive ? this.databaseConnection : pool);
+        if (parameters && parameters.length) {
+            parameters.forEach((parameter, index) => {
+                const parameterName = index.toString();
+                if (InstanceChecker_1.InstanceChecker.isMssqlParameter(parameter)) {
+                    request.input(parameterName, this.mssqlParameterToNativeParameter(parameter), parameter.value);
+                }
+                else {
+                    request.input(parameterName, parameter);
+                }
+            });
+        }
+        request.query(query);
+        const streamRequest = request.toReadableStream();
+        streamRequest.on("error", (err) => {
+            release();
+            this.driver.connection.logger.logQueryError(err, query, parameters, this);
+        });
+        streamRequest.on("end", () => {
+            release();
+        });
+        if (onEnd) {
+            streamRequest.on("end", onEnd);
+        }
+        if (onError) {
+            streamRequest.on("error", onError);
+        }
+        return streamRequest;
+    }
+    /**
+     * Returns all available database names including system databases.
+     */
+    async getDatabases() {
+        const results = await this.query(`EXEC sp_databases`);
+        return results.map((result) => result["DATABASE_NAME"]);
+    }
+    /**
+     * Returns all available schema names including system schemas.
+     * If database parameter specified, returns schemas of that database.
+     */
+    async getSchemas(database) {
+        const query = database
+            ? `SELECT * FROM "${database}"."sys"."schema"`
+            : `SELECT * FROM "sys"."schemas"`;
+        const results = await this.query(query);
+        return results.map((result) => result["name"]);
+    }
+    /**
+     * Checks if database with the given name exist.
+     */
+    async hasDatabase(database) {
+        const result = await this.query(`SELECT DB_ID('${database}') as "db_id"`);
+        const dbId = result[0]["db_id"];
+        return !!dbId;
+    }
+    /**
+     * Loads currently using database
+     */
+    async getCurrentDatabase() {
+        const currentDBQuery = await this.query(`SELECT DB_NAME() AS "db_name"`);
+        return currentDBQuery[0]["db_name"];
+    }
+    /**
+     * Checks if schema with the given name exist.
+     */
+    async hasSchema(schema) {
+        const result = await this.query(`SELECT SCHEMA_ID('${schema}') as "schema_id"`);
+        const schemaId = result[0]["schema_id"];
+        return !!schemaId;
+    }
+    /**
+     * Loads currently using database schema
+     */
+    async getCurrentSchema() {
+        const currentSchemaQuery = await this.query(`SELECT SCHEMA_NAME() AS "schema_name"`);
+        return currentSchemaQuery[0]["schema_name"];
+    }
+    /**
+     * Checks if table with the given name exist in the database.
+     */
+    async hasTable(tableOrName) {
+        const parsedTableName = this.driver.parseTableName(tableOrName);
+        if (!parsedTableName.database) {
+            parsedTableName.database = await this.getCurrentDatabase();
+        }
+        if (!parsedTableName.schema) {
+            parsedTableName.schema = await this.getCurrentSchema();
+        }
+        const sql = `SELECT * FROM "${parsedTableName.database}"."INFORMATION_SCHEMA"."TABLES" WHERE "TABLE_NAME" = '${parsedTableName.tableName}' AND "TABLE_SCHEMA" = '${parsedTableName.schema}'`;
+        const result = await this.query(sql);
+        return result.length ? true : false;
+    }
+    /**
+     * Checks if column exist in the table.
+     */
+    async hasColumn(tableOrName, columnName) {
+        const parsedTableName = this.driver.parseTableName(tableOrName);
+        if (!parsedTableName.database) {
+            parsedTableName.database = await this.getCurrentDatabase();
+        }
+        if (!parsedTableName.schema) {
+            parsedTableName.schema = await this.getCurrentSchema();
+        }
+        const sql = `SELECT * FROM "${parsedTableName.database}"."INFORMATION_SCHEMA"."COLUMNS" WHERE "TABLE_NAME" = '${parsedTableName.tableName}' AND "TABLE_SCHEMA" = '${parsedTableName.schema}' AND "COLUMN_NAME" = '${columnName}'`;
+        const result = await this.query(sql);
+        return result.length ? true : false;
+    }
+    /**
+     * Creates a new database.
+     */
+    async createDatabase(database, ifNotExist) {
+        const up = ifNotExist
+            ? `IF DB_ID('${database}') IS NULL CREATE DATABASE "${database}"`
+            : `CREATE DATABASE "${database}"`;
+        const down = `DROP DATABASE "${database}"`;
+        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
+    }
+    /**
+     * Drops database.
+     */
+    async dropDatabase(database, ifExist) {
+        const up = ifExist
+            ? `IF DB_ID('${database}') IS NOT NULL DROP DATABASE "${database}"`
+            : `DROP DATABASE "${database}"`;
+        const down = `CREATE DATABASE "${database}"`;
+        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
+    }
+    /**
+     * Creates table schema.
+     * If database name also specified (e.g. 'dbName.schemaName') schema will be created in specified database.
+     */
+    async createSchema(schemaPath, ifNotExist) {
+        const upQueries = [];
+        const downQueries = [];
+        if (schemaPath.indexOf(".") === -1) {
+            const upQuery = ifNotExist
+                ? `IF SCHEMA_ID('${schemaPath}') IS NULL BEGIN EXEC ('CREATE SCHEMA "${schemaPath}"') END`
+                : `CREATE SCHEMA "${schemaPath}"`;
+            upQueries.push(new Query_1.Query(upQuery));
+            downQueries.push(new Query_1.Query(`DROP SCHEMA "${schemaPath}"`));
+        }
+        else {
+            const dbName = schemaPath.split(".")[0];
+            const schema = schemaPath.split(".")[1];
+            const currentDB = await this.getCurrentDatabase();
+            upQueries.push(new Query_1.Query(`USE "${dbName}"`));
+            downQueries.push(new Query_1.Query(`USE "${currentDB}"`));
+            const upQuery = ifNotExist
+                ? `IF SCHEMA_ID('${schema}') IS NULL BEGIN EXEC ('CREATE SCHEMA "${schema}"') END`
+                : `CREATE SCHEMA "${schema}"`;
+            upQueries.push(new Query_1.Query(upQuery));
+            downQueries.push(new Query_1.Query(`DROP SCHEMA "${schema}"`));
+            upQueries.push(new Query_1.Query(`USE "${currentDB}"`));
+            downQueries.push(new Query_1.Query(`USE "${dbName}"`));
+        }
+        await this.executeQueries(upQueries, downQueries);
+    }
+    /**
+     * Drops table schema.
+     * If database name also specified (e.g. 'dbName.schemaName') schema will be dropped in specified database.
+     */
+    async dropSchema(schemaPath, ifExist) {
+        const upQueries = [];
+        const downQueries = [];
+        if (schemaPath.indexOf(".") === -1) {
+            const upQuery = ifExist
+                ? `IF SCHEMA_ID('${schemaPath}') IS NULL BEGIN EXEC ('DROP SCHEMA "${schemaPath}"') END`
+                : `DROP SCHEMA "${schemaPath}"`;
+            upQueries.push(new Query_1.Query(upQuery));
+            downQueries.push(new Query_1.Query(`CREATE SCHEMA "${schemaPath}"`));
+        }
+        else {
+            const dbName = schemaPath.split(".")[0];
+            const schema = schemaPath.split(".")[1];
+            const currentDB = await this.getCurrentDatabase();
+            upQueries.push(new Query_1.Query(`USE "${dbName}"`));
+            downQueries.push(new Query_1.Query(`USE "${currentDB}"`));
+            const upQuery = ifExist
+                ? `IF SCHEMA_ID('${schema}') IS NULL BEGIN EXEC ('DROP SCHEMA "${schema}"') END`
+                : `DROP SCHEMA "${schema}"`;
+            upQueries.push(new Query_1.Query(upQuery));
+            downQueries.push(new Query_1.Query(`CREATE SCHEMA "${schema}"`));
+            upQueries.push(new Query_1.Query(`USE "${currentDB}"`));
+            downQueries.push(new Query_1.Query(`USE "${dbName}"`));
+        }
+        await this.executeQueries(upQueries, downQueries);
+    }
+    /**
+     * Creates a new table.
+     */
+    async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
+        if (ifNotExist) {
+            const isTableExist = await this.hasTable(table);
+            if (isTableExist)
+                return Promise.resolve();
+        }
+        const upQueries = [];
+        const downQueries = [];
+        upQueries.push(this.createTableSql(table, createForeignKeys));
+        downQueries.push(this.dropTableSql(table));
+        // if createForeignKeys is true, we must drop created foreign keys in down query.
+        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.
+        if (createForeignKeys)
+            table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));
+        if (createIndices) {
+            table.indices.forEach((index) => {
+                // new index may be passed without name. In this case we generate index name manually.
+                if (!index.name)
+                    index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
+                upQueries.push(this.createIndexSql(table, index));
+                downQueries.push(this.dropIndexSql(table, index));
+            });
+        }
+        // if table have column with generated type, we must add the expression to the metadata table
+        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
+        for (const column of generatedColumns) {
+            const parsedTableName = this.driver.parseTableName(table);
+            if (!parsedTableName.schema) {
+                parsedTableName.schema = await this.getCurrentSchema();
+            }
+            const insertQuery = this.insertTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+                value: column.asExpression,
+            });
+            const deleteQuery = this.deleteTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+            });
+            upQueries.push(insertQuery);
+            downQueries.push(deleteQuery);
+        }
+        await this.executeQueries(upQueries, downQueries);
+    }
+    /**
+     * Drops the table.
+     */
+    async dropTable(tableOrName, ifExist, dropForeignKeys = true, dropIndices = true) {
+        if (ifExist) {
+            const isTableExist = await this.hasTable(tableOrName);
+            if (!isTableExist)
+                return Promise.resolve();
+        }
+        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.
+        const createForeignKeys = dropForeignKeys;
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const upQueries = [];
+        const downQueries = [];
+        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need
+        // to perform drop queries for foreign keys and indices.
+        if (dropIndices) {
+            table.indices.forEach((index) => {
+                upQueries.push(this.dropIndexSql(table, index));
+                downQueries.push(this.createIndexSql(table, index));
+            });
+        }
+        // if dropForeignKeys is true, we just drop the table, otherwise we also drop table foreign keys.
+        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.
+        if (dropForeignKeys)
+            table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));
+        upQueries.push(this.dropTableSql(table));
+        downQueries.push(this.createTableSql(table, createForeignKeys));
+        // if table had columns with generated type, we must remove the expression from the metadata table
+        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);
+        for (const column of generatedColumns) {
+            const parsedTableName = this.driver.parseTableName(table);
+            if (!parsedTableName.schema) {
+                parsedTableName.schema = await this.getCurrentSchema();
+            }
+            const deleteQuery = this.deleteTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+            });
+            const insertQuery = this.insertTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+                value: column.asExpression,
+            });
+            upQueries.push(deleteQuery);
+            downQueries.push(insertQuery);
+        }
+        await this.executeQueries(upQueries, downQueries);
+    }
+    /**
+     * Creates a new view.
+     */
+    async createView(view, syncWithMetadata = false) {
+        const upQueries = [];
+        const downQueries = [];
+        upQueries.push(this.createViewSql(view));
+        if (syncWithMetadata)
+            upQueries.push(await this.insertViewDefinitionSql(view));
+        downQueries.push(this.dropViewSql(view));
+        if (syncWithMetadata)
+            downQueries.push(await this.deleteViewDefinitionSql(view));
+        await this.executeQueries(upQueries, downQueries);
+    }
+    /**
+     * Drops the view.
+     */
+    async dropView(target) {
+        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
+        const view = await this.getCachedView(viewName);
+        const upQueries = [];
+        const downQueries = [];
+        upQueries.push(await this.deleteViewDefinitionSql(view));
+        upQueries.push(this.dropViewSql(view));
+        downQueries.push(await this.insertViewDefinitionSql(view));
+        downQueries.push(this.createViewSql(view));
+        await this.executeQueries(upQueries, downQueries);
+    }
+    /**
+     * Renames a table.
+     */
+    async renameTable(oldTableOrName, newTableName) {
+        const upQueries = [];
+        const downQueries = [];
+        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName)
+            ? oldTableOrName
+            : await this.getCachedTable(oldTableOrName);
+        let newTable = oldTable.clone();
+        // we need database name and schema name to rename FK constraints
+        let dbName = undefined;
+        let schemaName = undefined;
+        let oldTableName = oldTable.name;
+        const splittedName = oldTable.name.split(".");
+        if (splittedName.length === 3) {
+            dbName = splittedName[0];
+            oldTableName = splittedName[2];
+            if (splittedName[1] !== "")
+                schemaName = splittedName[1];
+        }
+        else if (splittedName.length === 2) {
+            schemaName = splittedName[0];
+            oldTableName = splittedName[1];
+        }
+        newTable.name = this.driver.buildTableName(newTableName, schemaName, dbName);
+        // if we have tables with database which differs from database specified in config, we must change currently used database.
+        // This need because we can not rename objects from another database.
+        const currentDB = await this.getCurrentDatabase();
+        if (dbName && dbName !== currentDB) {
+            upQueries.push(new Query_1.Query(`USE "${dbName}"`));
+            downQueries.push(new Query_1.Query(`USE "${currentDB}"`));
+        }
+        // rename table
+        upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(oldTable)}", "${newTableName}"`));
+        downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}", "${oldTableName}"`));
+        // rename primary key constraint
+        if (newTable.primaryColumns.length > 0 &&
+            !newTable.primaryColumns[0].primaryKeyConstraintName) {
+            const columnNames = newTable.primaryColumns.map((column) => column.name);
+            const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);
+            const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);
+            // rename primary constraint
+            upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${oldPkName}", "${newPkName}"`));
+            downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${newPkName}", "${oldPkName}"`));
+        }
+        // rename unique constraints
+        newTable.uniques.forEach((unique) => {
+            const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);
+            // Skip renaming if Unique has user defined constraint name
+            if (unique.name !== oldUniqueName)
+                return;
+            // build new constraint name
+            const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);
+            // build queries
+            upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${unique.name}", "${newUniqueName}"`));
+            downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${newUniqueName}", "${unique.name}"`));
+            // replace constraint name
+            unique.name = newUniqueName;
+        });
+        // rename index constraints
+        newTable.indices.forEach((index) => {
+            const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);
+            // Skip renaming if Index has user defined constraint name
+            if (index.name !== oldIndexName)
+                return;
+            // build new constraint name
+            const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
+            // build queries
+            upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${index.name}", "${newIndexName}", "INDEX"`));
+            downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(newTable)}.${newIndexName}", "${index.name}", "INDEX"`));
+            // replace constraint name
+            index.name = newIndexName;
+        });
+        // rename foreign key constraints
+        newTable.foreignKeys.forEach((foreignKey) => {
+            const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
+            // Skip renaming if foreign key has user defined constraint name
+            if (foreignKey.name !== oldForeignKeyName)
+                return;
+            // build new constraint name
+            const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
+            // build queries
+            upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.buildForeignKeyName(foreignKey.name, schemaName, dbName)}", "${newForeignKeyName}"`));
+            downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.buildForeignKeyName(newForeignKeyName, schemaName, dbName)}", "${foreignKey.name}"`));
+            // replace constraint name
+            foreignKey.name = newForeignKeyName;
+        });
+        // change currently used database back to default db.
+        if (dbName && dbName !== currentDB) {
+            upQueries.push(new Query_1.Query(`USE "${currentDB}"`));
+            downQueries.push(new Query_1.Query(`USE "${dbName}"`));
+        }
+        await this.executeQueries(upQueries, downQueries);
+        // rename old table and replace it in cached tabled;
+        oldTable.name = newTable.name;
+        this.replaceCachedTable(oldTable, newTable);
+    }
+    /**
+     * Creates a new column from the column in the table.
+     */
+    async addColumn(tableOrName, column) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const clonedTable = table.clone();
+        const upQueries = [];
+        const downQueries = [];
+        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column, false, true)}`));
+        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
+        // create or update primary key constraint
+        if (column.isPrimary) {
+            const primaryColumns = clonedTable.primaryColumns;
+            // if table already have primary key, me must drop it and recreate again
+            if (primaryColumns.length > 0) {
+                const pkName = primaryColumns[0].primaryKeyConstraintName
+                    ? primaryColumns[0].primaryKeyConstraintName
+                    : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
+                const columnNames = primaryColumns
+                    .map((column) => `"${column.name}"`)
+                    .join(", ");
+                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
+                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
+            }
+            primaryColumns.push(column);
+            const pkName = primaryColumns[0].primaryKeyConstraintName
+                ? primaryColumns[0].primaryKeyConstraintName
+                : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
+            const columnNames = primaryColumns
+                .map((column) => `"${column.name}"`)
+                .join(", ");
+            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
+            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
+        }
+        // create column index
+        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 &&
+            index.columnNames[0] === column.name);
+        if (columnIndex) {
+            upQueries.push(this.createIndexSql(table, columnIndex));
+            downQueries.push(this.dropIndexSql(table, columnIndex));
+        }
+        // create unique constraint
+        if (column.isUnique) {
+            const uniqueConstraint = new TableUnique_1.TableUnique({
+                name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
+                columnNames: [column.name],
+            });
+            clonedTable.uniques.push(uniqueConstraint);
+            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${column.name}")`));
+            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
+        }
+        // remove default constraint
+        if (column.default !== null && column.default !== undefined) {
+            const defaultName = this.connection.namingStrategy.defaultConstraintName(table, column.name);
+            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${defaultName}"`));
+        }
+        if (column.generatedType && column.asExpression) {
+            const parsedTableName = this.driver.parseTableName(table);
+            if (!parsedTableName.schema) {
+                parsedTableName.schema = await this.getCurrentSchema();
+            }
+            const insertQuery = this.insertTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+                value: column.asExpression,
+            });
+            const deleteQuery = this.deleteTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+            });
+            upQueries.push(insertQuery);
+            downQueries.push(deleteQuery);
+        }
+        await this.executeQueries(upQueries, downQueries);
+        clonedTable.addColumn(column);
+        this.replaceCachedTable(table, clonedTable);
+    }
+    /**
+     * Creates a new columns from the column in the table.
+     */
+    async addColumns(tableOrName, columns) {
+        for (const column of columns) {
+            await this.addColumn(tableOrName, column);
+        }
+    }
+    /**
+     * Renames column in the given table.
+     */
+    async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName)
+            ? oldTableColumnOrName
+            : table.columns.find((c) => c.name === oldTableColumnOrName);
+        if (!oldColumn)
+            throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
+        let newColumn = undefined;
+        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
+            newColumn = newTableColumnOrName;
+        }
+        else {
+            newColumn = oldColumn.clone();
+            newColumn.name = newTableColumnOrName;
+        }
+        await this.changeColumn(table, oldColumn, newColumn);
+    }
+    /**
+     * Changes a column in the table.
+     */
+    async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        let clonedTable = table.clone();
+        const upQueries = [];
+        const downQueries = [];
+        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName)
+            ? oldTableColumnOrName
+            : table.columns.find((column) => column.name === oldTableColumnOrName);
+        if (!oldColumn)
+            throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
+        if ((newColumn.isGenerated !== oldColumn.isGenerated &&
+            newColumn.generationStrategy !== "uuid") ||
+            newColumn.type !== oldColumn.type ||
+            newColumn.length !== oldColumn.length ||
+            newColumn.asExpression !== oldColumn.asExpression ||
+            newColumn.generatedType !== oldColumn.generatedType) {
+            // SQL Server does not support changing of IDENTITY column, so we must drop column and recreate it again.
+            // Also, we recreate column if column type changed
+            await this.dropColumn(table, oldColumn);
+            await this.addColumn(table, newColumn);
+            // update cloned table
+            clonedTable = table.clone();
+        }
+        else {
+            if (newColumn.name !== oldColumn.name) {
+                // we need database name and schema name to rename FK constraints
+                let dbName = undefined;
+                let schemaName = undefined;
+                const splittedName = table.name.split(".");
+                if (splittedName.length === 3) {
+                    dbName = splittedName[0];
+                    if (splittedName[1] !== "")
+                        schemaName = splittedName[1];
+                }
+                else if (splittedName.length === 2) {
+                    schemaName = splittedName[0];
+                }
+                // if we have tables with database which differs from database specified in config, we must change currently used database.
+                // This need because we can not rename objects from another database.
+                const currentDB = await this.getCurrentDatabase();
+                if (dbName && dbName !== currentDB) {
+                    upQueries.push(new Query_1.Query(`USE "${dbName}"`));
+                    downQueries.push(new Query_1.Query(`USE "${currentDB}"`));
+                }
+                // rename the column
+                upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(table)}.${oldColumn.name}", "${newColumn.name}"`));
+                downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(table)}.${newColumn.name}", "${oldColumn.name}"`));
+                // rename column primary key constraint
+                if (oldColumn.isPrimary === true &&
+                    !oldColumn.primaryKeyConstraintName) {
+                    const primaryColumns = clonedTable.primaryColumns;
+                    // build old primary constraint name
+                    const columnNames = primaryColumns.map((column) => column.name);
+                    const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
+                    // replace old column name with new column name
+                    columnNames.splice(columnNames.indexOf(oldColumn.name), 1);
+                    columnNames.push(newColumn.name);
+                    // build new primary constraint name
+                    const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
+                    // rename primary constraint
+                    upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${oldPkName}", "${newPkName}"`));
+                    downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${newPkName}", "${oldPkName}"`));
+                }
+                // rename index constraints
+                clonedTable.findColumnIndices(oldColumn).forEach((index) => {
+                    const oldIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
+                    // Skip renaming if Index has user defined constraint name
+                    if (index.name !== oldIndexName)
+                        return;
+                    // build new constraint name
+                    index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
+                    index.columnNames.push(newColumn.name);
+                    const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
+                    // build queries
+                    upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${index.name}", "${newIndexName}", "INDEX"`));
+                    downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${newIndexName}", "${index.name}", "INDEX"`));
+                    // replace constraint name
+                    index.name = newIndexName;
+                });
+                // rename foreign key constraints
+                clonedTable
+                    .findColumnForeignKeys(oldColumn)
+                    .forEach((foreignKey) => {
+                    const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
+                    // Skip renaming if foreign key has user defined constraint name
+                    if (foreignKey.name !== foreignKeyName)
+                        return;
+                    // build new constraint name
+                    foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
+                    foreignKey.columnNames.push(newColumn.name);
+                    const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
+                    // build queries
+                    upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.buildForeignKeyName(foreignKey.name, schemaName, dbName)}", "${newForeignKeyName}"`));
+                    downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.buildForeignKeyName(newForeignKeyName, schemaName, dbName)}", "${foreignKey.name}"`));
+                    // replace constraint name
+                    foreignKey.name = newForeignKeyName;
+                });
+                // rename check constraints
+                clonedTable.findColumnChecks(oldColumn).forEach((check) => {
+                    // build new constraint name
+                    check.columnNames.splice(check.columnNames.indexOf(oldColumn.name), 1);
+                    check.columnNames.push(newColumn.name);
+                    const newCheckName = this.connection.namingStrategy.checkConstraintName(clonedTable, check.expression);
+                    // build queries
+                    upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${check.name}", "${newCheckName}"`));
+                    downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${newCheckName}", "${check.name}"`));
+                    // replace constraint name
+                    check.name = newCheckName;
+                });
+                // rename unique constraints
+                clonedTable.findColumnUniques(oldColumn).forEach((unique) => {
+                    const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
+                    // Skip renaming if Unique has user defined constraint name
+                    if (unique.name !== oldUniqueName)
+                        return;
+                    // build new constraint name
+                    unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);
+                    unique.columnNames.push(newColumn.name);
+                    const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
+                    // build queries
+                    upQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${unique.name}", "${newUniqueName}"`));
+                    downQueries.push(new Query_1.Query(`EXEC sp_rename "${this.getTablePath(clonedTable)}.${newUniqueName}", "${unique.name}"`));
+                    // replace constraint name
+                    unique.name = newUniqueName;
+                });
+                // rename default constraints
+                if (oldColumn.default !== null &&
+                    oldColumn.default !== undefined) {
+                    const oldDefaultName = this.connection.namingStrategy.defaultConstraintName(table, oldColumn.name);
+                    const newDefaultName = this.connection.namingStrategy.defaultConstraintName(table, newColumn.name);
+                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${oldDefaultName}"`));
+                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${oldDefaultName}" DEFAULT ${oldColumn.default} FOR "${newColumn.name}"`));
+                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${newDefaultName}" DEFAULT ${oldColumn.default} FOR "${newColumn.name}"`));
+                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${newDefaultName}"`));
+                }
+                // change currently used database back to default db.
+                if (dbName && dbName !== currentDB) {
+                    upQueries.push(new Query_1.Query(`USE "${currentDB}"`));
+                    downQueries.push(new Query_1.Query(`USE "${dbName}"`));
+                }
+                // rename old column in the Table object
+                const oldTableColumn = clonedTable.columns.find((column) => column.name === oldColumn.name);
+                clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
+                oldColumn.name = newColumn.name;
+            }
+            if (this.isColumnChanged(oldColumn, newColumn, false, false, false)) {
+                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN ${this.buildCreateColumnSql(table, newColumn, true, false, true)}`));
+                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN ${this.buildCreateColumnSql(table, oldColumn, true, false, true)}`));
+            }
+            if (this.isEnumChanged(oldColumn, newColumn)) {
+                const oldExpression = this.getEnumExpression(oldColumn);
+                const oldCheck = new TableCheck_1.TableCheck({
+                    name: this.connection.namingStrategy.checkConstraintName(table, oldExpression, true),
+                    expression: oldExpression,
+                });
+                const newExpression = this.getEnumExpression(newColumn);
+                const newCheck = new TableCheck_1.TableCheck({
+                    name: this.connection.namingStrategy.checkConstraintName(table, newExpression, true),
+                    expression: newExpression,
+                });
+                upQueries.push(this.dropCheckConstraintSql(table, oldCheck));
+                upQueries.push(this.createCheckConstraintSql(table, newCheck));
+                downQueries.push(this.dropCheckConstraintSql(table, newCheck));
+                downQueries.push(this.createCheckConstraintSql(table, oldCheck));
+            }
+            if (newColumn.isPrimary !== oldColumn.isPrimary) {
+                const primaryColumns = clonedTable.primaryColumns;
+                // if primary column state changed, we must always drop existed constraint.
+                if (primaryColumns.length > 0) {
+                    const pkName = primaryColumns[0].primaryKeyConstraintName
+                        ? primaryColumns[0].primaryKeyConstraintName
+                        : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
+                    const columnNames = primaryColumns
+                        .map((column) => `"${column.name}"`)
+                        .join(", ");
+                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
+                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
+                }
+                if (newColumn.isPrimary === true) {
+                    primaryColumns.push(newColumn);
+                    // update column in table
+                    const column = clonedTable.columns.find((column) => column.name === newColumn.name);
+                    column.isPrimary = true;
+                    const pkName = primaryColumns[0].primaryKeyConstraintName
+                        ? primaryColumns[0].primaryKeyConstraintName
+                        : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
+                    const columnNames = primaryColumns
+                        .map((column) => `"${column.name}"`)
+                        .join(", ");
+                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
+                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
+                }
+                else {
+                    const primaryColumn = primaryColumns.find((c) => c.name === newColumn.name);
+                    primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
+                    // update column in table
+                    const column = clonedTable.columns.find((column) => column.name === newColumn.name);
+                    column.isPrimary = false;
+                    // if we have another primary keys, we must recreate constraint.
+                    if (primaryColumns.length > 0) {
+                        const pkName = primaryColumns[0]
+                            .primaryKeyConstraintName
+                            ? primaryColumns[0].primaryKeyConstraintName
+                            : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
+                        const columnNames = primaryColumns
+                            .map((column) => `"${column.name}"`)
+                            .join(", ");
+                        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
+                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
+                    }
+                }
+            }
+            if (newColumn.isUnique !== oldColumn.isUnique) {
+                if (newColumn.isUnique === true) {
+                    const uniqueConstraint = new TableUnique_1.TableUnique({
+                        name: this.connection.namingStrategy.uniqueConstraintName(table, [newColumn.name]),
+                        columnNames: [newColumn.name],
+                    });
+                    clonedTable.uniques.push(uniqueConstraint);
+                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
+                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
+                }
+                else {
+                    const uniqueConstraint = clonedTable.uniques.find((unique) => {
+                        return (unique.columnNames.length === 1 &&
+                            !!unique.columnNames.find((columnName) => columnName === newColumn.name));
+                    });
+                    clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);
+                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
+                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
+                }
+            }
+            if (newColumn.default !== oldColumn.default) {
+                // (note) if there is a previous default, we need to drop its constraint first
+                if (oldColumn.default !== null &&
+                    oldColumn.default !== undefined) {
+                    const defaultName = this.connection.namingStrategy.defaultConstraintName(table, oldColumn.name);
+                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${defaultName}"`));
+                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${defaultName}" DEFAULT ${oldColumn.default} FOR "${oldColumn.name}"`));
+                }
+                if (newColumn.default !== null &&
+                    newColumn.default !== undefined) {
+                    const defaultName = this.connection.namingStrategy.defaultConstraintName(table, newColumn.name);
+                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${defaultName}" DEFAULT ${newColumn.default} FOR "${newColumn.name}"`));
+                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${defaultName}"`));
+                }
+            }
+            await this.executeQueries(upQueries, downQueries);
+            this.replaceCachedTable(table, clonedTable);
+        }
+    }
+    /**
+     * Changes a column in the table.
+     */
+    async changeColumns(tableOrName, changedColumns) {
+        for (const { oldColumn, newColumn } of changedColumns) {
+            await this.changeColumn(tableOrName, oldColumn, newColumn);
+        }
+    }
+    /**
+     * Drops column in the table.
+     */
+    async dropColumn(tableOrName, columnOrName) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName)
+            ? columnOrName
+            : table.findColumnByName(columnOrName);
+        if (!column)
+            throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
+        const clonedTable = table.clone();
+        const upQueries = [];
+        const downQueries = [];
+        // drop primary key constraint
+        if (column.isPrimary) {
+            const pkName = column.primaryKeyConstraintName
+                ? column.primaryKeyConstraintName
+                : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column) => column.name));
+            const columnNames = clonedTable.primaryColumns
+                .map((primaryColumn) => `"${primaryColumn.name}"`)
+                .join(", ");
+            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
+            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
+            // update column in table
+            const tableColumn = clonedTable.findColumnByName(column.name);
+            tableColumn.isPrimary = false;
+            // if primary key have multiple columns, we must recreate it without dropped column
+            if (clonedTable.primaryColumns.length > 0) {
+                const pkName = clonedTable.primaryColumns[0]
+                    .primaryKeyConstraintName
+                    ? clonedTable.primaryColumns[0].primaryKeyConstraintName
+                    : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column) => column.name));
+                const columnNames = clonedTable.primaryColumns
+                    .map((primaryColumn) => `"${primaryColumn.name}"`)
+                    .join(", ");
+                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
+                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
+            }
+        }
+        // drop column index
+        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 &&
+            index.columnNames[0] === column.name);
+        if (columnIndex) {
+            clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
+            upQueries.push(this.dropIndexSql(table, columnIndex));
+            downQueries.push(this.createIndexSql(table, columnIndex));
+        }
+        // drop column check
+        const columnCheck = clonedTable.checks.find((check) => !!check.columnNames &&
+            check.columnNames.length === 1 &&
+            check.columnNames[0] === column.name);
+        if (columnCheck) {
+            clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
+            upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
+            downQueries.push(this.createCheckConstraintSql(table, columnCheck));
+        }
+        // drop column unique
+        const columnUnique = clonedTable.uniques.find((unique) => unique.columnNames.length === 1 &&
+            unique.columnNames[0] === column.name);
+        if (columnUnique) {
+            clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);
+            upQueries.push(this.dropUniqueConstraintSql(table, columnUnique));
+            downQueries.push(this.createUniqueConstraintSql(table, columnUnique));
+        }
+        // drop default constraint
+        if (column.default !== null && column.default !== undefined) {
+            const defaultName = this.connection.namingStrategy.defaultConstraintName(table, column.name);
+            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${defaultName}"`));
+            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${defaultName}" DEFAULT ${column.default} FOR "${column.name}"`));
+        }
+        if (column.generatedType && column.asExpression) {
+            const parsedTableName = this.driver.parseTableName(table);
+            if (!parsedTableName.schema) {
+                parsedTableName.schema = await this.getCurrentSchema();
+            }
+            const deleteQuery = this.deleteTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+            });
+            const insertQuery = this.insertTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+                value: column.asExpression,
+            });
+            upQueries.push(deleteQuery);
+            downQueries.push(insertQuery);
+        }
+        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
+        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column, false, false)}`));
+        await this.executeQueries(upQueries, downQueries);
+        clonedTable.removeColumn(column);
+        this.replaceCachedTable(table, clonedTable);
+    }
+    /**
+     * Drops the columns in the table.
+     */
+    async dropColumns(tableOrName, columns) {
+        for (const column of columns) {
+            await this.dropColumn(tableOrName, column);
+        }
+    }
+    /**
+     * Creates a new primary key.
+     */
+    async createPrimaryKey(tableOrName, columnNames, constraintName) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const clonedTable = table.clone();
+        const up = this.createPrimaryKeySql(table, columnNames, constraintName);
+        // mark columns as primary, because dropPrimaryKeySql build constraint name from table primary column names.
+        clonedTable.columns.forEach((column) => {
+            if (columnNames.find((columnName) => columnName === column.name))
+                column.isPrimary = true;
+        });
+        const down = this.dropPrimaryKeySql(clonedTable);
+        await this.executeQueries(up, down);
+        this.replaceCachedTable(table, clonedTable);
+    }
+    /**
+     * Updates composite primary keys.
+     */
+    async updatePrimaryKeys(tableOrName, columns) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const clonedTable = table.clone();
+        const columnNames = columns.map((column) => column.name);
+        const upQueries = [];
+        const downQueries = [];
+        // if table already have primary columns, we must drop them.
+        const primaryColumns = clonedTable.primaryColumns;
+        if (primaryColumns.length > 0) {
+            const pkName = primaryColumns[0].primaryKeyConstraintName
+                ? primaryColumns[0].primaryKeyConstraintName
+                : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));
+            const columnNamesString = primaryColumns
+                .map((column) => `"${column.name}"`)
+                .join(", ");
+            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
+            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
+        }
+        // update columns in table.
+        clonedTable.columns
+            .filter((column) => columnNames.indexOf(column.name) !== -1)
+            .forEach((column) => (column.isPrimary = true));
+        const pkName = primaryColumns[0].primaryKeyConstraintName
+            ? primaryColumns[0].primaryKeyConstraintName
+            : this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
+        const columnNamesString = columnNames
+            .map((columnName) => `"${columnName}"`)
+            .join(", ");
+        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
+        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
+        await this.executeQueries(upQueries, downQueries);
+        this.replaceCachedTable(table, clonedTable);
+    }
+    /**
+     * Drops a primary key.
+     */
+    async dropPrimaryKey(tableOrName, constraintName) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const up = this.dropPrimaryKeySql(table);
+        const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column) => column.name), constraintName);
+        await this.executeQueries(up, down);
+        table.primaryColumns.forEach((column) => {
+            column.isPrimary = false;
+        });
+    }
+    /**
+     * Creates a new unique constraint.
+     */
+    async createUniqueConstraint(tableOrName, uniqueConstraint) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        // new unique constraint may be passed without name. In this case we generate unique name manually.
+        if (!uniqueConstraint.name)
+            uniqueConstraint.name =
+                this.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);
+        const up = this.createUniqueConstraintSql(table, uniqueConstraint);
+        const down = this.dropUniqueConstraintSql(table, uniqueConstraint);
+        await this.executeQueries(up, down);
+        table.addUniqueConstraint(uniqueConstraint);
+    }
+    /**
+     * Creates a new unique constraints.
+     */
+    async createUniqueConstraints(tableOrName, uniqueConstraints) {
+        const promises = uniqueConstraints.map((uniqueConstraint) => this.createUniqueConstraint(tableOrName, uniqueConstraint));
+        await Promise.all(promises);
+    }
+    /**
+     * Drops unique constraint.
+     */
+    async dropUniqueConstraint(tableOrName, uniqueOrName) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const uniqueConstraint = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName)
+            ? uniqueOrName
+            : table.uniques.find((u) => u.name === uniqueOrName);
+        if (!uniqueConstraint)
+            throw new error_1.TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);
+        const up = this.dropUniqueConstraintSql(table, uniqueConstraint);
+        const down = this.createUniqueConstraintSql(table, uniqueConstraint);
+        await this.executeQueries(up, down);
+        table.removeUniqueConstraint(uniqueConstraint);
+    }
+    /**
+     * Drops an unique constraints.
+     */
+    async dropUniqueConstraints(tableOrName, uniqueConstraints) {
+        const promises = uniqueConstraints.map((uniqueConstraint) => this.dropUniqueConstraint(tableOrName, uniqueConstraint));
+        await Promise.all(promises);
+    }
+    /**
+     * Creates a new check constraint.
+     */
+    async createCheckConstraint(tableOrName, checkConstraint) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        // new unique constraint may be passed without name. In this case we generate unique name manually.
+        if (!checkConstraint.name)
+            checkConstraint.name =
+                this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
+        const up = this.createCheckConstraintSql(table, checkConstraint);
+        const down = this.dropCheckConstraintSql(table, checkConstraint);
+        await this.executeQueries(up, down);
+        table.addCheckConstraint(checkConstraint);
+    }
+    /**
+     * Creates a new check constraints.
+     */
+    async createCheckConstraints(tableOrName, checkConstraints) {
+        const promises = checkConstraints.map((checkConstraint) => this.createCheckConstraint(tableOrName, checkConstraint));
+        await Promise.all(promises);
+    }
+    /**
+     * Drops check constraint.
+     */
+    async dropCheckConstraint(tableOrName, checkOrName) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const checkConstraint = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName)
+            ? checkOrName
+            : table.checks.find((c) => c.name === checkOrName);
+        if (!checkConstraint)
+            throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
+        const up = this.dropCheckConstraintSql(table, checkConstraint);
+        const down = this.createCheckConstraintSql(table, checkConstraint);
+        await this.executeQueries(up, down);
+        table.removeCheckConstraint(checkConstraint);
+    }
+    /**
+     * Drops check constraints.
+     */
+    async dropCheckConstraints(tableOrName, checkConstraints) {
+        const promises = checkConstraints.map((checkConstraint) => this.dropCheckConstraint(tableOrName, checkConstraint));
+        await Promise.all(promises);
+    }
+    /**
+     * Creates a new exclusion constraint.
+     */
+    async createExclusionConstraint(tableOrName, exclusionConstraint) {
+        throw new error_1.TypeORMError(`SqlServer does not support exclusion constraints.`);
+    }
+    /**
+     * Creates a new exclusion constraints.
+     */
+    async createExclusionConstraints(tableOrName, exclusionConstraints) {
+        throw new error_1.TypeORMError(`SqlServer does not support exclusion constraints.`);
+    }
+    /**
+     * Drops exclusion constraint.
+     */
+    async dropExclusionConstraint(tableOrName, exclusionOrName) {
+        throw new error_1.TypeORMError(`SqlServer does not support exclusion constraints.`);
+    }
+    /**
+     * Drops exclusion constraints.
+     */
+    async dropExclusionConstraints(tableOrName, exclusionConstraints) {
+        throw new error_1.TypeORMError(`SqlServer does not support exclusion constraints.`);
+    }
+    /**
+     * Creates a new foreign key.
+     */
+    async createForeignKey(tableOrName, foreignKey) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const metadata = this.connection.hasMetadata(table.name)
+            ? this.connection.getMetadata(table.name)
+            : undefined;
+        if (metadata &&
+            metadata.treeParentRelation &&
+            metadata.treeParentRelation.isTreeParent &&
+            metadata.foreignKeys.find((foreignKey) => foreignKey.onDelete !== "NO ACTION"))
+            throw new error_1.TypeORMError("SqlServer does not support options in TreeParent.");
+        // new FK may be passed without name. In this case we generate FK name manually.
+        if (!foreignKey.name)
+            foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
+        const up = this.createForeignKeySql(table, foreignKey);
+        const down = this.dropForeignKeySql(table, foreignKey);
+        await this.executeQueries(up, down);
+        table.addForeignKey(foreignKey);
+    }
+    /**
+     * Creates a new foreign keys.
+     */
+    async createForeignKeys(tableOrName, foreignKeys) {
+        const promises = foreignKeys.map((foreignKey) => this.createForeignKey(tableOrName, foreignKey));
+        await Promise.all(promises);
+    }
+    /**
+     * Drops a foreign key from the table.
+     */
+    async dropForeignKey(tableOrName, foreignKeyOrName) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName)
+            ? foreignKeyOrName
+            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);
+        if (!foreignKey)
+            throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
+        const up = this.dropForeignKeySql(table, foreignKey);
+        const down = this.createForeignKeySql(table, foreignKey);
+        await this.executeQueries(up, down);
+        table.removeForeignKey(foreignKey);
+    }
+    /**
+     * Drops a foreign keys from the table.
+     */
+    async dropForeignKeys(tableOrName, foreignKeys) {
+        const promises = foreignKeys.map((foreignKey) => this.dropForeignKey(tableOrName, foreignKey));
+        await Promise.all(promises);
+    }
+    /**
+     * Creates a new index.
+     */
+    async createIndex(tableOrName, index) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        // new index may be passed without name. In this case we generate index name manually.
+        if (!index.name)
+            index.name = this.generateIndexName(table, index);
+        const up = this.createIndexSql(table, index);
+        const down = this.dropIndexSql(table, index);
+        await this.executeQueries(up, down);
+        table.addIndex(index);
+    }
+    /**
+     * Creates a new indices
+     */
+    async createIndices(tableOrName, indices) {
+        const promises = indices.map((index) => this.createIndex(tableOrName, index));
+        await Promise.all(promises);
+    }
+    /**
+     * Drops an index.
+     */
+    async dropIndex(tableOrName, indexOrName) {
+        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName);
+        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName)
+            ? indexOrName
+            : table.indices.find((i) => i.name === indexOrName);
+        if (!index)
+            throw new error_1.TypeORMError(`Supplied index was not found in table ${table.name}`);
+        // old index may be passed without name. In this case we generate index name manually.
+        if (!index.name)
+            index.name = this.generateIndexName(table, index);
+        const up = this.dropIndexSql(table, index);
+        const down = this.createIndexSql(table, index);
+        await this.executeQueries(up, down);
+        table.removeIndex(index);
+    }
+    /**
+     * Drops an indices from the table.
+     */
+    async dropIndices(tableOrName, indices) {
+        const promises = indices.map((index) => this.dropIndex(tableOrName, index));
+        await Promise.all(promises);
+    }
+    /**
+     * Clears all table contents.
+     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
+     */
+    async clearTable(tablePath) {
+        await this.query(`TRUNCATE TABLE ${this.escapePath(tablePath)}`);
+    }
+    /**
+     * Removes all tables from the currently connected database.
+     */
+    async clearDatabase(database) {
+        if (database) {
+            const isDatabaseExist = await this.hasDatabase(database);
+            if (!isDatabaseExist)
+                return Promise.resolve();
+        }
+        const isAnotherTransactionActive = this.isTransactionActive;
+        if (!isAnotherTransactionActive)
+            await this.startTransaction();
+        try {
+            let allViewsSql = database
+                ? `SELECT * FROM "${database}"."INFORMATION_SCHEMA"."VIEWS"`
+                : `SELECT * FROM "INFORMATION_SCHEMA"."VIEWS"`;
+            const allViewsResults = await this.query(allViewsSql);
+            await Promise.all(allViewsResults.map((viewResult) => {
+                // 'DROP VIEW' does not allow specifying the database name as a prefix to the object name.
+                const dropTableSql = `DROP VIEW "${viewResult["TABLE_SCHEMA"]}"."${viewResult["TABLE_NAME"]}"`;
+                return this.query(dropTableSql);
+            }));
+            let allTablesSql = database
+                ? `SELECT * FROM "${database}"."INFORMATION_SCHEMA"."TABLES" WHERE "TABLE_TYPE" = 'BASE TABLE'`
+                : `SELECT * FROM "INFORMATION_SCHEMA"."TABLES" WHERE "TABLE_TYPE" = 'BASE TABLE'`;
+            const allTablesResults = await this.query(allTablesSql);
+            if (allTablesResults.length > 0) {
+                const tablesByCatalog = allTablesResults.reduce((c, { TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME }) => {
+                    c[TABLE_CATALOG] = c[TABLE_CATALOG] || [];
+                    c[TABLE_CATALOG].push({ TABLE_SCHEMA, TABLE_NAME });
+                    return c;
+                }, {});
+                const foreignKeysSql = Object.entries(tablesByCatalog)
+                    .map(([TABLE_CATALOG, tables]) => {
+                    const conditions = tables
+                        .map(({ TABLE_SCHEMA, TABLE_NAME }) => {
+                        return `("fk"."referenced_object_id" = OBJECT_ID('"${TABLE_CATALOG}"."${TABLE_SCHEMA}"."${TABLE_NAME}"'))`;
+                    })
+                        .join(" OR ");
+                    return `
+                        SELECT DISTINCT '${TABLE_CATALOG}' AS                                              "TABLE_CATALOG",
+                                        OBJECT_SCHEMA_NAME("fk"."parent_object_id",
+                                                           DB_ID('${TABLE_CATALOG}')) AS                   "TABLE_SCHEMA",
+                                        OBJECT_NAME("fk"."parent_object_id", DB_ID('${TABLE_CATALOG}')) AS "TABLE_NAME",
+                                        "fk"."name" AS                                                     "CONSTRAINT_NAME"
+                        FROM "${TABLE_CATALOG}"."sys"."foreign_keys" AS "fk"
+                        WHERE (${conditions})
+                    `;
+                })
+                    .join(" UNION ALL ");
+                const foreignKeys = await this.query(foreignKeysSql);
+                await Promise.all(foreignKeys.map(async ({ TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, CONSTRAINT_NAME, }) => {
+                    // Disable the constraint first.
+                    await this.query(`ALTER TABLE "${TABLE_CATALOG}"."${TABLE_SCHEMA}"."${TABLE_NAME}" ` +
+                        `NOCHECK CONSTRAINT "${CONSTRAINT_NAME}"`);
+                    await this.query(`ALTER TABLE "${TABLE_CATALOG}"."${TABLE_SCHEMA}"."${TABLE_NAME}" ` +
+                        `DROP CONSTRAINT "${CONSTRAINT_NAME}" -- FROM CLEAR`);
+                }));
+                await Promise.all(allTablesResults.map((tablesResult) => {
+                    if (tablesResult["TABLE_NAME"].startsWith("#")) {
+                        // don't try to drop temporary tables
+                        return;
+                    }
+                    const dropTableSql = `DROP TABLE "${tablesResult["TABLE_CATALOG"]}"."${tablesResult["TABLE_SCHEMA"]}"."${tablesResult["TABLE_NAME"]}"`;
+                    return this.query(dropTableSql);
+                }));
+            }
+            if (!isAnotherTransactionActive)
+                await this.commitTransaction();
+        }
+        catch (error) {
+            try {
+                // we throw original error even if rollback thrown an error
+                if (!isAnotherTransactionActive)
+                    await this.rollbackTransaction();
+            }
+            catch (rollbackError) { }
+            throw error;
+        }
+    }
+    // -------------------------------------------------------------------------
+    // Protected Methods
+    // -------------------------------------------------------------------------
+    async loadViews(viewPaths) {
+        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
+        if (!hasTable) {
+            return [];
+        }
+        if (!viewPaths) {
+            viewPaths = [];
+        }
+        const currentSchema = await this.getCurrentSchema();
+        const currentDatabase = await this.getCurrentDatabase();
+        const dbNames = viewPaths
+            .map((viewPath) => this.driver.parseTableName(viewPath).database)
+            .filter((database) => database);
+        if (this.driver.database &&
+            !dbNames.find((dbName) => dbName === this.driver.database))
+            dbNames.push(this.driver.database);
+        const viewsCondition = viewPaths
+            .map((viewPath) => {
+            let { schema, tableName: name } = this.driver.parseTableName(viewPath);
+            if (!schema) {
+                schema = currentSchema;
+            }
+            return `("T"."SCHEMA" = '${schema}' AND "T"."NAME" = '${name}')`;
+        })
+            .join(" OR ");
+        const query = dbNames
+            .map((dbName) => {
+            return (`SELECT "T".*, "V"."CHECK_OPTION" FROM ${this.escapePath(this.getTypeormMetadataTableName())} "t" ` +
+                `INNER JOIN "${dbName}"."INFORMATION_SCHEMA"."VIEWS" "V" ON "V"."TABLE_SCHEMA" = "T"."SCHEMA" AND "v"."TABLE_NAME" = "T"."NAME" WHERE "T"."TYPE" = '${MetadataTableType_1.MetadataTableType.VIEW}' ${viewsCondition ? `AND (${viewsCondition})` : ""}`);
+        })
+            .join(" UNION ALL ");
+        const dbViews = await this.query(query);
+        return dbViews.map((dbView) => {
+            const view = new View_1.View();
+            const db = dbView["TABLE_CATALOG"] === currentDatabase
+                ? undefined
+                : dbView["TABLE_CATALOG"];
+            const schema = dbView["schema"] === currentSchema &&
+                !this.driver.options.schema
+                ? undefined
+                : dbView["schema"];
+            view.database = dbView["TABLE_CATALOG"];
+            view.schema = dbView["schema"];
+            view.name = this.driver.buildTableName(dbView["name"], schema, db);
+            view.expression = dbView["value"];
+            return view;
+        });
+    }
+    /**
+     * Loads all tables (with given names) from the database and creates a Table from them.
+     */
+    async loadTables(tableNames) {
+        // if no tables given then no need to proceed
+        if (tableNames && tableNames.length === 0) {
+            return [];
+        }
+        const currentSchema = await this.getCurrentSchema();
+        const currentDatabase = await this.getCurrentDatabase();
+        const dbTables = [];
+        if (!tableNames) {
+            const databasesSql = `SELECT DISTINCT "name" ` +
+                `FROM "master"."dbo"."sysdatabases" ` +
+                `WHERE "name" NOT IN ('master', 'model', 'msdb')`;
+            const dbDatabases = await this.query(databasesSql);
+            const tablesSql = dbDatabases
+                .map(({ name }) => {
+                return `
+                    SELECT DISTINCT
+                        "TABLE_CATALOG", "TABLE_SCHEMA", "TABLE_NAME"
+                    FROM "${name}"."INFORMATION_SCHEMA"."TABLES"
+                    WHERE
+                      "TABLE_TYPE" = 'BASE TABLE'
+                      AND
+                      "TABLE_CATALOG" = '${name}'
+                      AND
+                      ISNULL(Objectproperty(Object_id("TABLE_CATALOG" + '.' + "TABLE_SCHEMA" + '.' + "TABLE_NAME"), 'IsMSShipped'), 0) = 0
+                `;
+            })
+                .join(" UNION ALL ");
+            dbTables.push(...(await this.query(tablesSql)));
+        }
+        else {
+            const tableNamesByCatalog = tableNames
+                .map((tableName) => this.driver.parseTableName(tableName))
+                .reduce((c, { database, ...other }) => {
+                database = database || currentDatabase;
+                c[database] = c[database] || [];
+                c[database].push({
+                    schema: other.schema || currentSchema,
+                    tableName: other.tableName,
+                });
+                return c;
+            }, {});
+            const tablesSql = Object.entries(tableNamesByCatalog)
+                .map(([database, tables]) => {
+                const tablesCondition = tables
+                    .map(({ schema, tableName }) => {
+                    return `("TABLE_SCHEMA" = '${schema}' AND "TABLE_NAME" = '${tableName}')`;
+                })
+                    .join(" OR ");
+                return `
+                    SELECT DISTINCT
+                        "TABLE_CATALOG", "TABLE_SCHEMA", "TABLE_NAME"
+                    FROM "${database}"."INFORMATION_SCHEMA"."TABLES"
+                    WHERE
+                          "TABLE_TYPE" = 'BASE TABLE' AND
+                          "TABLE_CATALOG" = '${database}' AND
+                          ${tablesCondition}
+                `;
+            })
+                .join(" UNION ALL ");
+            dbTables.push(...(await this.query(tablesSql)));
+        }
+        // if tables were not found in the db, no need to proceed
+        if (dbTables.length === 0) {
+            return [];
+        }
+        const dbTablesByCatalog = dbTables.reduce((c, { TABLE_CATALOG, ...other }) => {
+            c[TABLE_CATALOG] = c[TABLE_CATALOG] || [];
+            c[TABLE_CATALOG].push(other);
+            return c;
+        }, {});
+        const columnsSql = Object.entries(dbTablesByCatalog)
+            .map(([TABLE_CATALOG, tables]) => {
+            const condition = tables
+                .map(({ TABLE_SCHEMA, TABLE_NAME }) => `("TABLE_SCHEMA" = '${TABLE_SCHEMA}' AND "TABLE_NAME" = '${TABLE_NAME}')`)
+                .join("OR");
+            return (`SELECT "COLUMNS".*, "cc"."is_persisted", "cc"."definition" ` +
+                `FROM "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."COLUMNS" ` +
+                `LEFT JOIN "sys"."computed_columns" "cc" ON COL_NAME("cc"."object_id", "cc"."column_id") = "column_name" ` +
+                `WHERE (${condition})`);
+        })
+            .join(" UNION ALL ");
+        const constraintsSql = Object.entries(dbTablesByCatalog)
+            .map(([TABLE_CATALOG, tables]) => {
+            const conditions = tables
+                .map(({ TABLE_NAME, TABLE_SCHEMA }) => `("columnUsages"."TABLE_SCHEMA" = '${TABLE_SCHEMA}' AND "columnUsages"."TABLE_NAME" = '${TABLE_NAME}')`)
+                .join(" OR ");
+            return (`SELECT "columnUsages".*, "tableConstraints"."CONSTRAINT_TYPE", "chk"."definition" ` +
+                `FROM "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."CONSTRAINT_COLUMN_USAGE" "columnUsages" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."TABLE_CONSTRAINTS" "tableConstraints" ` +
+                `ON ` +
+                `"tableConstraints"."CONSTRAINT_NAME" = "columnUsages"."CONSTRAINT_NAME" AND ` +
+                `"tableConstraints"."TABLE_SCHEMA" = "columnUsages"."TABLE_SCHEMA" AND ` +
+                `"tableConstraints"."TABLE_NAME" = "columnUsages"."TABLE_NAME" ` +
+                `LEFT JOIN "${TABLE_CATALOG}"."sys"."check_constraints" "chk" ` +
+                `ON ` +
+                `"chk"."object_id" = OBJECT_ID("columnUsages"."TABLE_CATALOG" + '.' + "columnUsages"."TABLE_SCHEMA" + '.' + "columnUsages"."CONSTRAINT_NAME") ` +
+                `WHERE ` +
+                `(${conditions}) AND ` +
+                `"tableConstraints"."CONSTRAINT_TYPE" IN ('PRIMARY KEY', 'UNIQUE', 'CHECK')`);
+        })
+            .join(" UNION ALL ");
+        const foreignKeysSql = Object.entries(dbTablesByCatalog)
+            .map(([TABLE_CATALOG, tables]) => {
+            const conditions = tables
+                .map(({ TABLE_NAME, TABLE_SCHEMA }) => `("s1"."name" = '${TABLE_SCHEMA}' AND "t1"."name" = '${TABLE_NAME}')`)
+                .join(" OR ");
+            return (`SELECT "fk"."name" AS "FK_NAME", '${TABLE_CATALOG}' AS "TABLE_CATALOG", "s1"."name" AS "TABLE_SCHEMA", "t1"."name" AS "TABLE_NAME", ` +
+                `"col1"."name" AS "COLUMN_NAME", "s2"."name" AS "REF_SCHEMA", "t2"."name" AS "REF_TABLE", "col2"."name" AS "REF_COLUMN", ` +
+                `"fk"."delete_referential_action_desc" AS "ON_DELETE", "fk"."update_referential_action_desc" AS "ON_UPDATE" ` +
+                `FROM "${TABLE_CATALOG}"."sys"."foreign_keys" "fk" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."sys"."foreign_key_columns" "fkc" ON "fkc"."constraint_object_id" = "fk"."object_id" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."sys"."tables" "t1" ON "t1"."object_id" = "fk"."parent_object_id" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."sys"."schemas" "s1" ON "s1"."schema_id" = "t1"."schema_id" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."sys"."tables" "t2" ON "t2"."object_id" = "fk"."referenced_object_id" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."sys"."schemas" "s2" ON "s2"."schema_id" = "t2"."schema_id" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."sys"."columns" "col1" ON "col1"."column_id" = "fkc"."parent_column_id" AND "col1"."object_id" = "fk"."parent_object_id" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."sys"."columns" "col2" ON "col2"."column_id" = "fkc"."referenced_column_id" AND "col2"."object_id" = "fk"."referenced_object_id" ` +
+                `WHERE (${conditions})`);
+        })
+            .join(" UNION ALL ");
+        const identityColumnsSql = Object.entries(dbTablesByCatalog)
+            .map(([TABLE_CATALOG, tables]) => {
+            const conditions = tables
+                .map(({ TABLE_NAME, TABLE_SCHEMA }) => `("TABLE_SCHEMA" = '${TABLE_SCHEMA}' AND "TABLE_NAME" = '${TABLE_NAME}')`)
+                .join(" OR ");
+            return (`SELECT "TABLE_CATALOG", "TABLE_SCHEMA", "COLUMN_NAME", "TABLE_NAME" ` +
+                `FROM "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."COLUMNS" ` +
+                `WHERE ` +
+                `EXISTS(SELECT 1 FROM "${TABLE_CATALOG}"."sys"."columns" "S" WHERE OBJECT_ID("TABLE_CATALOG" + '.' + "TABLE_SCHEMA" + '.' + "TABLE_NAME") = "S"."OBJECT_ID" AND "COLUMN_NAME" = "S"."NAME" AND "S"."is_identity" = 1) AND ` +
+                `(${conditions})`);
+        })
+            .join(" UNION ALL ");
+        const dbCollationsSql = `SELECT "NAME", "COLLATION_NAME" FROM "sys"."databases"`;
+        const indicesSql = Object.entries(dbTablesByCatalog)
+            .map(([TABLE_CATALOG, tables]) => {
+            const conditions = tables
+                .map(({ TABLE_NAME, TABLE_SCHEMA }) => `("s"."name" = '${TABLE_SCHEMA}' AND "t"."name" = '${TABLE_NAME}')`)
+                .join(" OR ");
+            return (`SELECT '${TABLE_CATALOG}' AS "TABLE_CATALOG", "s"."name" AS "TABLE_SCHEMA", "t"."name" AS "TABLE_NAME", ` +
+                `"ind"."name" AS "INDEX_NAME", "col"."name" AS "COLUMN_NAME", "ind"."is_unique" AS "IS_UNIQUE", "ind"."filter_definition" as "CONDITION" ` +
+                `FROM "${TABLE_CATALOG}"."sys"."indexes" "ind" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."sys"."index_columns" "ic" ON "ic"."object_id" = "ind"."object_id" AND "ic"."index_id" = "ind"."index_id" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."sys"."columns" "col" ON "col"."object_id" = "ic"."object_id" AND "col"."column_id" = "ic"."column_id" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."sys"."tables" "t" ON "t"."object_id" = "ind"."object_id" ` +
+                `INNER JOIN "${TABLE_CATALOG}"."sys"."schemas" "s" ON "s"."schema_id" = "t"."schema_id" ` +
+                `WHERE ` +
+                `"ind"."is_primary_key" = 0 AND "ind"."is_unique_constraint" = 0 AND "t"."is_ms_shipped" = 0 AND ` +
+                `(${conditions})`);
+        })
+            .join(" UNION ALL ");
+        const [dbColumns, dbConstraints, dbForeignKeys, dbIdentityColumns, dbCollations, dbIndices,] = await Promise.all([
+            this.query(columnsSql),
+            this.query(constraintsSql),
+            this.query(foreignKeysSql),
+            this.query(identityColumnsSql),
+            this.query(dbCollationsSql),
+            this.query(indicesSql),
+        ]);
+        // create table schemas for loaded tables
+        return await Promise.all(dbTables.map(async (dbTable) => {
+            const table = new Table_1.Table();
+            const getSchemaFromKey = (dbObject, key) => {
+                return dbObject[key] === currentSchema &&
+                    (!this.driver.options.schema ||
+                        this.driver.options.schema === currentSchema)
+                    ? undefined
+                    : dbObject[key];
+            };
+            // We do not need to join schema and database names, when db or schema is by default.
+            const db = dbTable["TABLE_CATALOG"] === currentDatabase
+                ? undefined
+                : dbTable["TABLE_CATALOG"];
+            const schema = getSchemaFromKey(dbTable, "TABLE_SCHEMA");
+            table.database = dbTable["TABLE_CATALOG"];
+            table.schema = dbTable["TABLE_SCHEMA"];
+            table.name = this.driver.buildTableName(dbTable["TABLE_NAME"], schema, db);
+            const defaultCollation = dbCollations.find((dbCollation) => dbCollation["NAME"] === dbTable["TABLE_CATALOG"]);
+            // create columns from the loaded columns
+            table.columns = await Promise.all(dbColumns
+                .filter((dbColumn) => dbColumn["TABLE_NAME"] ===
+                dbTable["TABLE_NAME"] &&
+                dbColumn["TABLE_SCHEMA"] ===
+                    dbTable["TABLE_SCHEMA"] &&
+                dbColumn["TABLE_CATALOG"] ===
+                    dbTable["TABLE_CATALOG"])
+                .map(async (dbColumn) => {
+                const columnConstraints = dbConstraints.filter((dbConstraint) => dbConstraint["TABLE_NAME"] ===
+                    dbColumn["TABLE_NAME"] &&
+                    dbConstraint["TABLE_SCHEMA"] ===
+                        dbColumn["TABLE_SCHEMA"] &&
+                    dbConstraint["TABLE_CATALOG"] ===
+                        dbColumn["TABLE_CATALOG"] &&
+                    dbConstraint["COLUMN_NAME"] ===
+                        dbColumn["COLUMN_NAME"]);
+                const uniqueConstraints = columnConstraints.filter((constraint) => constraint["CONSTRAINT_TYPE"] === "UNIQUE");
+                const isConstraintComposite = uniqueConstraints.every((uniqueConstraint) => {
+                    return dbConstraints.some((dbConstraint) => dbConstraint["CONSTRAINT_TYPE"] ===
+                        "UNIQUE" &&
+                        dbConstraint["CONSTRAINT_NAME"] ===
+                            uniqueConstraint["CONSTRAINT_NAME"] &&
+                        dbConstraint["TABLE_SCHEMA"] ===
+                            dbColumn["TABLE_SCHEMA"] &&
+                        dbConstraint["TABLE_CATALOG"] ===
+                            dbColumn["TABLE_CATALOG"] &&
+                        dbConstraint["COLUMN_NAME"] !==
+                            dbColumn["COLUMN_NAME"]);
+                });
+                const isGenerated = !!dbIdentityColumns.find((column) => column["TABLE_NAME"] ===
+                    dbColumn["TABLE_NAME"] &&
+                    column["TABLE_SCHEMA"] ===
+                        dbColumn["TABLE_SCHEMA"] &&
+                    column["TABLE_CATALOG"] ===
+                        dbColumn["TABLE_CATALOG"] &&
+                    column["COLUMN_NAME"] ===
+                        dbColumn["COLUMN_NAME"]);
+                const tableColumn = new TableColumn_1.TableColumn();
+                tableColumn.name = dbColumn["COLUMN_NAME"];
+                tableColumn.type =
+                    dbColumn["DATA_TYPE"].toLowerCase();
+                // check only columns that have length property
+                if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1 &&
+                    dbColumn["CHARACTER_MAXIMUM_LENGTH"]) {
+                    const length = dbColumn["CHARACTER_MAXIMUM_LENGTH"].toString();
+                    if (length === "-1") {
+                        tableColumn.length = "MAX";
+                    }
+                    else {
+                        tableColumn.length =
+                            !this.isDefaultColumnLength(table, tableColumn, length)
+                                ? length
+                                : "";
+                    }
+                }
+                if (tableColumn.type === "decimal" ||
+                    tableColumn.type === "numeric") {
+                    if (dbColumn["NUMERIC_PRECISION"] !== null &&
+                        !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["NUMERIC_PRECISION"]))
+                        tableColumn.precision =
+                            dbColumn["NUMERIC_PRECISION"];
+                    if (dbColumn["NUMERIC_SCALE"] !== null &&
+                        !this.isDefaultColumnScale(table, tableColumn, dbColumn["NUMERIC_SCALE"]))
+                        tableColumn.scale =
+                            dbColumn["NUMERIC_SCALE"];
+                }
+                if (tableColumn.type === "nvarchar") {
+                    // Check if this is an enum
+                    const columnCheckConstraints = columnConstraints.filter((constraint) => constraint["CONSTRAINT_TYPE"] ===
+                        "CHECK");
+                    if (columnCheckConstraints.length) {
+                        // const isEnumRegexp = new RegExp("^\\(\\[" + tableColumn.name + "\\]='[^']+'(?: OR \\[" + tableColumn.name + "\\]='[^']+')*\\)$");
+                        for (const checkConstraint of columnCheckConstraints) {
+                            if (this.isEnumCheckConstraint(checkConstraint["CONSTRAINT_NAME"])) {
+                                // This is an enum constraint, make column into an enum
+                                tableColumn.enum = [];
+                                const enumValueRegexp = new RegExp("\\[" +
+                                    tableColumn.name +
+                                    "\\]='([^']+)'", "g");
+                                let result;
+                                while ((result = enumValueRegexp.exec(checkConstraint["definition"])) !== null) {
+                                    tableColumn.enum.unshift(result[1]);
+                                }
+                                // Skip other column constraints
+                                break;
+                            }
+                        }
+                    }
+                }
+                const primaryConstraint = columnConstraints.find((constraint) => constraint["CONSTRAINT_TYPE"] ===
+                    "PRIMARY KEY");
+                if (primaryConstraint) {
+                    tableColumn.isPrimary = true;
+                    // find another columns involved in primary key constraint
+                    const anotherPrimaryConstraints = dbConstraints.filter((constraint) => constraint["TABLE_NAME"] ===
+                        dbColumn["TABLE_NAME"] &&
+                        constraint["TABLE_SCHEMA"] ===
+                            dbColumn["TABLE_SCHEMA"] &&
+                        constraint["TABLE_CATALOG"] ===
+                            dbColumn["TABLE_CATALOG"] &&
+                        constraint["COLUMN_NAME"] !==
+                            dbColumn["COLUMN_NAME"] &&
+                        constraint["CONSTRAINT_TYPE"] ===
+                            "PRIMARY KEY");
+                    // collect all column names
+                    const columnNames = anotherPrimaryConstraints.map((constraint) => constraint["COLUMN_NAME"]);
+                    columnNames.push(dbColumn["COLUMN_NAME"]);
+                    // build default primary key constraint name
+                    const pkName = this.connection.namingStrategy.primaryKeyName(table, columnNames);
+                    // if primary key has user-defined constraint name, write it in table column
+                    if (primaryConstraint["CONSTRAINT_NAME"] !==
+                        pkName) {
+                        tableColumn.primaryKeyConstraintName =
+                            primaryConstraint["CONSTRAINT_NAME"];
+                    }
+                }
+                tableColumn.default =
+                    dbColumn["COLUMN_DEFAULT"] !== null &&
+                        dbColumn["COLUMN_DEFAULT"] !== undefined
+                        ? this.removeParenthesisFromDefault(dbColumn["COLUMN_DEFAULT"])
+                        : undefined;
+                tableColumn.isNullable =
+                    dbColumn["IS_NULLABLE"] === "YES";
+                tableColumn.isUnique =
+                    uniqueConstraints.length > 0 &&
+                        !isConstraintComposite;
+                tableColumn.isGenerated = isGenerated;
+                if (isGenerated)
+                    tableColumn.generationStrategy = "increment";
+                if (tableColumn.default === "newsequentialid()") {
+                    tableColumn.isGenerated = true;
+                    tableColumn.generationStrategy = "uuid";
+                    tableColumn.default = undefined;
+                }
+                // todo: unable to get default charset
+                // tableColumn.charset = dbColumn["CHARACTER_SET_NAME"];
+                if (dbColumn["COLLATION_NAME"])
+                    tableColumn.collation =
+                        dbColumn["COLLATION_NAME"] ===
+                            defaultCollation["COLLATION_NAME"]
+                            ? undefined
+                            : dbColumn["COLLATION_NAME"];
+                if (tableColumn.type === "datetime2" ||
+                    tableColumn.type === "time" ||
+                    tableColumn.type === "datetimeoffset") {
+                    tableColumn.precision =
+                        !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["DATETIME_PRECISION"])
+                            ? dbColumn["DATETIME_PRECISION"]
+                            : undefined;
+                }
+                if (dbColumn["is_persisted"] !== null &&
+                    dbColumn["is_persisted"] !== undefined &&
+                    dbColumn["definition"]) {
+                    tableColumn.generatedType =
+                        dbColumn["is_persisted"] === true
+                            ? "STORED"
+                            : "VIRTUAL";
+                    // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.
+                    const asExpressionQuery = this.selectTypeormMetadataSql({
+                        database: dbTable["TABLE_CATALOG"],
+                        schema: dbTable["TABLE_SCHEMA"],
+                        table: dbTable["TABLE_NAME"],
+                        type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
+                        name: tableColumn.name,
+                    });
+                    const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
+                    if (results[0] && results[0].value) {
+                        tableColumn.asExpression = results[0].value;
+                    }
+                    else {
+                        tableColumn.asExpression = "";
+                    }
+                }
+                return tableColumn;
+            }));
+            // find unique constraints of table, group them by constraint name and build TableUnique.
+            const tableUniqueConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => dbConstraint["TABLE_NAME"] ===
+                dbTable["TABLE_NAME"] &&
+                dbConstraint["TABLE_SCHEMA"] ===
+                    dbTable["TABLE_SCHEMA"] &&
+                dbConstraint["TABLE_CATALOG"] ===
+                    dbTable["TABLE_CATALOG"] &&
+                dbConstraint["CONSTRAINT_TYPE"] === "UNIQUE"), (dbConstraint) => dbConstraint["CONSTRAINT_NAME"]);
+            table.uniques = tableUniqueConstraints.map((constraint) => {
+                const uniques = dbConstraints.filter((dbC) => dbC["CONSTRAINT_NAME"] ===
+                    constraint["CONSTRAINT_NAME"]);
+                return new TableUnique_1.TableUnique({
+                    name: constraint["CONSTRAINT_NAME"],
+                    columnNames: uniques.map((u) => u["COLUMN_NAME"]),
+                });
+            });
+            // find check constraints of table, group them by constraint name and build TableCheck.
+            const tableCheckConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint) => dbConstraint["TABLE_NAME"] ===
+                dbTable["TABLE_NAME"] &&
+                dbConstraint["TABLE_SCHEMA"] ===
+                    dbTable["TABLE_SCHEMA"] &&
+                dbConstraint["TABLE_CATALOG"] ===
+                    dbTable["TABLE_CATALOG"] &&
+                dbConstraint["CONSTRAINT_TYPE"] === "CHECK"), (dbConstraint) => dbConstraint["CONSTRAINT_NAME"]);
+            table.checks = tableCheckConstraints
+                .filter((constraint) => !this.isEnumCheckConstraint(constraint["CONSTRAINT_NAME"]))
+                .map((constraint) => {
+                const checks = dbConstraints.filter((dbC) => dbC["CONSTRAINT_NAME"] ===
+                    constraint["CONSTRAINT_NAME"]);
+                return new TableCheck_1.TableCheck({
+                    name: constraint["CONSTRAINT_NAME"],
+                    columnNames: checks.map((c) => c["COLUMN_NAME"]),
+                    expression: constraint["definition"],
+                });
+            });
+            // find foreign key constraints of table, group them by constraint name and build TableForeignKey.
+            const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey) => dbForeignKey["TABLE_NAME"] ===
+                dbTable["TABLE_NAME"] &&
+                dbForeignKey["TABLE_SCHEMA"] ===
+                    dbTable["TABLE_SCHEMA"] &&
+                dbForeignKey["TABLE_CATALOG"] ===
+                    dbTable["TABLE_CATALOG"]), (dbForeignKey) => dbForeignKey["FK_NAME"]);
+            table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey) => {
+                const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk["FK_NAME"] === dbForeignKey["FK_NAME"]);
+                // if referenced table located in currently used db and schema, we don't need to concat db and schema names to table name.
+                const db = dbForeignKey["TABLE_CATALOG"] === currentDatabase
+                    ? undefined
+                    : dbForeignKey["TABLE_CATALOG"];
+                const schema = getSchemaFromKey(dbForeignKey, "REF_SCHEMA");
+                const referencedTableName = this.driver.buildTableName(dbForeignKey["REF_TABLE"], schema, db);
+                return new TableForeignKey_1.TableForeignKey({
+                    name: dbForeignKey["FK_NAME"],
+                    columnNames: foreignKeys.map((dbFk) => dbFk["COLUMN_NAME"]),
+                    referencedDatabase: dbForeignKey["TABLE_CATALOG"],
+                    referencedSchema: dbForeignKey["REF_SCHEMA"],
+                    referencedTableName: referencedTableName,
+                    referencedColumnNames: foreignKeys.map((dbFk) => dbFk["REF_COLUMN"]),
+                    onDelete: dbForeignKey["ON_DELETE"].replace("_", " "), // SqlServer returns NO_ACTION, instead of NO ACTION
+                    onUpdate: dbForeignKey["ON_UPDATE"].replace("_", " "), // SqlServer returns NO_ACTION, instead of NO ACTION
+                });
+            });
+            // find index constraints of table, group them by constraint name and build TableIndex.
+            const tableIndexConstraints = OrmUtils_1.OrmUtils.uniq(dbIndices.filter((dbIndex) => dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] &&
+                dbIndex["TABLE_SCHEMA"] ===
+                    dbTable["TABLE_SCHEMA"] &&
+                dbIndex["TABLE_CATALOG"] ===
+                    dbTable["TABLE_CATALOG"]), (dbIndex) => dbIndex["INDEX_NAME"]);
+            table.indices = tableIndexConstraints.map((constraint) => {
+                const indices = dbIndices.filter((index) => {
+                    return (index["TABLE_CATALOG"] ===
+                        constraint["TABLE_CATALOG"] &&
+                        index["TABLE_SCHEMA"] ===
+                            constraint["TABLE_SCHEMA"] &&
+                        index["TABLE_NAME"] === constraint["TABLE_NAME"] &&
+                        index["INDEX_NAME"] === constraint["INDEX_NAME"]);
+                });
+                return new TableIndex_1.TableIndex({
+                    table: table,
+                    name: constraint["INDEX_NAME"],
+                    columnNames: indices.map((i) => i["COLUMN_NAME"]),
+                    isUnique: constraint["IS_UNIQUE"],
+                    where: constraint["CONDITION"],
+                });
+            });
+            return table;
+        }));
+    }
+    /**
+     * Builds and returns SQL for create table.
+     */
+    createTableSql(table, createForeignKeys) {
+        const columnDefinitions = table.columns
+            .map((column) => this.buildCreateColumnSql(table, column, false, true))
+            .join(", ");
+        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
+        table.columns
+            .filter((column) => column.isUnique)
+            .forEach((column) => {
+            const isUniqueExist = table.uniques.some((unique) => unique.columnNames.length === 1 &&
+                unique.columnNames[0] === column.name);
+            if (!isUniqueExist)
+                table.uniques.push(new TableUnique_1.TableUnique({
+                    name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),
+                    columnNames: [column.name],
+                }));
+        });
+        if (table.uniques.length > 0) {
+            const uniquesSql = table.uniques
+                .map((unique) => {
+                const uniqueName = unique.name
+                    ? unique.name
+                    : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);
+                const columnNames = unique.columnNames
+                    .map((columnName) => `"${columnName}"`)
+                    .join(", ");
+                return `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`;
+            })
+                .join(", ");
+            sql += `, ${uniquesSql}`;
+        }
+        if (table.checks.length > 0) {
+            const checksSql = table.checks
+                .map((check) => {
+                const checkName = check.name
+                    ? check.name
+                    : this.connection.namingStrategy.checkConstraintName(table, check.expression);
+                return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
+            })
+                .join(", ");
+            sql += `, ${checksSql}`;
+        }
+        if (table.foreignKeys.length > 0 && createForeignKeys) {
+            const foreignKeysSql = table.foreignKeys
+                .map((fk) => {
+                const columnNames = fk.columnNames
+                    .map((columnName) => `"${columnName}"`)
+                    .join(", ");
+                if (!fk.name)
+                    fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
+                const referencedColumnNames = fk.referencedColumnNames
+                    .map((columnName) => `"${columnName}"`)
+                    .join(", ");
+                let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
+                if (fk.onDelete)
+                    constraint += ` ON DELETE ${fk.onDelete}`;
+                if (fk.onUpdate)
+                    constraint += ` ON UPDATE ${fk.onUpdate}`;
+                return constraint;
+            })
+                .join(", ");
+            sql += `, ${foreignKeysSql}`;
+        }
+        const primaryColumns = table.columns.filter((column) => column.isPrimary);
+        if (primaryColumns.length > 0) {
+            const primaryKeyName = primaryColumns[0].primaryKeyConstraintName
+                ? primaryColumns[0].primaryKeyConstraintName
+                : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map((column) => column.name));
+            const columnNames = primaryColumns
+                .map((column) => `"${column.name}"`)
+                .join(", ");
+            sql += `, CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNames})`;
+        }
+        sql += `)`;
+        return new Query_1.Query(sql);
+    }
+    /**
+     * Builds drop table sql.
+     */
+    dropTableSql(tableOrName, ifExist) {
+        const query = ifExist
+            ? `DROP TABLE IF EXISTS ${this.escapePath(tableOrName)}`
+            : `DROP TABLE ${this.escapePath(tableOrName)}`;
+        return new Query_1.Query(query);
+    }
+    createViewSql(view) {
+        const parsedName = this.driver.parseTableName(view);
+        // Can't use `escapePath` here because `CREATE VIEW` does not accept database names.
+        const viewIdentifier = parsedName.schema
+            ? `"${parsedName.schema}"."${parsedName.tableName}"`
+            : `"${parsedName.tableName}"`;
+        if (typeof view.expression === "string") {
+            return new Query_1.Query(`CREATE VIEW ${viewIdentifier} AS ${view.expression}`);
+        }
+        else {
+            return new Query_1.Query(`CREATE VIEW ${viewIdentifier} AS ${view
+                .expression(this.connection)
+                .getQuery()}`);
+        }
+    }
+    async insertViewDefinitionSql(view) {
+        const parsedTableName = this.driver.parseTableName(view);
+        if (!parsedTableName.schema) {
+            parsedTableName.schema = await this.getCurrentSchema();
+        }
+        const expression = typeof view.expression === "string"
+            ? view.expression.trim()
+            : view.expression(this.connection).getQuery();
+        return this.insertTypeormMetadataSql({
+            type: MetadataTableType_1.MetadataTableType.VIEW,
+            database: parsedTableName.database,
+            schema: parsedTableName.schema,
+            name: parsedTableName.tableName,
+            value: expression,
+        });
+    }
+    /**
+     * Builds drop view sql.
+     */
+    dropViewSql(viewOrPath) {
+        return new Query_1.Query(`DROP VIEW ${this.escapePath(viewOrPath)}`);
+    }
+    /**
+     * Builds remove view sql.
+     */
+    async deleteViewDefinitionSql(viewOrPath) {
+        const parsedTableName = this.driver.parseTableName(viewOrPath);
+        if (!parsedTableName.schema) {
+            parsedTableName.schema = await this.getCurrentSchema();
+        }
+        return this.deleteTypeormMetadataSql({
+            type: MetadataTableType_1.MetadataTableType.VIEW,
+            database: parsedTableName.database,
+            schema: parsedTableName.schema,
+            name: parsedTableName.tableName,
+        });
+    }
+    /**
+     * Builds create index sql.
+     */
+    createIndexSql(table, index) {
+        const columns = index.columnNames
+            .map((columnName) => `"${columnName}"`)
+            .join(", ");
+        return new Query_1.Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX "${index.name}" ON ${this.escapePath(table)} (${columns}) ${index.where ? "WHERE " + index.where : ""}`);
+    }
+    /**
+     * Builds drop index sql.
+     */
+    dropIndexSql(table, indexOrName) {
+        let indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName)
+            ? indexOrName.name
+            : indexOrName;
+        return new Query_1.Query(`DROP INDEX "${indexName}" ON ${this.escapePath(table)}`);
+    }
+    /**
+     * Builds create primary key sql.
+     */
+    createPrimaryKeySql(table, columnNames, constraintName) {
+        const primaryKeyName = constraintName
+            ? constraintName
+            : this.connection.namingStrategy.primaryKeyName(table, columnNames);
+        const columnNamesString = columnNames
+            .map((columnName) => `"${columnName}"`)
+            .join(", ");
+        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNamesString})`);
+    }
+    /**
+     * Builds drop primary key sql.
+     */
+    dropPrimaryKeySql(table) {
+        const columnNames = table.primaryColumns.map((column) => column.name);
+        const constraintName = table.primaryColumns[0].primaryKeyConstraintName;
+        const primaryKeyName = constraintName
+            ? constraintName
+            : this.connection.namingStrategy.primaryKeyName(table, columnNames);
+        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${primaryKeyName}"`);
+    }
+    /**
+     * Builds create unique constraint sql.
+     */
+    createUniqueConstraintSql(table, uniqueConstraint) {
+        const columnNames = uniqueConstraint.columnNames
+            .map((column) => `"` + column + `"`)
+            .join(", ");
+        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE (${columnNames})`);
+    }
+    /**
+     * Builds drop unique constraint sql.
+     */
+    dropUniqueConstraintSql(table, uniqueOrName) {
+        const uniqueName = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName)
+            ? uniqueOrName.name
+            : uniqueOrName;
+        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueName}"`);
+    }
+    /**
+     * Builds create check constraint sql.
+     */
+    createCheckConstraintSql(table, checkConstraint) {
+        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`);
+    }
+    /**
+     * Builds drop check constraint sql.
+     */
+    dropCheckConstraintSql(table, checkOrName) {
+        const checkName = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName)
+            ? checkOrName.name
+            : checkOrName;
+        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${checkName}"`);
+    }
+    /**
+     * Builds create foreign key sql.
+     */
+    createForeignKeySql(table, foreignKey) {
+        const columnNames = foreignKey.columnNames
+            .map((column) => `"` + column + `"`)
+            .join(", ");
+        const referencedColumnNames = foreignKey.referencedColumnNames
+            .map((column) => `"` + column + `"`)
+            .join(",");
+        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${foreignKey.name}" FOREIGN KEY (${columnNames}) ` +
+            `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
+        if (foreignKey.onDelete)
+            sql += ` ON DELETE ${foreignKey.onDelete}`;
+        if (foreignKey.onUpdate)
+            sql += ` ON UPDATE ${foreignKey.onUpdate}`;
+        return new Query_1.Query(sql);
+    }
+    /**
+     * Builds drop foreign key sql.
+     */
+    dropForeignKeySql(table, foreignKeyOrName) {
+        const foreignKeyName = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName)
+            ? foreignKeyOrName.name
+            : foreignKeyOrName;
+        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${foreignKeyName}"`);
+    }
+    /**
+     * Escapes given table or View path.
+     */
+    escapePath(target) {
+        const { database, schema, tableName } = this.driver.parseTableName(target);
+        if (database && database !== this.driver.database) {
+            if (schema && schema !== this.driver.searchSchema) {
+                return `"${database}"."${schema}"."${tableName}"`;
+            }
+            return `"${database}".."${tableName}"`;
+        }
+        if (schema && schema !== this.driver.searchSchema) {
+            return `"${schema}"."${tableName}"`;
+        }
+        return `"${tableName}"`;
+    }
+    /**
+     * Concat database name and schema name to the foreign key name.
+     * Needs because FK name is relevant to the schema and database.
+     */
+    buildForeignKeyName(fkName, schemaName, dbName) {
+        let joinedFkName = fkName;
+        if (schemaName && schemaName !== this.driver.searchSchema)
+            joinedFkName = schemaName + "." + joinedFkName;
+        if (dbName && dbName !== this.driver.database)
+            joinedFkName = dbName + "." + joinedFkName;
+        return joinedFkName;
+    }
+    /**
+     * Removes parenthesis around default value.
+     * Sql server returns default value with parenthesis around, e.g.
+     *  ('My text') - for string
+     *  ((1)) - for number
+     *  (newsequentialId()) - for function
+     */
+    removeParenthesisFromDefault(defaultValue) {
+        if (defaultValue.substr(0, 1) !== "(")
+            return defaultValue;
+        const normalizedDefault = defaultValue.substr(1, defaultValue.lastIndexOf(")") - 1);
+        return this.removeParenthesisFromDefault(normalizedDefault);
+    }
+    /**
+     * Builds a query for create column.
+     */
+    buildCreateColumnSql(table, column, skipIdentity, createDefault, skipEnum) {
+        let c = `"${column.name}" ${this.connection.driver.createFullType(column)}`;
+        if (!skipEnum && column.enum) {
+            const expression = this.getEnumExpression(column);
+            const checkName = this.connection.namingStrategy.checkConstraintName(table, expression, true);
+            c += ` CONSTRAINT ${checkName} CHECK(${expression})`;
+        }
+        if (column.collation)
+            c += " COLLATE " + column.collation;
+        if (column.asExpression) {
+            c += ` AS (${column.asExpression})`;
+            if (column.generatedType === "STORED") {
+                c += ` PERSISTED`;
+                // NOT NULL can be specified for computed columns only if PERSISTED is also specified
+                if (column.isNullable !== true)
+                    c += " NOT NULL";
+            }
+        }
+        else {
+            if (column.isNullable !== true)
+                c += " NOT NULL";
+        }
+        if (column.isGenerated === true &&
+            column.generationStrategy === "increment" &&
+            !skipIdentity)
+            // don't use skipPrimary here since updates can update already exist primary without auto inc.
+            c += " IDENTITY(1,1)";
+        if (column.default !== undefined &&
+            column.default !== null &&
+            createDefault) {
+            // we create named constraint to be able to delete this constraint when column been dropped
+            const defaultName = this.connection.namingStrategy.defaultConstraintName(table, column.name);
+            c += ` CONSTRAINT "${defaultName}" DEFAULT ${column.default}`;
+        }
+        if (column.isGenerated &&
+            column.generationStrategy === "uuid" &&
+            !column.default) {
+            // we create named constraint to be able to delete this constraint when column been dropped
+            const defaultName = this.connection.namingStrategy.defaultConstraintName(table, column.name);
+            c += ` CONSTRAINT "${defaultName}" DEFAULT NEWSEQUENTIALID()`;
+        }
+        return c;
+    }
+    getEnumExpression(column) {
+        if (!column.enum) {
+            throw new Error(`Enum is not defined in column ${column.name}`);
+        }
+        return (column.name +
+            " IN (" +
+            column.enum.map((val) => "'" + val + "'").join(",") +
+            ")");
+    }
+    isEnumCheckConstraint(name) {
+        return name.indexOf("CHK_") !== -1 && name.indexOf("_ENUM") !== -1;
+    }
+    /**
+     * Converts MssqlParameter into real mssql parameter type.
+     */
+    mssqlParameterToNativeParameter(parameter) {
+        switch (this.driver.normalizeType({ type: parameter.type })) {
+            case "bit":
+                return this.driver.mssql.Bit;
+            case "bigint":
+                return this.driver.mssql.BigInt;
+            case "decimal":
+                return this.driver.mssql.Decimal(...parameter.params);
+            case "float":
+                return this.driver.mssql.Float;
+            case "int":
+                return this.driver.mssql.Int;
+            case "money":
+                return this.driver.mssql.Money;
+            case "numeric":
+                return this.driver.mssql.Numeric(...parameter.params);
+            case "smallint":
+                return this.driver.mssql.SmallInt;
+            case "smallmoney":
+                return this.driver.mssql.SmallMoney;
+            case "real":
+                return this.driver.mssql.Real;
+            case "tinyint":
+                return this.driver.mssql.TinyInt;
+            case "char":
+                if (this.driver.options.options
+                    ?.disableAsciiToUnicodeParamConversion) {
+                    return this.driver.mssql.Char(...parameter.params);
+                }
+                return this.driver.mssql.NChar(...parameter.params);
+            case "nchar":
+                return this.driver.mssql.NChar(...parameter.params);
+            case "text":
+                if (this.driver.options.options
+                    ?.disableAsciiToUnicodeParamConversion) {
+                    return this.driver.mssql.Text;
+                }
+                return this.driver.mssql.Ntext;
+            case "ntext":
+                return this.driver.mssql.Ntext;
+            case "varchar":
+                if (this.driver.options.options
+                    ?.disableAsciiToUnicodeParamConversion) {
+                    return this.driver.mssql.VarChar(...parameter.params);
+                }
+                return this.driver.mssql.NVarChar(...parameter.params);
+            case "nvarchar":
+                return this.driver.mssql.NVarChar(...parameter.params);
+            case "xml":
+                return this.driver.mssql.Xml;
+            case "time":
+                return this.driver.mssql.Time(...parameter.params);
+            case "date":
+                return this.driver.mssql.Date;
+            case "datetime":
+                return this.driver.mssql.DateTime;
+            case "datetime2":
+                return this.driver.mssql.DateTime2(...parameter.params);
+            case "datetimeoffset":
+                return this.driver.mssql.DateTimeOffset(...parameter.params);
+            case "smalldatetime":
+                return this.driver.mssql.SmallDateTime;
+            case "uniqueidentifier":
+                return this.driver.mssql.UniqueIdentifier;
+            case "variant":
+                return this.driver.mssql.Variant;
+            case "binary":
+                return this.driver.mssql.Binary;
+            case "varbinary":
+                return this.driver.mssql.VarBinary(...parameter.params);
+            case "image":
+                return this.driver.mssql.Image;
+            case "udt":
+                return this.driver.mssql.UDT;
+            case "rowversion":
+                return this.driver.mssql.RowVersion;
+        }
+    }
+    /**
+     * Converts string literal of isolation level to enum.
+     * The underlying mssql driver requires an enum for the isolation level.
+     */
+    convertIsolationLevel(isolation) {
+        const ISOLATION_LEVEL = this.driver.mssql.ISOLATION_LEVEL;
+        switch (isolation) {
+            case "READ UNCOMMITTED":
+                return ISOLATION_LEVEL.READ_UNCOMMITTED;
+            case "REPEATABLE READ":
+                return ISOLATION_LEVEL.REPEATABLE_READ;
+            case "SERIALIZABLE":
+                return ISOLATION_LEVEL.SERIALIZABLE;
+            case "READ COMMITTED":
+            default:
+                return ISOLATION_LEVEL.READ_COMMITTED;
+        }
+    }
+    /**
+     * Change table comment.
+     */
+    changeTableComment(tableOrName, comment) {
+        throw new error_1.TypeORMError(`sqlserver driver does not support change table comment.`);
+    }
+}
+exports.SqlServerQueryRunner = SqlServerQueryRunner;
+
+//# sourceMappingURL=SqlServerQueryRunner.js.map
diff --git a/driver/sqlserver/SqlServerQueryRunner.js.map b/driver/sqlserver/SqlServerQueryRunner.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..5be8bf15bd172d0fa630151ea80d8c1da37fb00f
--- /dev/null
+++ b/driver/sqlserver/SqlServerQueryRunner.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/SqlServerQueryRunner.ts"],"names":[],"mappings":";;;AACA,gEAA4D;AAC5D,mEAA+D;AAC/D,iGAA6F;AAC7F,uFAAmF;AAGnF,wEAAoE;AAGpE,4DAAwD;AACxD,sEAAkE;AAClE,wEAAoE;AAEpE,gFAA4E;AAC5E,sEAAkE;AAClE,wEAAoE;AACpE,yDAAqD;AACrD,8DAA0D;AAC1D,kDAA8C;AAC9C,oCAAgC;AAKhC,uCAA0C;AAC1C,4DAAwD;AACxD,kEAA8D;AAC9D,gEAA4D;AAC5D,0EAAsE;AAEtE;;GAEG;AACH,MAAa,oBACT,SAAQ,iCAAe;IAkBvB,4EAA4E;IAC5E,cAAc;IACd,4EAA4E;IAE5E,YAAY,MAAuB,EAAE,IAAqB;QACtD,KAAK,EAAE,CAAA;QAXX,4EAA4E;QAC5E,qBAAqB;QACrB,4EAA4E;QAEpE,SAAI,GAAc,IAAI,qBAAS,EAAE,CAAA;QAQrC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAA;QACpB,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,UAAU,CAAA;QACnC,IAAI,CAAC,WAAW,GAAG,IAAI,yBAAW,CAAC,IAAI,CAAC,CAAA;QACxC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;IACpB,CAAC;IAED,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E;;;OAGG;IACH,OAAO;QACH,OAAO,OAAO,CAAC,OAAO,EAAE,CAAA;IAC5B,CAAC;IAED;;;OAGG;IACH,OAAO;QACH,IAAI,CAAC,UAAU,GAAG,IAAI,CAAA;QACtB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAA;IAC5B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,gBAAgB,CAAC,cAA+B;QAClD,IAAI,IAAI,CAAC,UAAU;YAAE,MAAM,IAAI,iEAA+B,EAAE,CAAA;QAEhE,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAA;QAC/B,IAAI,CAAC;YACD,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,wBAAwB,CAAC,CAAA;QAC9D,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACX,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAA;YAChC,MAAM,GAAG,CAAA;QACb,CAAC;QACD,MAAM,IAAI,OAAO,CAAO,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE;YACvC,MAAM,mBAAmB,GAAG,CAAC,GAAQ,EAAE,EAAE;gBACrC,IAAI,GAAG,EAAE,CAAC;oBACN,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAA;oBAChC,OAAO,IAAI,CAAC,GAAG,CAAC,CAAA;gBACpB,CAAC;gBACD,EAAE,EAAE,CAAA;YACR,CAAC,CAAA;YAED,IAAI,IAAI,CAAC,gBAAgB,KAAK,CAAC,EAAE,CAAC;gBAC9B,IAAI,CAAC,gBAAgB,IAAI,CAAC,CAAA;gBAC1B,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO;oBACrC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,qBAAqB,EAAE;oBACrC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,sBAAsB,EAAE,CAAC,CAAA;gBAC3C,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,WAAW,EAAE,CAAA;gBAC5C,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,mBAAmB,CAAC,CAAA;gBACpD,IAAI,cAAc,EAAE,CAAC;oBACjB,IAAI,CAAC,kBAAkB,CAAC,KAAK,CACzB,IAAI,CAAC,qBAAqB,CAAC,cAAc,CAAC,EAC1C,mBAAmB,CACtB,CAAA;oBACD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAC3B,kCAAkC,GAAG,cAAc,CACtD,CAAA;gBACL,CAAC;qBAAM,CAAC;oBACJ,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAA;gBACtD,CAAC;YACL,CAAC;iBAAM,CAAC;gBACJ,IAAI,CAAC,gBAAgB,IAAI,CAAC,CAAA;gBAC1B,MAAM,IAAI,CAAC,KAAK,CACZ,4BAA4B,IAAI,CAAC,gBAAgB,GAAG,CAAC,EAAE,CAC1D,CAAA;gBACD,EAAE,EAAE,CAAA;YACR,CAAC;QACL,CAAC,CAAC,CAAA;QAEF,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,uBAAuB,CAAC,CAAA;IAC7D,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,iBAAiB;QACnB,IAAI,IAAI,CAAC,UAAU;YAAE,MAAM,IAAI,iEAA+B,EAAE,CAAA;QAEhE,IAAI,CAAC,IAAI,CAAC,mBAAmB;YAAE,MAAM,IAAI,uDAA0B,EAAE,CAAA;QAErE,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,yBAAyB,CAAC,CAAA;QAE3D,IAAI,IAAI,CAAC,gBAAgB,KAAK,CAAC,EAAE,CAAC;YAC9B,OAAO,IAAI,OAAO,CAAO,CAAC,EAAE,EAAE,IAAI,EAAE,EAAE;gBAClC,IAAI,CAAC,gBAAgB,IAAI,CAAC,CAAA;gBAC1B,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,KAAK,EAAE,GAAQ,EAAE,EAAE;oBAC9C,IAAI,GAAG;wBAAE,OAAO,IAAI,CAAC,GAAG,CAAC,CAAA;oBACzB,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAA;oBAChC,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAA;oBAE9B,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,wBAAwB,CAAC,CAAA;oBAE1D,EAAE,EAAE,CAAA;oBACJ,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAA;gBAC7C,CAAC,CAAC,CAAA;YACN,CAAC,CAAC,CAAA;QACN,CAAC;QACD,IAAI,CAAC,gBAAgB,IAAI,CAAC,CAAA;IAC9B,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,mBAAmB;QACrB,IAAI,IAAI,CAAC,UAAU;YAAE,MAAM,IAAI,iEAA+B,EAAE,CAAA;QAEhE,IAAI,CAAC,IAAI,CAAC,mBAAmB;YAAE,MAAM,IAAI,uDAA0B,EAAE,CAAA;QAErE,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,2BAA2B,CAAC,CAAA;QAE7D,IAAI,IAAI,CAAC,gBAAgB,GAAG,CAAC,EAAE,CAAC;YAC5B,IAAI,CAAC,gBAAgB,IAAI,CAAC,CAAA;YAC1B,MAAM,IAAI,CAAC,KAAK,CACZ,gCAAgC,IAAI,CAAC,gBAAgB,EAAE,CAC1D,CAAA;QACL,CAAC;aAAM,CAAC;YACJ,OAAO,IAAI,OAAO,CAAO,CAAC,EAAE,EAAE,IAAI,EAAE,EAAE;gBAClC,IAAI,CAAC,gBAAgB,IAAI,CAAC,CAAA;gBAC1B,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAQ,EAAE,EAAE;oBAChD,IAAI,GAAG;wBAAE,OAAO,IAAI,CAAC,GAAG,CAAC,CAAA;oBACzB,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAA;oBAChC,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAA;oBAE9B,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,0BAA0B,CAAC,CAAA;oBAE5D,EAAE,EAAE,CAAA;oBACJ,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAA;gBAC/C,CAAC,CAAC,CAAA;YACN,CAAC,CAAC,CAAA;QACN,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,KAAK,CACP,KAAa,EACb,UAAkB,EAClB,mBAAmB,GAAG,KAAK;QAE3B,IAAI,IAAI,CAAC,UAAU;YAAE,MAAM,IAAI,iEAA+B,EAAE,CAAA;QAEhE,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAA;QAEzC,MAAM,iBAAiB,GAAG,IAAI,qCAAiB,EAAE,CAAA;QAEjD,IAAI,CAAC;YACD,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,UAAU,EAAE,IAAI,CAAC,CAAA;YAC/D,IAAI,CAAC,WAAW,CAAC,yBAAyB,CACtC,iBAAiB,EACjB,KAAK,EACL,UAAU,CACb,CAAA;YAED,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO;gBACrC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,qBAAqB,EAAE;gBACrC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,sBAAsB,EAAE,CAAC,CAAA;YAC3C,MAAM,OAAO,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CACzC,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAC5D,CAAA;YACD,IAAI,UAAU,IAAI,UAAU,CAAC,MAAM,EAAE,CAAC;gBAClC,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,KAAK,EAAE,EAAE;oBACpC,MAAM,aAAa,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAA;oBACtC,IAAI,iCAAe,CAAC,gBAAgB,CAAC,SAAS,CAAC,EAAE,CAAC;wBAC9C,MAAM,cAAc,GAChB,IAAI,CAAC,+BAA+B,CAAC,SAAS,CAAC,CAAA;wBACnD,IAAI,cAAc,EAAE,CAAC;4BACjB,OAAO,CAAC,KAAK,CACT,aAAa,EACb,cAAc,EACd,SAAS,CAAC,KAAK,CAClB,CAAA;wBACL,CAAC;6BAAM,CAAC;4BACJ,OAAO,CAAC,KAAK,CAAC,aAAa,EAAE,SAAS,CAAC,KAAK,CAAC,CAAA;wBACjD,CAAC;oBACL,CAAC;yBAAM,CAAC;wBACJ,OAAO,CAAC,KAAK,CAAC,aAAa,EAAE,SAAS,CAAC,CAAA;oBAC3C,CAAC;gBACL,CAAC,CAAC,CAAA;YACN,CAAC;YACD,MAAM,cAAc,GAAG,CAAC,IAAI,IAAI,EAAE,CAAA;YAElC,MAAM,GAAG,GAAG,MAAM,IAAI,OAAO,CAAM,CAAC,EAAE,EAAE,IAAI,EAAE,EAAE;gBAC5C,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,GAAQ,EAAE,GAAQ,EAAE,EAAE;oBACxC,oDAAoD;oBACpD,MAAM,qBAAqB,GACvB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,qBAAqB,CAAA;oBAC7C,MAAM,YAAY,GAAG,CAAC,IAAI,IAAI,EAAE,CAAA;oBAChC,MAAM,kBAAkB,GAAG,YAAY,GAAG,cAAc,CAAA;oBAExD,IAAI,CAAC,WAAW,CAAC,wBAAwB,CACrC,iBAAiB,EACjB,KAAK,EACL,UAAU,EACV,IAAI,EACJ,kBAAkB,EAClB,GAAG,EACH,SAAS,CACZ,CAAA;oBAED,IACI,qBAAqB;wBACrB,kBAAkB,GAAG,qBAAqB,EAC5C,CAAC;wBACC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,YAAY,CACtC,kBAAkB,EAClB,KAAK,EACL,UAAU,EACV,IAAI,CACP,CAAA;oBACL,CAAC;oBAED,IAAI,GAAG,EAAE,CAAC;wBACN,IAAI,CAAC,IAAI,mCAAgB,CAAC,KAAK,EAAE,UAAU,EAAE,GAAG,CAAC,CAAC,CAAA;oBACtD,CAAC;oBAED,EAAE,CAAC,GAAG,CAAC,CAAA;gBACX,CAAC,CAAC,CAAA;YACN,CAAC,CAAC,CAAA;YAEF,MAAM,MAAM,GAAG,IAAI,yBAAW,EAAE,CAAA;YAEhC,IAAI,GAAG,EAAE,cAAc,CAAC,WAAW,CAAC,EAAE,CAAC;gBACnC,MAAM,CAAC,OAAO,GAAG,GAAG,CAAC,SAAS,CAAA;YAClC,CAAC;YAED,IAAI,GAAG,EAAE,cAAc,CAAC,cAAc,CAAC,EAAE,CAAC;gBACtC,MAAM,CAAC,QAAQ,GAAG,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,CAAA;YACzC,CAAC;YAED,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAA;YACpD,QAAQ,SAAS,EAAE,CAAC;gBAChB,KAAK,QAAQ;oBACT,+DAA+D;oBAC/D,MAAM,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,SAAS,EAAE,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAA;oBACjD,MAAK;gBACT;oBACI,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC,SAAS,CAAA;YAClC,CAAC;YAED,IAAI,mBAAmB,EAAE,CAAC;gBACtB,OAAO,MAAM,CAAA;YACjB,CAAC;iBAAM,CAAC;gBACJ,OAAO,MAAM,CAAC,GAAG,CAAA;YACrB,CAAC;QACL,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACX,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,aAAa,CACvC,GAAG,EACH,KAAK,EACL,UAAU,EACV,IAAI,CACP,CAAA;YACD,IAAI,CAAC,WAAW,CAAC,wBAAwB,CACrC,iBAAiB,EACjB,KAAK,EACL,UAAU,EACV,KAAK,EACL,SAAS,EACT,SAAS,EACT,GAAG,CACN,CAAA;YAED,MAAM,GAAG,CAAA;QACb,CAAC;gBAAS,CAAC;YACP,MAAM,iBAAiB,CAAC,IAAI,EAAE,CAAA;YAE9B,OAAO,EAAE,CAAA;QACb,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,MAAM,CACR,KAAa,EACb,UAAkB,EAClB,KAAgB,EAChB,OAAkB;QAElB,IAAI,IAAI,CAAC,UAAU;YAAE,MAAM,IAAI,iEAA+B,EAAE,CAAA;QAEhE,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAA;QAEzC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,UAAU,EAAE,IAAI,CAAC,CAAA;QAC/D,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO;YACrC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,qBAAqB,EAAE;YACrC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,sBAAsB,EAAE,CAAC,CAAA;QAC3C,MAAM,OAAO,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CACzC,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAC5D,CAAA;QACD,IAAI,UAAU,IAAI,UAAU,CAAC,MAAM,EAAE,CAAC;YAClC,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,KAAK,EAAE,EAAE;gBACpC,MAAM,aAAa,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAA;gBACtC,IAAI,iCAAe,CAAC,gBAAgB,CAAC,SAAS,CAAC,EAAE,CAAC;oBAC9C,OAAO,CAAC,KAAK,CACT,aAAa,EACb,IAAI,CAAC,+BAA+B,CAAC,SAAS,CAAC,EAC/C,SAAS,CAAC,KAAK,CAClB,CAAA;gBACL,CAAC;qBAAM,CAAC;oBACJ,OAAO,CAAC,KAAK,CAAC,aAAa,EAAE,SAAS,CAAC,CAAA;gBAC3C,CAAC;YACL,CAAC,CAAC,CAAA;QACN,CAAC;QAED,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;QAEpB,MAAM,aAAa,GAAG,OAAO,CAAC,gBAAgB,EAAE,CAAA;QAEhD,aAAa,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,GAAQ,EAAE,EAAE;YACnC,OAAO,EAAE,CAAA;YACT,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,aAAa,CACvC,GAAG,EACH,KAAK,EACL,UAAU,EACV,IAAI,CACP,CAAA;QACL,CAAC,CAAC,CAAA;QAEF,aAAa,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;YACzB,OAAO,EAAE,CAAA;QACb,CAAC,CAAC,CAAA;QAEF,IAAI,KAAK,EAAE,CAAC;YACR,aAAa,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;QAClC,CAAC;QAED,IAAI,OAAO,EAAE,CAAC;YACV,aAAa,CAAC,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAA;QACtC,CAAC;QAED,OAAO,aAAa,CAAA;IACxB,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,YAAY;QACd,MAAM,OAAO,GAAoB,MAAM,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAA;QACtE,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC,CAAA;IAC3D,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,UAAU,CAAC,QAAiB;QAC9B,MAAM,KAAK,GAAG,QAAQ;YAClB,CAAC,CAAC,kBAAkB,QAAQ,kBAAkB;YAC9C,CAAC,CAAC,+BAA+B,CAAA;QACrC,MAAM,OAAO,GAAoB,MAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;QACxD,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAA;IAClD,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,WAAW,CAAC,QAAgB;QAC9B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,KAAK,CAC3B,iBAAiB,QAAQ,eAAe,CAC3C,CAAA;QACD,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAA;QAC/B,OAAO,CAAC,CAAC,IAAI,CAAA;IACjB,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,kBAAkB;QACpB,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,+BAA+B,CAAC,CAAA;QACxE,OAAO,cAAc,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAA;IACvC,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,SAAS,CAAC,MAAc;QAC1B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,KAAK,CAC3B,qBAAqB,MAAM,mBAAmB,CACjD,CAAA;QACD,MAAM,QAAQ,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAA;QACvC,OAAO,CAAC,CAAC,QAAQ,CAAA;IACrB,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,gBAAgB;QAClB,MAAM,kBAAkB,GAAG,MAAM,IAAI,CAAC,KAAK,CACvC,uCAAuC,CAC1C,CAAA;QACD,OAAO,kBAAkB,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,CAAA;IAC/C,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,QAAQ,CAAC,WAA2B;QACtC,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAE/D,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,CAAC;YAC5B,eAAe,CAAC,QAAQ,GAAG,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAA;QAC9D,CAAC;QAED,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;YAC1B,eAAe,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAA;QAC1D,CAAC;QAED,MAAM,GAAG,GAAG,kBAAkB,eAAe,CAAC,QAAQ,yDAAyD,eAAe,CAAC,SAAS,2BAA2B,eAAe,CAAC,MAAM,GAAG,CAAA;QAC5L,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;QACpC,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAA;IACvC,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,SAAS,CACX,WAA2B,EAC3B,UAAkB;QAElB,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAE/D,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,CAAC;YAC5B,eAAe,CAAC,QAAQ,GAAG,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAA;QAC9D,CAAC;QAED,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;YAC1B,eAAe,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAA;QAC1D,CAAC;QAED,MAAM,GAAG,GAAG,kBAAkB,eAAe,CAAC,QAAQ,0DAA0D,eAAe,CAAC,SAAS,2BAA2B,eAAe,CAAC,MAAM,0BAA0B,UAAU,GAAG,CAAA;QACjO,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;QACpC,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAA;IACvC,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,cAAc,CAChB,QAAgB,EAChB,UAAoB;QAEpB,MAAM,EAAE,GAAG,UAAU;YACjB,CAAC,CAAC,aAAa,QAAQ,+BAA+B,QAAQ,GAAG;YACjE,CAAC,CAAC,oBAAoB,QAAQ,GAAG,CAAA;QACrC,MAAM,IAAI,GAAG,kBAAkB,QAAQ,GAAG,CAAA;QAC1C,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,aAAK,CAAC,EAAE,CAAC,EAAE,IAAI,aAAK,CAAC,IAAI,CAAC,CAAC,CAAA;IAC7D,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,YAAY,CAAC,QAAgB,EAAE,OAAiB;QAClD,MAAM,EAAE,GAAG,OAAO;YACd,CAAC,CAAC,aAAa,QAAQ,iCAAiC,QAAQ,GAAG;YACnE,CAAC,CAAC,kBAAkB,QAAQ,GAAG,CAAA;QACnC,MAAM,IAAI,GAAG,oBAAoB,QAAQ,GAAG,CAAA;QAC5C,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,aAAK,CAAC,EAAE,CAAC,EAAE,IAAI,aAAK,CAAC,IAAI,CAAC,CAAC,CAAA;IAC7D,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,YAAY,CACd,UAAkB,EAClB,UAAoB;QAEpB,MAAM,SAAS,GAAY,EAAE,CAAA;QAC7B,MAAM,WAAW,GAAY,EAAE,CAAA;QAE/B,IAAI,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;YACjC,MAAM,OAAO,GAAG,UAAU;gBACtB,CAAC,CAAC,iBAAiB,UAAU,0CAA0C,UAAU,SAAS;gBAC1F,CAAC,CAAC,kBAAkB,UAAU,GAAG,CAAA;YACrC,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,OAAO,CAAC,CAAC,CAAA;YAClC,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,gBAAgB,UAAU,GAAG,CAAC,CAAC,CAAA;QAC9D,CAAC;aAAM,CAAC;YACJ,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAA;YACvC,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAA;YACvC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAA;YACjD,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,MAAM,GAAG,CAAC,CAAC,CAAA;YAC5C,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,SAAS,GAAG,CAAC,CAAC,CAAA;YAEjD,MAAM,OAAO,GAAG,UAAU;gBACtB,CAAC,CAAC,iBAAiB,MAAM,0CAA0C,MAAM,SAAS;gBAClF,CAAC,CAAC,kBAAkB,MAAM,GAAG,CAAA;YACjC,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,OAAO,CAAC,CAAC,CAAA;YAClC,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,gBAAgB,MAAM,GAAG,CAAC,CAAC,CAAA;YAEtD,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,SAAS,GAAG,CAAC,CAAC,CAAA;YAC/C,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,MAAM,GAAG,CAAC,CAAC,CAAA;QAClD,CAAC;QAED,MAAM,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;IACrD,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,UAAU,CAAC,UAAkB,EAAE,OAAiB;QAClD,MAAM,SAAS,GAAY,EAAE,CAAA;QAC7B,MAAM,WAAW,GAAY,EAAE,CAAA;QAE/B,IAAI,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;YACjC,MAAM,OAAO,GAAG,OAAO;gBACnB,CAAC,CAAC,iBAAiB,UAAU,wCAAwC,UAAU,SAAS;gBACxF,CAAC,CAAC,gBAAgB,UAAU,GAAG,CAAA;YACnC,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,OAAO,CAAC,CAAC,CAAA;YAClC,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,kBAAkB,UAAU,GAAG,CAAC,CAAC,CAAA;QAChE,CAAC;aAAM,CAAC;YACJ,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAA;YACvC,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAA;YACvC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAA;YACjD,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,MAAM,GAAG,CAAC,CAAC,CAAA;YAC5C,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,SAAS,GAAG,CAAC,CAAC,CAAA;YAEjD,MAAM,OAAO,GAAG,OAAO;gBACnB,CAAC,CAAC,iBAAiB,MAAM,wCAAwC,MAAM,SAAS;gBAChF,CAAC,CAAC,gBAAgB,MAAM,GAAG,CAAA;YAC/B,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,OAAO,CAAC,CAAC,CAAA;YAClC,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,kBAAkB,MAAM,GAAG,CAAC,CAAC,CAAA;YAExD,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,SAAS,GAAG,CAAC,CAAC,CAAA;YAC/C,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,MAAM,GAAG,CAAC,CAAC,CAAA;QAClD,CAAC;QAED,MAAM,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;IACrD,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,WAAW,CACb,KAAY,EACZ,aAAsB,KAAK,EAC3B,oBAA6B,IAAI,EACjC,gBAAyB,IAAI;QAE7B,IAAI,UAAU,EAAE,CAAC;YACb,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;YAC/C,IAAI,YAAY;gBAAE,OAAO,OAAO,CAAC,OAAO,EAAE,CAAA;QAC9C,CAAC;QACD,MAAM,SAAS,GAAY,EAAE,CAAA;QAC7B,MAAM,WAAW,GAAY,EAAE,CAAA;QAE/B,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,iBAAiB,CAAC,CAAC,CAAA;QAC7D,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAA;QAE1C,iFAAiF;QACjF,kIAAkI;QAClI,IAAI,iBAAiB;YACjB,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,EAAE,CACrC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC,CAC9D,CAAA;QAEL,IAAI,aAAa,EAAE,CAAC;YAChB,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;gBAC5B,sFAAsF;gBACtF,IAAI,CAAC,KAAK,CAAC,IAAI;oBACX,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,SAAS,CACjD,KAAK,EACL,KAAK,CAAC,WAAW,EACjB,KAAK,CAAC,KAAK,CACd,CAAA;gBACL,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAA;gBACjD,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAA;YACrD,CAAC,CAAC,CAAA;QACN,CAAC;QAED,6FAA6F;QAC7F,MAAM,gBAAgB,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CACzC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,aAAa,IAAI,MAAM,CAAC,YAAY,CAC1D,CAAA;QAED,KAAK,MAAM,MAAM,IAAI,gBAAgB,EAAE,CAAC;YACpC,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAA;YAEzD,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;gBAC1B,eAAe,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAA;YAC1D,CAAC;YAED,MAAM,WAAW,GAAG,IAAI,CAAC,wBAAwB,CAAC;gBAC9C,QAAQ,EAAE,eAAe,CAAC,QAAQ;gBAClC,MAAM,EAAE,eAAe,CAAC,MAAM;gBAC9B,KAAK,EAAE,eAAe,CAAC,SAAS;gBAChC,IAAI,EAAE,qCAAiB,CAAC,gBAAgB;gBACxC,IAAI,EAAE,MAAM,CAAC,IAAI;gBACjB,KAAK,EAAE,MAAM,CAAC,YAAY;aAC7B,CAAC,CAAA;YAEF,MAAM,WAAW,GAAG,IAAI,CAAC,wBAAwB,CAAC;gBAC9C,QAAQ,EAAE,eAAe,CAAC,QAAQ;gBAClC,MAAM,EAAE,eAAe,CAAC,MAAM;gBAC9B,KAAK,EAAE,eAAe,CAAC,SAAS;gBAChC,IAAI,EAAE,qCAAiB,CAAC,gBAAgB;gBACxC,IAAI,EAAE,MAAM,CAAC,IAAI;aACpB,CAAC,CAAA;YAEF,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;YAC3B,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;QACjC,CAAC;QAED,MAAM,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;IACrD,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,SAAS,CACX,WAA2B,EAC3B,OAAiB,EACjB,kBAA2B,IAAI,EAC/B,cAAuB,IAAI;QAE3B,IAAI,OAAO,EAAE,CAAC;YACV,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAA;YACrD,IAAI,CAAC,YAAY;gBAAE,OAAO,OAAO,CAAC,OAAO,EAAE,CAAA;QAC/C,CAAC;QAED,8FAA8F;QAC9F,MAAM,iBAAiB,GAAY,eAAe,CAAA;QAClD,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,SAAS,GAAY,EAAE,CAAA;QAC7B,MAAM,WAAW,GAAY,EAAE,CAAA;QAE/B,qGAAqG;QACrG,wDAAwD;QAExD,IAAI,WAAW,EAAE,CAAC;YACd,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;gBAC5B,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAA;gBAC/C,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAA;YACvD,CAAC,CAAC,CAAA;QACN,CAAC;QAED,iGAAiG;QACjG,kIAAkI;QAClI,IAAI,eAAe;YACf,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,EAAE,CACrC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC,CAC5D,CAAA;QAEL,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAA;QACxC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,iBAAiB,CAAC,CAAC,CAAA;QAE/D,kGAAkG;QAClG,MAAM,gBAAgB,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CACzC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,aAAa,IAAI,MAAM,CAAC,YAAY,CAC1D,CAAA;QAED,KAAK,MAAM,MAAM,IAAI,gBAAgB,EAAE,CAAC;YACpC,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAA;YAEzD,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;gBAC1B,eAAe,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAA;YAC1D,CAAC;YAED,MAAM,WAAW,GAAG,IAAI,CAAC,wBAAwB,CAAC;gBAC9C,QAAQ,EAAE,eAAe,CAAC,QAAQ;gBAClC,MAAM,EAAE,eAAe,CAAC,MAAM;gBAC9B,KAAK,EAAE,eAAe,CAAC,SAAS;gBAChC,IAAI,EAAE,qCAAiB,CAAC,gBAAgB;gBACxC,IAAI,EAAE,MAAM,CAAC,IAAI;aACpB,CAAC,CAAA;YAEF,MAAM,WAAW,GAAG,IAAI,CAAC,wBAAwB,CAAC;gBAC9C,QAAQ,EAAE,eAAe,CAAC,QAAQ;gBAClC,MAAM,EAAE,eAAe,CAAC,MAAM;gBAC9B,KAAK,EAAE,eAAe,CAAC,SAAS;gBAChC,IAAI,EAAE,qCAAiB,CAAC,gBAAgB;gBACxC,IAAI,EAAE,MAAM,CAAC,IAAI;gBACjB,KAAK,EAAE,MAAM,CAAC,YAAY;aAC7B,CAAC,CAAA;YAEF,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;YAC3B,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;QACjC,CAAC;QAED,MAAM,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;IACrD,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,UAAU,CACZ,IAAU,EACV,mBAA4B,KAAK;QAEjC,MAAM,SAAS,GAAY,EAAE,CAAA;QAC7B,MAAM,WAAW,GAAY,EAAE,CAAA;QAC/B,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAA;QACxC,IAAI,gBAAgB;YAChB,SAAS,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAA;QAC5D,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAA;QACxC,IAAI,gBAAgB;YAChB,WAAW,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAA;QAC9D,MAAM,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;IACrD,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,QAAQ,CAAC,MAAqB;QAChC,MAAM,QAAQ,GAAG,iCAAe,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAA;QACtE,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAA;QAE/C,MAAM,SAAS,GAAY,EAAE,CAAA;QAC7B,MAAM,WAAW,GAAY,EAAE,CAAA;QAC/B,SAAS,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAA;QACxD,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAA;QACtC,WAAW,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAA;QAC1D,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAA;QAC1C,MAAM,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;IACrD,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,WAAW,CACb,cAA8B,EAC9B,YAAoB;QAEpB,MAAM,SAAS,GAAY,EAAE,CAAA;QAC7B,MAAM,WAAW,GAAY,EAAE,CAAA;QAC/B,MAAM,QAAQ,GAAG,iCAAe,CAAC,OAAO,CAAC,cAAc,CAAC;YACpD,CAAC,CAAC,cAAc;YAChB,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,CAAA;QAC/C,IAAI,QAAQ,GAAG,QAAQ,CAAC,KAAK,EAAE,CAAA;QAE/B,iEAAiE;QACjE,IAAI,MAAM,GAAuB,SAAS,CAAA;QAC1C,IAAI,UAAU,GAAuB,SAAS,CAAA;QAC9C,IAAI,YAAY,GAAW,QAAQ,CAAC,IAAI,CAAA;QACxC,MAAM,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;QAC7C,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC5B,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC,CAAA;YACxB,YAAY,GAAG,YAAY,CAAC,CAAC,CAAC,CAAA;YAC9B,IAAI,YAAY,CAAC,CAAC,CAAC,KAAK,EAAE;gBAAE,UAAU,GAAG,YAAY,CAAC,CAAC,CAAC,CAAA;QAC5D,CAAC;aAAM,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACnC,UAAU,GAAG,YAAY,CAAC,CAAC,CAAC,CAAA;YAC5B,YAAY,GAAG,YAAY,CAAC,CAAC,CAAC,CAAA;QAClC,CAAC;QAED,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CACtC,YAAY,EACZ,UAAU,EACV,MAAM,CACT,CAAA;QAED,2HAA2H;QAC3H,qEAAqE;QACrE,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAA;QACjD,IAAI,MAAM,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;YACjC,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,MAAM,GAAG,CAAC,CAAC,CAAA;YAC5C,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,SAAS,GAAG,CAAC,CAAC,CAAA;QACrD,CAAC;QAED,eAAe;QACf,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,QAAQ,CACX,OAAO,YAAY,GAAG,CAC1B,CACJ,CAAA;QACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,QAAQ,CACX,OAAO,YAAY,GAAG,CAC1B,CACJ,CAAA;QAED,gCAAgC;QAChC,IACI,QAAQ,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC;YAClC,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB,EACtD,CAAC;YACC,MAAM,WAAW,GAAG,QAAQ,CAAC,cAAc,CAAC,GAAG,CAC3C,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAC1B,CAAA;YAED,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CAC3D,QAAQ,EACR,WAAW,CACd,CAAA;YACD,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CAC3D,QAAQ,EACR,WAAW,CACd,CAAA;YAED,4BAA4B;YAC5B,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,QAAQ,CACX,IAAI,SAAS,OAAO,SAAS,GAAG,CACpC,CACJ,CAAA;YACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,QAAQ,CACX,IAAI,SAAS,OAAO,SAAS,GAAG,CACpC,CACJ,CAAA;QACL,CAAC;QAED,4BAA4B;QAC5B,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YAChC,MAAM,aAAa,GACf,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,oBAAoB,CAC/C,QAAQ,EACR,MAAM,CAAC,WAAW,CACrB,CAAA;YAEL,2DAA2D;YAC3D,IAAI,MAAM,CAAC,IAAI,KAAK,aAAa;gBAAE,OAAM;YAEzC,4BAA4B;YAC5B,MAAM,aAAa,GACf,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,oBAAoB,CAC/C,QAAQ,EACR,MAAM,CAAC,WAAW,CACrB,CAAA;YAEL,gBAAgB;YAChB,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,IAC1C,MAAM,CAAC,IACX,OAAO,aAAa,GAAG,CAC1B,CACJ,CAAA;YACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,QAAQ,CACX,IAAI,aAAa,OAAO,MAAM,CAAC,IAAI,GAAG,CAC1C,CACJ,CAAA;YAED,0BAA0B;YAC1B,MAAM,CAAC,IAAI,GAAG,aAAa,CAAA;QAC/B,CAAC,CAAC,CAAA;QAEF,2BAA2B;QAC3B,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;YAC/B,MAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,SAAS,CACzD,QAAQ,EACR,KAAK,CAAC,WAAW,EACjB,KAAK,CAAC,KAAK,CACd,CAAA;YAED,0DAA0D;YAC1D,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY;gBAAE,OAAM;YAEvC,4BAA4B;YAC5B,MAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,SAAS,CACzD,QAAQ,EACR,KAAK,CAAC,WAAW,EACjB,KAAK,CAAC,KAAK,CACd,CAAA;YAED,gBAAgB;YAChB,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,IAC1C,KAAK,CAAC,IACV,OAAO,YAAY,YAAY,CAClC,CACJ,CAAA;YACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,QAAQ,CACX,IAAI,YAAY,OAAO,KAAK,CAAC,IAAI,YAAY,CACjD,CACJ,CAAA;YAED,0BAA0B;YAC1B,KAAK,CAAC,IAAI,GAAG,YAAY,CAAA;QAC7B,CAAC,CAAC,CAAA;QAEF,iCAAiC;QACjC,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,EAAE;YACxC,MAAM,iBAAiB,GACnB,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,QAAQ,EACR,UAAU,CAAC,WAAW,EACtB,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,EAC7B,UAAU,CAAC,qBAAqB,CACnC,CAAA;YAEL,gEAAgE;YAChE,IAAI,UAAU,CAAC,IAAI,KAAK,iBAAiB;gBAAE,OAAM;YAEjD,4BAA4B;YAC5B,MAAM,iBAAiB,GACnB,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,QAAQ,EACR,UAAU,CAAC,WAAW,EACtB,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,EAC7B,UAAU,CAAC,qBAAqB,CACnC,CAAA;YAEL,gBAAgB;YAChB,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,mBAAmB,CACvC,UAAU,CAAC,IAAK,EAChB,UAAU,EACV,MAAM,CACT,OAAO,iBAAiB,GAAG,CAC/B,CACJ,CAAA;YACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,mBAAmB,CACvC,iBAAiB,EACjB,UAAU,EACV,MAAM,CACT,OAAO,UAAU,CAAC,IAAI,GAAG,CAC7B,CACJ,CAAA;YAED,0BAA0B;YAC1B,UAAU,CAAC,IAAI,GAAG,iBAAiB,CAAA;QACvC,CAAC,CAAC,CAAA;QAEF,qDAAqD;QACrD,IAAI,MAAM,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;YACjC,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,SAAS,GAAG,CAAC,CAAC,CAAA;YAC/C,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,MAAM,GAAG,CAAC,CAAC,CAAA;QAClD,CAAC;QAED,MAAM,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;QAEjD,oDAAoD;QACpD,QAAQ,CAAC,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAA;QAC7B,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAA;IAC/C,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,SAAS,CACX,WAA2B,EAC3B,MAAmB;QAEnB,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,CAAA;QACjC,MAAM,SAAS,GAAY,EAAE,CAAA;QAC7B,MAAM,WAAW,GAAY,EAAE,CAAA;QAE/B,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,QAAQ,IAAI,CAAC,oBAAoB,CAC9B,KAAK,EACL,MAAM,EACN,KAAK,EACL,IAAI,CACP,EAAE,CACN,CACJ,CAAA;QACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,iBACjC,MAAM,CAAC,IACX,GAAG,CACN,CACJ,CAAA;QAED,0CAA0C;QAC1C,IAAI,MAAM,CAAC,SAAS,EAAE,CAAC;YACnB,MAAM,cAAc,GAAG,WAAW,CAAC,cAAc,CAAA;YACjD,wEAAwE;YACxE,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC5B,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;oBACrD,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;oBAC5C,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,cAAc,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAC9C,CAAA;gBAEP,MAAM,WAAW,GAAG,cAAc;qBAC7B,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC;qBACnC,IAAI,CAAC,IAAI,CAAC,CAAA;gBAEf,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,MAAM,GAAG,CAClC,CACJ,CAAA;gBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,MAAM,kBAAkB,WAAW,GAAG,CAC9D,CACJ,CAAA;YACL,CAAC;YAED,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;YAC3B,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;gBACrD,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;gBAC5C,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,cAAc,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAC9C,CAAA;YAEP,MAAM,WAAW,GAAG,cAAc;iBAC7B,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC;iBACnC,IAAI,CAAC,IAAI,CAAC,CAAA;YACf,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,MAAM,kBAAkB,WAAW,GAAG,CAC9D,CACJ,CAAA;YACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,MAAM,GAAG,CAClC,CACJ,CAAA;QACL,CAAC;QAED,sBAAsB;QACtB,MAAM,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CACxC,CAAC,KAAK,EAAE,EAAE,CACN,KAAK,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC;YAC9B,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,IAAI,CAC3C,CAAA;QACD,IAAI,WAAW,EAAE,CAAC;YACd,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAA;YACvD,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAA;QAC3D,CAAC;QAED,2BAA2B;QAC3B,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;YAClB,MAAM,gBAAgB,GAAG,IAAI,yBAAW,CAAC;gBACrC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,oBAAoB,CACrD,KAAK,EACL,CAAC,MAAM,CAAC,IAAI,CAAC,CAChB;gBACD,WAAW,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC;aAC7B,CAAC,CAAA;YACF,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAA;YAC1C,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,oBACjC,gBAAgB,CAAC,IACrB,cAAc,MAAM,CAAC,IAAI,IAAI,CAChC,CACJ,CAAA;YACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,qBACjC,gBAAgB,CAAC,IACrB,GAAG,CACN,CACJ,CAAA;QACL,CAAC;QAED,4BAA4B;QAC5B,IAAI,MAAM,CAAC,OAAO,KAAK,IAAI,IAAI,MAAM,CAAC,OAAO,KAAK,SAAS,EAAE,CAAC;YAC1D,MAAM,WAAW,GACb,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,qBAAqB,CAChD,KAAK,EACL,MAAM,CAAC,IAAI,CACd,CAAA;YACL,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,WAAW,GAAG,CACvC,CACJ,CAAA;QACL,CAAC;QAED,IAAI,MAAM,CAAC,aAAa,IAAI,MAAM,CAAC,YAAY,EAAE,CAAC;YAC9C,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAA;YAEzD,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;gBAC1B,eAAe,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAA;YAC1D,CAAC;YAED,MAAM,WAAW,GAAG,IAAI,CAAC,wBAAwB,CAAC;gBAC9C,QAAQ,EAAE,eAAe,CAAC,QAAQ;gBAClC,MAAM,EAAE,eAAe,CAAC,MAAM;gBAC9B,KAAK,EAAE,eAAe,CAAC,SAAS;gBAChC,IAAI,EAAE,qCAAiB,CAAC,gBAAgB;gBACxC,IAAI,EAAE,MAAM,CAAC,IAAI;gBACjB,KAAK,EAAE,MAAM,CAAC,YAAY;aAC7B,CAAC,CAAA;YAEF,MAAM,WAAW,GAAG,IAAI,CAAC,wBAAwB,CAAC;gBAC9C,QAAQ,EAAE,eAAe,CAAC,QAAQ;gBAClC,MAAM,EAAE,eAAe,CAAC,MAAM;gBAC9B,KAAK,EAAE,eAAe,CAAC,SAAS;gBAChC,IAAI,EAAE,qCAAiB,CAAC,gBAAgB;gBACxC,IAAI,EAAE,MAAM,CAAC,IAAI;aACpB,CAAC,CAAA;YAEF,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;YAC3B,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;QACjC,CAAC;QAED,MAAM,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;QAEjD,WAAW,CAAC,SAAS,CAAC,MAAM,CAAC,CAAA;QAC7B,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,WAAW,CAAC,CAAA;IAC/C,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,UAAU,CACZ,WAA2B,EAC3B,OAAsB;QAEtB,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;YAC3B,MAAM,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;QAC7C,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,YAAY,CACd,WAA2B,EAC3B,oBAA0C,EAC1C,oBAA0C;QAE1C,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,SAAS,GAAG,iCAAe,CAAC,aAAa,CAAC,oBAAoB,CAAC;YACjE,CAAC,CAAC,oBAAoB;YACtB,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,oBAAoB,CAAC,CAAA;QAChE,IAAI,CAAC,SAAS;YACV,MAAM,IAAI,oBAAY,CAClB,WAAW,oBAAoB,2BAA2B,KAAK,CAAC,IAAI,UAAU,CACjF,CAAA;QAEL,IAAI,SAAS,GAA4B,SAAS,CAAA;QAClD,IAAI,iCAAe,CAAC,aAAa,CAAC,oBAAoB,CAAC,EAAE,CAAC;YACtD,SAAS,GAAG,oBAAoB,CAAA;QACpC,CAAC;aAAM,CAAC;YACJ,SAAS,GAAG,SAAS,CAAC,KAAK,EAAE,CAAA;YAC7B,SAAS,CAAC,IAAI,GAAG,oBAAoB,CAAA;QACzC,CAAC;QAED,MAAM,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,SAAS,EAAE,SAAS,CAAC,CAAA;IACxD,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,YAAY,CACd,WAA2B,EAC3B,oBAA0C,EAC1C,SAAsB;QAEtB,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,IAAI,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,CAAA;QAC/B,MAAM,SAAS,GAAY,EAAE,CAAA;QAC7B,MAAM,WAAW,GAAY,EAAE,CAAA;QAE/B,MAAM,SAAS,GAAG,iCAAe,CAAC,aAAa,CAAC,oBAAoB,CAAC;YACjE,CAAC,CAAC,oBAAoB;YACtB,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CACd,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,oBAAoB,CACnD,CAAA;QACP,IAAI,CAAC,SAAS;YACV,MAAM,IAAI,oBAAY,CAClB,WAAW,oBAAoB,2BAA2B,KAAK,CAAC,IAAI,UAAU,CACjF,CAAA;QAEL,IACI,CAAC,SAAS,CAAC,WAAW,KAAK,SAAS,CAAC,WAAW;YAC5C,SAAS,CAAC,kBAAkB,KAAK,MAAM,CAAC;YAC5C,SAAS,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI;YACjC,SAAS,CAAC,MAAM,KAAK,SAAS,CAAC,MAAM;YACrC,SAAS,CAAC,YAAY,KAAK,SAAS,CAAC,YAAY;YACjD,SAAS,CAAC,aAAa,KAAK,SAAS,CAAC,aAAa,EACrD,CAAC;YACC,yGAAyG;YACzG,kDAAkD;YAClD,MAAM,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,SAAS,CAAC,CAAA;YACvC,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,SAAS,CAAC,CAAA;YAEtC,sBAAsB;YACtB,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,CAAA;QAC/B,CAAC;aAAM,CAAC;YACJ,IAAI,SAAS,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,EAAE,CAAC;gBACpC,iEAAiE;gBACjE,IAAI,MAAM,GAAuB,SAAS,CAAA;gBAC1C,IAAI,UAAU,GAAuB,SAAS,CAAA;gBAC9C,MAAM,YAAY,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;gBAC1C,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBAC5B,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC,CAAA;oBACxB,IAAI,YAAY,CAAC,CAAC,CAAC,KAAK,EAAE;wBAAE,UAAU,GAAG,YAAY,CAAC,CAAC,CAAC,CAAA;gBAC5D,CAAC;qBAAM,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACnC,UAAU,GAAG,YAAY,CAAC,CAAC,CAAC,CAAA;gBAChC,CAAC;gBAED,2HAA2H;gBAC3H,qEAAqE;gBACrE,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAA;gBACjD,IAAI,MAAM,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;oBACjC,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,MAAM,GAAG,CAAC,CAAC,CAAA;oBAC5C,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,SAAS,GAAG,CAAC,CAAC,CAAA;gBACrD,CAAC;gBAED,oBAAoB;gBACpB,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,IACvC,SAAS,CAAC,IACd,OAAO,SAAS,CAAC,IAAI,GAAG,CAC3B,CACJ,CAAA;gBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,IACvC,SAAS,CAAC,IACd,OAAO,SAAS,CAAC,IAAI,GAAG,CAC3B,CACJ,CAAA;gBAED,uCAAuC;gBACvC,IACI,SAAS,CAAC,SAAS,KAAK,IAAI;oBAC5B,CAAC,SAAS,CAAC,wBAAwB,EACrC,CAAC;oBACC,MAAM,cAAc,GAAG,WAAW,CAAC,cAAc,CAAA;oBAEjD,oCAAoC;oBACpC,MAAM,WAAW,GAAG,cAAc,CAAC,GAAG,CAClC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAC1B,CAAA;oBACD,MAAM,SAAS,GACX,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,WAAW,CACd,CAAA;oBAEL,+CAA+C;oBAC/C,WAAW,CAAC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAA;oBAC1D,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA;oBAEhC,oCAAoC;oBACpC,MAAM,SAAS,GACX,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,WAAW,CACd,CAAA;oBAEL,4BAA4B;oBAC5B,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,WAAW,CACd,IAAI,SAAS,OAAO,SAAS,GAAG,CACpC,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,WAAW,CACd,IAAI,SAAS,OAAO,SAAS,GAAG,CACpC,CACJ,CAAA;gBACL,CAAC;gBAED,2BAA2B;gBAC3B,WAAW,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;oBACvD,MAAM,YAAY,GACd,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,SAAS,CACpC,WAAW,EACX,KAAK,CAAC,WAAW,EACjB,KAAK,CAAC,KAAK,CACd,CAAA;oBAEL,0DAA0D;oBAC1D,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY;wBAAE,OAAM;oBAEvC,4BAA4B;oBAC5B,KAAK,CAAC,WAAW,CAAC,MAAM,CACpB,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,EACzC,CAAC,CACJ,CAAA;oBACD,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA;oBACtC,MAAM,YAAY,GACd,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,SAAS,CACpC,WAAW,EACX,KAAK,CAAC,WAAW,EACjB,KAAK,CAAC,KAAK,CACd,CAAA;oBAEL,gBAAgB;oBAChB,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,WAAW,CACd,IAAI,KAAK,CAAC,IAAI,OAAO,YAAY,YAAY,CACjD,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,WAAW,CACd,IAAI,YAAY,OAAO,KAAK,CAAC,IAAI,YAAY,CACjD,CACJ,CAAA;oBAED,0BAA0B;oBAC1B,KAAK,CAAC,IAAI,GAAG,YAAY,CAAA;gBAC7B,CAAC,CAAC,CAAA;gBAEF,iCAAiC;gBACjC,WAAW;qBACN,qBAAqB,CAAC,SAAS,CAAC;qBAChC,OAAO,CAAC,CAAC,UAAU,EAAE,EAAE;oBACpB,MAAM,cAAc,GAChB,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,UAAU,CAAC,WAAW,EACtB,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,EAC7B,UAAU,CAAC,qBAAqB,CACnC,CAAA;oBAEL,gEAAgE;oBAChE,IAAI,UAAU,CAAC,IAAI,KAAK,cAAc;wBAAE,OAAM;oBAE9C,4BAA4B;oBAC5B,UAAU,CAAC,WAAW,CAAC,MAAM,CACzB,UAAU,CAAC,WAAW,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,EAC9C,CAAC,CACJ,CAAA;oBACD,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA;oBAC3C,MAAM,iBAAiB,GACnB,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,UAAU,CAAC,WAAW,EACtB,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,EAC7B,UAAU,CAAC,qBAAqB,CACnC,CAAA;oBAEL,gBAAgB;oBAChB,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,mBAAmB,CACvC,UAAU,CAAC,IAAK,EAChB,UAAU,EACV,MAAM,CACT,OAAO,iBAAiB,GAAG,CAC/B,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,mBAAmB,CACvC,iBAAiB,EACjB,UAAU,EACV,MAAM,CACT,OAAO,UAAU,CAAC,IAAI,GAAG,CAC7B,CACJ,CAAA;oBAED,0BAA0B;oBAC1B,UAAU,CAAC,IAAI,GAAG,iBAAiB,CAAA;gBACvC,CAAC,CAAC,CAAA;gBAEN,2BAA2B;gBAC3B,WAAW,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;oBACtD,4BAA4B;oBAC5B,KAAK,CAAC,WAAY,CAAC,MAAM,CACrB,KAAK,CAAC,WAAY,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,EAC1C,CAAC,CACJ,CAAA;oBACD,KAAK,CAAC,WAAY,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA;oBACvC,MAAM,YAAY,GACd,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,mBAAmB,CAC9C,WAAW,EACX,KAAK,CAAC,UAAW,CACpB,CAAA;oBAEL,gBAAgB;oBAChB,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,WAAW,CACd,IAAI,KAAK,CAAC,IAAI,OAAO,YAAY,GAAG,CACxC,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,WAAW,CACd,IAAI,YAAY,OAAO,KAAK,CAAC,IAAI,GAAG,CACxC,CACJ,CAAA;oBAED,0BAA0B;oBAC1B,KAAK,CAAC,IAAI,GAAG,YAAY,CAAA;gBAC7B,CAAC,CAAC,CAAA;gBAEF,4BAA4B;gBAC5B,WAAW,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;oBACxD,MAAM,aAAa,GACf,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,oBAAoB,CAC/C,WAAW,EACX,MAAM,CAAC,WAAW,CACrB,CAAA;oBAEL,2DAA2D;oBAC3D,IAAI,MAAM,CAAC,IAAI,KAAK,aAAa;wBAAE,OAAM;oBAEzC,4BAA4B;oBAC5B,MAAM,CAAC,WAAW,CAAC,MAAM,CACrB,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,EAC1C,CAAC,CACJ,CAAA;oBACD,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA;oBACvC,MAAM,aAAa,GACf,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,oBAAoB,CAC/C,WAAW,EACX,MAAM,CAAC,WAAW,CACrB,CAAA;oBAEL,gBAAgB;oBAChB,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,WAAW,CACd,IAAI,MAAM,CAAC,IAAI,OAAO,aAAa,GAAG,CAC1C,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,mBAAmB,IAAI,CAAC,YAAY,CAChC,WAAW,CACd,IAAI,aAAa,OAAO,MAAM,CAAC,IAAI,GAAG,CAC1C,CACJ,CAAA;oBAED,0BAA0B;oBAC1B,MAAM,CAAC,IAAI,GAAG,aAAa,CAAA;gBAC/B,CAAC,CAAC,CAAA;gBAEF,6BAA6B;gBAC7B,IACI,SAAS,CAAC,OAAO,KAAK,IAAI;oBAC1B,SAAS,CAAC,OAAO,KAAK,SAAS,EACjC,CAAC;oBACC,MAAM,cAAc,GAChB,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,qBAAqB,CAChD,KAAK,EACL,SAAS,CAAC,IAAI,CACjB,CAAA;oBACL,MAAM,cAAc,GAChB,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,qBAAqB,CAChD,KAAK,EACL,SAAS,CAAC,IAAI,CACjB,CAAA;oBAEL,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,cAAc,GAAG,CAC1C,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,cAAc,aAC/B,SAAS,CAAC,OACd,SAAS,SAAS,CAAC,IAAI,GAAG,CAC7B,CACJ,CAAA;oBAED,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,cAAc,aAC/B,SAAS,CAAC,OACd,SAAS,SAAS,CAAC,IAAI,GAAG,CAC7B,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,cAAc,GAAG,CAC1C,CACJ,CAAA;gBACL,CAAC;gBAED,qDAAqD;gBACrD,IAAI,MAAM,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;oBACjC,SAAS,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,SAAS,GAAG,CAAC,CAAC,CAAA;oBAC/C,WAAW,CAAC,IAAI,CAAC,IAAI,aAAK,CAAC,QAAQ,MAAM,GAAG,CAAC,CAAC,CAAA;gBAClD,CAAC;gBAED,wCAAwC;gBACxC,MAAM,cAAc,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CAC3C,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,CAC7C,CAAA;gBACD,WAAW,CAAC,OAAO,CACf,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,cAAe,CAAC,CAC/C,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,CAAA;gBACvB,SAAS,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,CAAA;YACnC,CAAC;YAED,IACI,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EACjE,CAAC;gBACC,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,iBAAiB,IAAI,CAAC,oBAAoB,CACvC,KAAK,EACL,SAAS,EACT,IAAI,EACJ,KAAK,EACL,IAAI,CACP,EAAE,CACN,CACJ,CAAA;gBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,iBAAiB,IAAI,CAAC,oBAAoB,CACvC,KAAK,EACL,SAAS,EACT,IAAI,EACJ,KAAK,EACL,IAAI,CACP,EAAE,CACN,CACJ,CAAA;YACL,CAAC;YAED,IAAI,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,CAAC;gBAC3C,MAAM,aAAa,GAAG,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAA;gBACvD,MAAM,QAAQ,GAAG,IAAI,uBAAU,CAAC;oBAC5B,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,mBAAmB,CACpD,KAAK,EACL,aAAa,EACb,IAAI,CACP;oBACD,UAAU,EAAE,aAAa;iBAC5B,CAAC,CAAA;gBAEF,MAAM,aAAa,GAAG,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAA;gBACvD,MAAM,QAAQ,GAAG,IAAI,uBAAU,CAAC;oBAC5B,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,mBAAmB,CACpD,KAAK,EACL,aAAa,EACb,IAAI,CACP;oBACD,UAAU,EAAE,aAAa;iBAC5B,CAAC,CAAA;gBAEF,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAA;gBAC5D,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,wBAAwB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAA;gBAE9D,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAA;gBAC9D,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,wBAAwB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAA;YACpE,CAAC;YAED,IAAI,SAAS,CAAC,SAAS,KAAK,SAAS,CAAC,SAAS,EAAE,CAAC;gBAC9C,MAAM,cAAc,GAAG,WAAW,CAAC,cAAc,CAAA;gBAEjD,2EAA2E;gBAC3E,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBAC5B,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;wBACrD,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;wBAC5C,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,cAAc,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAC9C,CAAA;oBAEP,MAAM,WAAW,GAAG,cAAc;yBAC7B,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC;yBACnC,IAAI,CAAC,IAAI,CAAC,CAAA;oBACf,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,MAAM,GAAG,CAClC,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,MAAM,kBAAkB,WAAW,GAAG,CAC9D,CACJ,CAAA;gBACL,CAAC;gBAED,IAAI,SAAS,CAAC,SAAS,KAAK,IAAI,EAAE,CAAC;oBAC/B,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;oBAC9B,yBAAyB;oBACzB,MAAM,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CACnC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,CAC7C,CAAA;oBACD,MAAO,CAAC,SAAS,GAAG,IAAI,CAAA;oBACxB,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;wBACrD,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;wBAC5C,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,cAAc,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAC9C,CAAA;oBAEP,MAAM,WAAW,GAAG,cAAc;yBAC7B,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC;yBACnC,IAAI,CAAC,IAAI,CAAC,CAAA;oBACf,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,MAAM,kBAAkB,WAAW,GAAG,CAC9D,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,MAAM,GAAG,CAClC,CACJ,CAAA;gBACL,CAAC;qBAAM,CAAC;oBACJ,MAAM,aAAa,GAAG,cAAc,CAAC,IAAI,CACrC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,CACnC,CAAA;oBACD,cAAc,CAAC,MAAM,CACjB,cAAc,CAAC,OAAO,CAAC,aAAc,CAAC,EACtC,CAAC,CACJ,CAAA;oBAED,yBAAyB;oBACzB,MAAM,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CACnC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,CAC7C,CAAA;oBACD,MAAO,CAAC,SAAS,GAAG,KAAK,CAAA;oBAEzB,gEAAgE;oBAChE,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;wBAC5B,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC;6BAC3B,wBAAwB;4BACzB,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;4BAC5C,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,cAAc,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAC9C,CAAA;wBAEP,MAAM,WAAW,GAAG,cAAc;6BAC7B,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC;6BACnC,IAAI,CAAC,IAAI,CAAC,CAAA;wBACf,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,MAAM,kBAAkB,WAAW,GAAG,CAC9D,CACJ,CAAA;wBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,MAAM,GAAG,CAClC,CACJ,CAAA;oBACL,CAAC;gBACL,CAAC;YACL,CAAC;YAED,IAAI,SAAS,CAAC,QAAQ,KAAK,SAAS,CAAC,QAAQ,EAAE,CAAC;gBAC5C,IAAI,SAAS,CAAC,QAAQ,KAAK,IAAI,EAAE,CAAC;oBAC9B,MAAM,gBAAgB,GAAG,IAAI,yBAAW,CAAC;wBACrC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,oBAAoB,CACrD,KAAK,EACL,CAAC,SAAS,CAAC,IAAI,CAAC,CACnB;wBACD,WAAW,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC;qBAChC,CAAC,CAAA;oBACF,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAA;oBAC1C,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBACG,gBAAgB,CAAC,IACrB,cAAc,SAAS,CAAC,IAAI,IAAI,CACnC,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,gBAAgB,CAAC,IAAI,GAAG,CACjD,CACJ,CAAA;gBACL,CAAC;qBAAM,CAAC;oBACJ,MAAM,gBAAgB,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CAC7C,CAAC,MAAM,EAAE,EAAE;wBACP,OAAO,CACH,MAAM,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC;4BAC/B,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CACrB,CAAC,UAAU,EAAE,EAAE,CACX,UAAU,KAAK,SAAS,CAAC,IAAI,CACpC,CACJ,CAAA;oBACL,CAAC,CACJ,CAAA;oBACD,WAAW,CAAC,OAAO,CAAC,MAAM,CACtB,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,gBAAiB,CAAC,EAC9C,CAAC,CACJ,CAAA;oBACD,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,gBAAiB,CAAC,IAAI,GAAG,CAClD,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBACG,gBAAiB,CAAC,IACtB,cAAc,SAAS,CAAC,IAAI,IAAI,CACnC,CACJ,CAAA;gBACL,CAAC;YACL,CAAC;YAED,IAAI,SAAS,CAAC,OAAO,KAAK,SAAS,CAAC,OAAO,EAAE,CAAC;gBAC1C,8EAA8E;gBAC9E,IACI,SAAS,CAAC,OAAO,KAAK,IAAI;oBAC1B,SAAS,CAAC,OAAO,KAAK,SAAS,EACjC,CAAC;oBACC,MAAM,WAAW,GACb,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,qBAAqB,CAChD,KAAK,EACL,SAAS,CAAC,IAAI,CACjB,CAAA;oBACL,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,WAAW,GAAG,CACvC,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,WAAW,aAC5B,SAAS,CAAC,OACd,SAAS,SAAS,CAAC,IAAI,GAAG,CAC7B,CACJ,CAAA;gBACL,CAAC;gBAED,IACI,SAAS,CAAC,OAAO,KAAK,IAAI;oBAC1B,SAAS,CAAC,OAAO,KAAK,SAAS,EACjC,CAAC;oBACC,MAAM,WAAW,GACb,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,qBAAqB,CAChD,KAAK,EACL,SAAS,CAAC,IAAI,CACjB,CAAA;oBACL,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,WAAW,aAC5B,SAAS,CAAC,OACd,SAAS,SAAS,CAAC,IAAI,GAAG,CAC7B,CACJ,CAAA;oBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,WAAW,GAAG,CACvC,CACJ,CAAA;gBACL,CAAC;YACL,CAAC;YAED,MAAM,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;YACjD,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,WAAW,CAAC,CAAA;QAC/C,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,aAAa,CACf,WAA2B,EAC3B,cAAoE;QAEpE,KAAK,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,IAAI,cAAc,EAAE,CAAC;YACpD,MAAM,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,SAAS,EAAE,SAAS,CAAC,CAAA;QAC9D,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,UAAU,CACZ,WAA2B,EAC3B,YAAkC;QAElC,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,MAAM,GAAG,iCAAe,CAAC,aAAa,CAAC,YAAY,CAAC;YACtD,CAAC,CAAC,YAAY;YACd,CAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAA;QAC1C,IAAI,CAAC,MAAM;YACP,MAAM,IAAI,oBAAY,CAClB,WAAW,YAAY,6BAA6B,KAAK,CAAC,IAAI,GAAG,CACpE,CAAA;QAEL,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,CAAA;QACjC,MAAM,SAAS,GAAY,EAAE,CAAA;QAC7B,MAAM,WAAW,GAAY,EAAE,CAAA;QAE/B,8BAA8B;QAC9B,IAAI,MAAM,CAAC,SAAS,EAAE,CAAC;YACnB,MAAM,MAAM,GAAG,MAAM,CAAC,wBAAwB;gBAC1C,CAAC,CAAC,MAAM,CAAC,wBAAwB;gBACjC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,WAAW,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAC1D,CAAA;YAEP,MAAM,WAAW,GAAG,WAAW,CAAC,cAAc;iBACzC,GAAG,CAAC,CAAC,aAAa,EAAE,EAAE,CAAC,IAAI,aAAa,CAAC,IAAI,GAAG,CAAC;iBACjD,IAAI,CAAC,IAAI,CAAC,CAAA;YAEf,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,WAAW,CACd,qBAAqB,MAAM,GAAG,CAClC,CACJ,CAAA;YACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,WAAW,CACd,oBAAoB,MAAM,kBAAkB,WAAW,GAAG,CAC9D,CACJ,CAAA;YAED,yBAAyB;YACzB,MAAM,WAAW,GAAG,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;YAC7D,WAAY,CAAC,SAAS,GAAG,KAAK,CAAA;YAE9B,mFAAmF;YACnF,IAAI,WAAW,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACxC,MAAM,MAAM,GAAG,WAAW,CAAC,cAAc,CAAC,CAAC,CAAC;qBACvC,wBAAwB;oBACzB,CAAC,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;oBACxD,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,WAAW,CAAC,cAAc,CAAC,GAAG,CAC1B,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAC1B,CACJ,CAAA;gBAEP,MAAM,WAAW,GAAG,WAAW,CAAC,cAAc;qBACzC,GAAG,CAAC,CAAC,aAAa,EAAE,EAAE,CAAC,IAAI,aAAa,CAAC,IAAI,GAAG,CAAC;qBACjD,IAAI,CAAC,IAAI,CAAC,CAAA;gBACf,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,WAAW,CACd,oBAAoB,MAAM,kBAAkB,WAAW,GAAG,CAC9D,CACJ,CAAA;gBACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,WAAW,CACd,qBAAqB,MAAM,GAAG,CAClC,CACJ,CAAA;YACL,CAAC;QACL,CAAC;QAED,oBAAoB;QACpB,MAAM,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CACxC,CAAC,KAAK,EAAE,EAAE,CACN,KAAK,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC;YAC9B,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,IAAI,CAC3C,CAAA;QACD,IAAI,WAAW,EAAE,CAAC;YACd,WAAW,CAAC,OAAO,CAAC,MAAM,CACtB,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,EACxC,CAAC,CACJ,CAAA;YACD,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAA;YACrD,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAA;QAC7D,CAAC;QAED,oBAAoB;QACpB,MAAM,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,IAAI,CACvC,CAAC,KAAK,EAAE,EAAE,CACN,CAAC,CAAC,KAAK,CAAC,WAAW;YACnB,KAAK,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC;YAC9B,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,IAAI,CAC3C,CAAA;QACD,IAAI,WAAW,EAAE,CAAC;YACd,WAAW,CAAC,MAAM,CAAC,MAAM,CACrB,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,EACvC,CAAC,CACJ,CAAA;YACD,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAA;YAC/D,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,wBAAwB,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAA;QACvE,CAAC;QAED,qBAAqB;QACrB,MAAM,YAAY,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CACzC,CAAC,MAAM,EAAE,EAAE,CACP,MAAM,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC;YAC/B,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,IAAI,CAC5C,CAAA;QACD,IAAI,YAAY,EAAE,CAAC;YACf,WAAW,CAAC,OAAO,CAAC,MAAM,CACtB,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,YAAY,CAAC,EACzC,CAAC,CACJ,CAAA;YACD,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC,CAAA;YACjE,WAAW,CAAC,IAAI,CACZ,IAAI,CAAC,yBAAyB,CAAC,KAAK,EAAE,YAAY,CAAC,CACtD,CAAA;QACL,CAAC;QAED,0BAA0B;QAC1B,IAAI,MAAM,CAAC,OAAO,KAAK,IAAI,IAAI,MAAM,CAAC,OAAO,KAAK,SAAS,EAAE,CAAC;YAC1D,MAAM,WAAW,GACb,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,qBAAqB,CAChD,KAAK,EACL,MAAM,CAAC,IAAI,CACd,CAAA;YACL,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,WAAW,GAAG,CACvC,CACJ,CAAA;YACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,WAAW,aAC5B,MAAM,CAAC,OACX,SAAS,MAAM,CAAC,IAAI,GAAG,CAC1B,CACJ,CAAA;QACL,CAAC;QAED,IAAI,MAAM,CAAC,aAAa,IAAI,MAAM,CAAC,YAAY,EAAE,CAAC;YAC9C,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAA;YAEzD,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;gBAC1B,eAAe,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAA;YAC1D,CAAC;YAED,MAAM,WAAW,GAAG,IAAI,CAAC,wBAAwB,CAAC;gBAC9C,QAAQ,EAAE,eAAe,CAAC,QAAQ;gBAClC,MAAM,EAAE,eAAe,CAAC,MAAM;gBAC9B,KAAK,EAAE,eAAe,CAAC,SAAS;gBAChC,IAAI,EAAE,qCAAiB,CAAC,gBAAgB;gBACxC,IAAI,EAAE,MAAM,CAAC,IAAI;aACpB,CAAC,CAAA;YACF,MAAM,WAAW,GAAG,IAAI,CAAC,wBAAwB,CAAC;gBAC9C,QAAQ,EAAE,eAAe,CAAC,QAAQ;gBAClC,MAAM,EAAE,eAAe,CAAC,MAAM;gBAC9B,KAAK,EAAE,eAAe,CAAC,SAAS;gBAChC,IAAI,EAAE,qCAAiB,CAAC,gBAAgB;gBACxC,IAAI,EAAE,MAAM,CAAC,IAAI;gBACjB,KAAK,EAAE,MAAM,CAAC,YAAY;aAC7B,CAAC,CAAA;YAEF,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;YAC3B,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;QACjC,CAAC;QAED,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,iBACjC,MAAM,CAAC,IACX,GAAG,CACN,CACJ,CAAA;QACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,QAAQ,IAAI,CAAC,oBAAoB,CAC9B,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,CACR,EAAE,CACN,CACJ,CAAA;QAED,MAAM,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;QAEjD,WAAW,CAAC,YAAY,CAAC,MAAM,CAAC,CAAA;QAChC,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,WAAW,CAAC,CAAA;IAC/C,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,WAAW,CACb,WAA2B,EAC3B,OAAiC;QAEjC,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;YAC3B,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;QAC9C,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,gBAAgB,CAClB,WAA2B,EAC3B,WAAqB,EACrB,cAAuB;QAEvB,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,CAAA;QAEjC,MAAM,EAAE,GAAG,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,WAAW,EAAE,cAAc,CAAC,CAAA;QAEvE,4GAA4G;QAC5G,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YACnC,IAAI,WAAW,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,UAAU,KAAK,MAAM,CAAC,IAAI,CAAC;gBAC5D,MAAM,CAAC,SAAS,GAAG,IAAI,CAAA;QAC/B,CAAC,CAAC,CAAA;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAA;QAEhD,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;QACnC,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,WAAW,CAAC,CAAA;IAC/C,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,iBAAiB,CACnB,WAA2B,EAC3B,OAAsB;QAEtB,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,CAAA;QACjC,MAAM,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;QACxD,MAAM,SAAS,GAAY,EAAE,CAAA;QAC7B,MAAM,WAAW,GAAY,EAAE,CAAA;QAE/B,4DAA4D;QAC5D,MAAM,cAAc,GAAG,WAAW,CAAC,cAAc,CAAA;QACjD,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC5B,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;gBACrD,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;gBAC5C,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,cAAc,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAC9C,CAAA;YAEP,MAAM,iBAAiB,GAAG,cAAc;iBACnC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC;iBACnC,IAAI,CAAC,IAAI,CAAC,CAAA;YAEf,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,MAAM,GAAG,CAClC,CACJ,CAAA;YACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,MAAM,kBAAkB,iBAAiB,GAAG,CACpE,CACJ,CAAA;QACL,CAAC;QAED,2BAA2B;QAC3B,WAAW,CAAC,OAAO;aACd,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;aAC3D,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC,CAAC,CAAA;QAEnD,MAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;YACrD,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;YAC5C,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,WAAW,EACX,WAAW,CACd,CAAA;QAEP,MAAM,iBAAiB,GAAG,WAAW;aAChC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,IAAI,UAAU,GAAG,CAAC;aACtC,IAAI,CAAC,IAAI,CAAC,CAAA;QAEf,SAAS,CAAC,IAAI,CACV,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,MAAM,kBAAkB,iBAAiB,GAAG,CACpE,CACJ,CAAA;QACD,WAAW,CAAC,IAAI,CACZ,IAAI,aAAK,CACL,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,MAAM,GAAG,CAClC,CACJ,CAAA;QAED,MAAM,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAA;QACjD,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,WAAW,CAAC,CAAA;IAC/C,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,cAAc,CAChB,WAA2B,EAC3B,cAAuB;QAEvB,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAA;QACxC,MAAM,IAAI,GAAG,IAAI,CAAC,mBAAmB,CACjC,KAAK,EACL,KAAK,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,EACjD,cAAc,CACjB,CAAA;QACD,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;QACnC,KAAK,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YACpC,MAAM,CAAC,SAAS,GAAG,KAAK,CAAA;QAC5B,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,sBAAsB,CACxB,WAA2B,EAC3B,gBAA6B;QAE7B,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAE5C,mGAAmG;QACnG,IAAI,CAAC,gBAAgB,CAAC,IAAI;YACtB,gBAAgB,CAAC,IAAI;gBACjB,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,oBAAoB,CAC/C,KAAK,EACL,gBAAgB,CAAC,WAAW,CAC/B,CAAA;QAET,MAAM,EAAE,GAAG,IAAI,CAAC,yBAAyB,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAA;QAClE,MAAM,IAAI,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAA;QAClE,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;QACnC,KAAK,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,CAAA;IAC/C,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,uBAAuB,CACzB,WAA2B,EAC3B,iBAAgC;QAEhC,MAAM,QAAQ,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAC,gBAAgB,EAAE,EAAE,CACxD,IAAI,CAAC,sBAAsB,CAAC,WAAW,EAAE,gBAAgB,CAAC,CAC7D,CAAA;QACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;IAC/B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,oBAAoB,CACtB,WAA2B,EAC3B,YAAkC;QAElC,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,gBAAgB,GAAG,iCAAe,CAAC,aAAa,CAAC,YAAY,CAAC;YAChE,CAAC,CAAC,YAAY;YACd,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,YAAY,CAAC,CAAA;QACxD,IAAI,CAAC,gBAAgB;YACjB,MAAM,IAAI,oBAAY,CAClB,qDAAqD,KAAK,CAAC,IAAI,EAAE,CACpE,CAAA;QAEL,MAAM,EAAE,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAA;QAChE,MAAM,IAAI,GAAG,IAAI,CAAC,yBAAyB,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAA;QACpE,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;QACnC,KAAK,CAAC,sBAAsB,CAAC,gBAAgB,CAAC,CAAA;IAClD,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,qBAAqB,CACvB,WAA2B,EAC3B,iBAAgC;QAEhC,MAAM,QAAQ,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAC,gBAAgB,EAAE,EAAE,CACxD,IAAI,CAAC,oBAAoB,CAAC,WAAW,EAAE,gBAAgB,CAAC,CAC3D,CAAA;QACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;IAC/B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,qBAAqB,CACvB,WAA2B,EAC3B,eAA2B;QAE3B,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAE5C,mGAAmG;QACnG,IAAI,CAAC,eAAe,CAAC,IAAI;YACrB,eAAe,CAAC,IAAI;gBAChB,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,mBAAmB,CAC9C,KAAK,EACL,eAAe,CAAC,UAAW,CAC9B,CAAA;QAET,MAAM,EAAE,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,EAAE,eAAe,CAAC,CAAA;QAChE,MAAM,IAAI,GAAG,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE,eAAe,CAAC,CAAA;QAChE,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;QACnC,KAAK,CAAC,kBAAkB,CAAC,eAAe,CAAC,CAAA;IAC7C,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,sBAAsB,CACxB,WAA2B,EAC3B,gBAA8B;QAE9B,MAAM,QAAQ,GAAG,gBAAgB,CAAC,GAAG,CAAC,CAAC,eAAe,EAAE,EAAE,CACtD,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,eAAe,CAAC,CAC3D,CAAA;QACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;IAC/B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,mBAAmB,CACrB,WAA2B,EAC3B,WAAgC;QAEhC,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,eAAe,GAAG,iCAAe,CAAC,YAAY,CAAC,WAAW,CAAC;YAC7D,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,WAAW,CAAC,CAAA;QACtD,IAAI,CAAC,eAAe;YAChB,MAAM,IAAI,oBAAY,CAClB,oDAAoD,KAAK,CAAC,IAAI,EAAE,CACnE,CAAA;QAEL,MAAM,EAAE,GAAG,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE,eAAe,CAAC,CAAA;QAC9D,MAAM,IAAI,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,EAAE,eAAe,CAAC,CAAA;QAClE,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;QACnC,KAAK,CAAC,qBAAqB,CAAC,eAAe,CAAC,CAAA;IAChD,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,oBAAoB,CACtB,WAA2B,EAC3B,gBAA8B;QAE9B,MAAM,QAAQ,GAAG,gBAAgB,CAAC,GAAG,CAAC,CAAC,eAAe,EAAE,EAAE,CACtD,IAAI,CAAC,mBAAmB,CAAC,WAAW,EAAE,eAAe,CAAC,CACzD,CAAA;QACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;IAC/B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,yBAAyB,CAC3B,WAA2B,EAC3B,mBAAmC;QAEnC,MAAM,IAAI,oBAAY,CAClB,mDAAmD,CACtD,CAAA;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,0BAA0B,CAC5B,WAA2B,EAC3B,oBAAsC;QAEtC,MAAM,IAAI,oBAAY,CAClB,mDAAmD,CACtD,CAAA;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,uBAAuB,CACzB,WAA2B,EAC3B,eAAwC;QAExC,MAAM,IAAI,oBAAY,CAClB,mDAAmD,CACtD,CAAA;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,wBAAwB,CAC1B,WAA2B,EAC3B,oBAAsC;QAEtC,MAAM,IAAI,oBAAY,CAClB,mDAAmD,CACtD,CAAA;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,gBAAgB,CAClB,WAA2B,EAC3B,UAA2B;QAE3B,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC;YACpD,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC;YACzC,CAAC,CAAC,SAAS,CAAA;QAEf,IACI,QAAQ;YACR,QAAQ,CAAC,kBAAkB;YAC3B,QAAQ,CAAC,kBAAmB,CAAC,YAAY;YACzC,QAAQ,CAAC,WAAW,CAAC,IAAI,CACrB,CAAC,UAAU,EAAE,EAAE,CAAC,UAAU,CAAC,QAAQ,KAAK,WAAW,CACtD;YAED,MAAM,IAAI,oBAAY,CAClB,mDAAmD,CACtD,CAAA;QAEL,gFAAgF;QAChF,IAAI,CAAC,UAAU,CAAC,IAAI;YAChB,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CAC3D,KAAK,EACL,UAAU,CAAC,WAAW,EACtB,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,EAC7B,UAAU,CAAC,qBAAqB,CACnC,CAAA;QAEL,MAAM,EAAE,GAAG,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAA;QACtD,MAAM,IAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAA;QACtD,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;QACnC,KAAK,CAAC,aAAa,CAAC,UAAU,CAAC,CAAA;IACnC,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,iBAAiB,CACnB,WAA2B,EAC3B,WAA8B;QAE9B,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAC5C,IAAI,CAAC,gBAAgB,CAAC,WAAW,EAAE,UAAU,CAAC,CACjD,CAAA;QACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;IAC/B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,cAAc,CAChB,WAA2B,EAC3B,gBAA0C;QAE1C,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,UAAU,GAAG,iCAAe,CAAC,iBAAiB,CAAC,gBAAgB,CAAC;YAClE,CAAC,CAAC,gBAAgB;YAClB,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,IAAI,KAAK,gBAAgB,CAAC,CAAA;QAClE,IAAI,CAAC,UAAU;YACX,MAAM,IAAI,oBAAY,CAClB,+CAA+C,KAAK,CAAC,IAAI,EAAE,CAC9D,CAAA;QAEL,MAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAA;QACpD,MAAM,IAAI,GAAG,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAA;QACxD,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;QACnC,KAAK,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAA;IACtC,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,eAAe,CACjB,WAA2B,EAC3B,WAA8B;QAE9B,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAC5C,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,UAAU,CAAC,CAC/C,CAAA;QACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;IAC/B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,WAAW,CACb,WAA2B,EAC3B,KAAiB;QAEjB,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAE5C,sFAAsF;QACtF,IAAI,CAAC,KAAK,CAAC,IAAI;YAAE,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;QAElE,MAAM,EAAE,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;QAC5C,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;QAC5C,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;QACnC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;IACzB,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,aAAa,CACf,WAA2B,EAC3B,OAAqB;QAErB,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CACnC,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,KAAK,CAAC,CACvC,CAAA;QACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;IAC/B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,SAAS,CACX,WAA2B,EAC3B,WAAgC;QAEhC,MAAM,KAAK,GAAG,iCAAe,CAAC,OAAO,CAAC,WAAW,CAAC;YAC9C,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC5C,MAAM,KAAK,GAAG,iCAAe,CAAC,YAAY,CAAC,WAAW,CAAC;YACnD,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,WAAW,CAAC,CAAA;QACvD,IAAI,CAAC,KAAK;YACN,MAAM,IAAI,oBAAY,CAClB,yCAAyC,KAAK,CAAC,IAAI,EAAE,CACxD,CAAA;QAEL,sFAAsF;QACtF,IAAI,CAAC,KAAK,CAAC,IAAI;YAAE,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;QAElE,MAAM,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;QAC1C,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;QAC9C,MAAM,IAAI,CAAC,cAAc,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;QACnC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;IAC5B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,WAAW,CACb,WAA2B,EAC3B,OAAqB;QAErB,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CACnC,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,KAAK,CAAC,CACrC,CAAA;QACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;IAC/B,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,UAAU,CAAC,SAAiB;QAC9B,MAAM,IAAI,CAAC,KAAK,CAAC,kBAAkB,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE,CAAC,CAAA;IACpE,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,aAAa,CAAC,QAAiB;QACjC,IAAI,QAAQ,EAAE,CAAC;YACX,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAA;YACxD,IAAI,CAAC,eAAe;gBAAE,OAAO,OAAO,CAAC,OAAO,EAAE,CAAA;QAClD,CAAC;QAED,MAAM,0BAA0B,GAAG,IAAI,CAAC,mBAAmB,CAAA;QAC3D,IAAI,CAAC,0BAA0B;YAAE,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAA;QAC9D,IAAI,CAAC;YACD,IAAI,WAAW,GAAG,QAAQ;gBACtB,CAAC,CAAC,kBAAkB,QAAQ,gCAAgC;gBAC5D,CAAC,CAAC,4CAA4C,CAAA;YAClD,MAAM,eAAe,GAAoB,MAAM,IAAI,CAAC,KAAK,CACrD,WAAW,CACd,CAAA;YAED,MAAM,OAAO,CAAC,GAAG,CACb,eAAe,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;gBAC/B,0FAA0F;gBAC1F,MAAM,YAAY,GAAG,cAAc,UAAU,CAAC,cAAc,CAAC,MAAM,UAAU,CAAC,YAAY,CAAC,GAAG,CAAA;gBAC9F,OAAO,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAA;YACnC,CAAC,CAAC,CACL,CAAA;YAED,IAAI,YAAY,GAAG,QAAQ;gBACvB,CAAC,CAAC,kBAAkB,QAAQ,mEAAmE;gBAC/F,CAAC,CAAC,+EAA+E,CAAA;YACrF,MAAM,gBAAgB,GAAoB,MAAM,IAAI,CAAC,KAAK,CACtD,YAAY,CACf,CAAA;YAED,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC9B,MAAM,eAAe,GAKjB,gBAAgB,CAAC,MAAM,CACvB,CAAC,CAAC,EAAE,EAAE,aAAa,EAAE,YAAY,EAAE,UAAU,EAAE,EAAE,EAAE;oBAC/C,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,aAAa,CAAC,IAAI,EAAE,CAAA;oBACzC,CAAC,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,EAAE,YAAY,EAAE,UAAU,EAAE,CAAC,CAAA;oBACnD,OAAO,CAAC,CAAA;gBACZ,CAAC,EACD,EAAE,CACL,CAAA;gBAED,MAAM,cAAc,GAAG,MAAM,CAAC,OAAO,CAAC,eAAe,CAAC;qBACjD,GAAG,CAAC,CAAC,CAAC,aAAa,EAAE,MAAM,CAAC,EAAE,EAAE;oBAC7B,MAAM,UAAU,GAAG,MAAM;yBACpB,GAAG,CAAC,CAAC,EAAE,YAAY,EAAE,UAAU,EAAE,EAAE,EAAE;wBAClC,OAAO,8CAA8C,aAAa,MAAM,YAAY,MAAM,UAAU,MAAM,CAAA;oBAC9G,CAAC,CAAC;yBACD,IAAI,CAAC,MAAM,CAAC,CAAA;oBAEjB,OAAO;2CACY,aAAa;;oEAEY,aAAa;sFACK,aAAa;;gCAEnE,aAAa;iCACZ,UAAU;qBACtB,CAAA;gBACD,CAAC,CAAC;qBACD,IAAI,CAAC,aAAa,CAAC,CAAA;gBAExB,MAAM,WAAW,GAKX,MAAM,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,CAAA;gBAEtC,MAAM,OAAO,CAAC,GAAG,CACb,WAAW,CAAC,GAAG,CACX,KAAK,EAAE,EACH,aAAa,EACb,YAAY,EACZ,UAAU,EACV,eAAe,GAClB,EAAE,EAAE;oBACD,gCAAgC;oBAChC,MAAM,IAAI,CAAC,KAAK,CACZ,gBAAgB,aAAa,MAAM,YAAY,MAAM,UAAU,IAAI;wBAC/D,uBAAuB,eAAe,GAAG,CAChD,CAAA;oBAED,MAAM,IAAI,CAAC,KAAK,CACZ,gBAAgB,aAAa,MAAM,YAAY,MAAM,UAAU,IAAI;wBAC/D,oBAAoB,eAAe,iBAAiB,CAC3D,CAAA;gBACL,CAAC,CACJ,CACJ,CAAA;gBAED,MAAM,OAAO,CAAC,GAAG,CACb,gBAAgB,CAAC,GAAG,CAAC,CAAC,YAAY,EAAE,EAAE;oBAClC,IAAI,YAAY,CAAC,YAAY,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;wBAC7C,qCAAqC;wBACrC,OAAM;oBACV,CAAC;oBAED,MAAM,YAAY,GAAG,eAAe,YAAY,CAAC,eAAe,CAAC,MAAM,YAAY,CAAC,cAAc,CAAC,MAAM,YAAY,CAAC,YAAY,CAAC,GAAG,CAAA;oBACtI,OAAO,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAA;gBACnC,CAAC,CAAC,CACL,CAAA;YACL,CAAC;YAED,IAAI,CAAC,0BAA0B;gBAAE,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAA;QACnE,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,IAAI,CAAC;gBACD,2DAA2D;gBAC3D,IAAI,CAAC,0BAA0B;oBAC3B,MAAM,IAAI,CAAC,mBAAmB,EAAE,CAAA;YACxC,CAAC;YAAC,OAAO,aAAa,EAAE,CAAC,CAAA,CAAC;YAC1B,MAAM,KAAK,CAAA;QACf,CAAC;IACL,CAAC;IAED,4EAA4E;IAC5E,oBAAoB;IACpB,4EAA4E;IAElE,KAAK,CAAC,SAAS,CAAC,SAAoB;QAC1C,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,2BAA2B,EAAE,CAAC,CAAA;QACxE,IAAI,CAAC,QAAQ,EAAE,CAAC;YACZ,OAAO,EAAE,CAAA;QACb,CAAC;QAED,IAAI,CAAC,SAAS,EAAE,CAAC;YACb,SAAS,GAAG,EAAE,CAAA;QAClB,CAAC;QAED,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAA;QACnD,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAA;QAEvD,MAAM,OAAO,GAAG,SAAS;aACpB,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,QAAQ,CAAC;aAChE,MAAM,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,CAAA;QAEnC,IACI,IAAI,CAAC,MAAM,CAAC,QAAQ;YACpB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC;YAE1D,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;QAEtC,MAAM,cAAc,GAAG,SAAS;aAC3B,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE;YACd,IAAI,EAAE,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,GAC3B,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAA;YAExC,IAAI,CAAC,MAAM,EAAE,CAAC;gBACV,MAAM,GAAG,aAAa,CAAA;YAC1B,CAAC;YACD,OAAO,oBAAoB,MAAM,uBAAuB,IAAI,IAAI,CAAA;QACpE,CAAC,CAAC;aACD,IAAI,CAAC,MAAM,CAAC,CAAA;QAEjB,MAAM,KAAK,GAAG,OAAO;aAChB,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE;YACZ,OAAO,CACH,yCAAyC,IAAI,CAAC,UAAU,CACpD,IAAI,CAAC,2BAA2B,EAAE,CACrC,OAAO;gBACR,eAAe,MAAM,iIACjB,qCAAiB,CAAC,IACtB,KAAK,cAAc,CAAC,CAAC,CAAC,QAAQ,cAAc,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CACzD,CAAA;QACL,CAAC,CAAC;aACD,IAAI,CAAC,aAAa,CAAC,CAAA;QAExB,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;QACvC,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,MAAW,EAAE,EAAE;YAC/B,MAAM,IAAI,GAAG,IAAI,WAAI,EAAE,CAAA;YACvB,MAAM,EAAE,GACJ,MAAM,CAAC,eAAe,CAAC,KAAK,eAAe;gBACvC,CAAC,CAAC,SAAS;gBACX,CAAC,CAAC,MAAM,CAAC,eAAe,CAAC,CAAA;YACjC,MAAM,MAAM,GACR,MAAM,CAAC,QAAQ,CAAC,KAAK,aAAa;gBAClC,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM;gBACvB,CAAC,CAAC,SAAS;gBACX,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;YAC1B,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC,eAAe,CAAC,CAAA;YACvC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAA;YAC9B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,MAAM,EAAE,EAAE,CAAC,CAAA;YAClE,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,OAAO,CAAC,CAAA;YACjC,OAAO,IAAI,CAAA;QACf,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;OAEG;IACO,KAAK,CAAC,UAAU,CAAC,UAAqB;QAC5C,6CAA6C;QAC7C,IAAI,UAAU,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxC,OAAO,EAAE,CAAA;QACb,CAAC;QAED,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAA;QACnD,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,kBAAkB,EAAE,CAAA;QAEvD,MAAM,QAAQ,GAIR,EAAE,CAAA;QAER,IAAI,CAAC,UAAU,EAAE,CAAC;YACd,MAAM,YAAY,GACd,yBAAyB;gBACzB,qCAAqC;gBACrC,iDAAiD,CAAA;YACrD,MAAM,WAAW,GAAuB,MAAM,IAAI,CAAC,KAAK,CACpD,YAAY,CACf,CAAA;YAED,MAAM,SAAS,GAAG,WAAW;iBACxB,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE;gBACd,OAAO;;;4BAGC,IAAI;;;;2CAIW,IAAI;;;iBAG9B,CAAA;YACD,CAAC,CAAC;iBACD,IAAI,CAAC,aAAa,CAAC,CAAA;YAExB,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAA;QACnD,CAAC;aAAM,CAAC;YACJ,MAAM,mBAAmB,GAAG,UAAU;iBACjC,GAAG,CAAC,CAAC,SAAS,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;iBACzD,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,QAAQ,EAAE,GAAG,KAAK,EAAE,EAAE,EAAE;gBAClC,QAAQ,GAAG,QAAQ,IAAI,eAAe,CAAA;gBACtC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAA;gBAC/B,CAAC,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC;oBACb,MAAM,EAAE,KAAK,CAAC,MAAM,IAAI,aAAa;oBACrC,SAAS,EAAE,KAAK,CAAC,SAAS;iBAC7B,CAAC,CAAA;gBACF,OAAO,CAAC,CAAA;YACZ,CAAC,EAAE,EAAgE,CAAC,CAAA;YAExE,MAAM,SAAS,GAAG,MAAM,CAAC,OAAO,CAAC,mBAAmB,CAAC;iBAChD,GAAG,CAAC,CAAC,CAAC,QAAQ,EAAE,MAAM,CAAC,EAAE,EAAE;gBACxB,MAAM,eAAe,GAAG,MAAM;qBACzB,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,SAAS,EAAE,EAAE,EAAE;oBAC3B,OAAO,sBAAsB,MAAM,yBAAyB,SAAS,IAAI,CAAA;gBAC7E,CAAC,CAAC;qBACD,IAAI,CAAC,MAAM,CAAC,CAAA;gBAEjB,OAAO;;;4BAGC,QAAQ;;;+CAGW,QAAQ;4BAC3B,eAAe;iBAC1B,CAAA;YACD,CAAC,CAAC;iBACD,IAAI,CAAC,aAAa,CAAC,CAAA;YAExB,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAA;QACnD,CAAC;QAED,yDAAyD;QACzD,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxB,OAAO,EAAE,CAAA;QACb,CAAC;QAED,MAAM,iBAAiB,GAAG,QAAQ,CAAC,MAAM,CACrC,CAAC,CAAC,EAAE,EAAE,aAAa,EAAE,GAAG,KAAK,EAAE,EAAE,EAAE;YAC/B,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,aAAa,CAAC,IAAI,EAAE,CAAA;YACzC,CAAC,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;YAC5B,OAAO,CAAC,CAAA;QACZ,CAAC,EACD,EAEC,CACJ,CAAA;QAED,MAAM,UAAU,GAAG,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC;aAC/C,GAAG,CAAC,CAAC,CAAC,aAAa,EAAE,MAAM,CAAC,EAAE,EAAE;YAC7B,MAAM,SAAS,GAAG,MAAM;iBACnB,GAAG,CACA,CAAC,EAAE,YAAY,EAAE,UAAU,EAAE,EAAE,EAAE,CAC7B,sBAAsB,YAAY,yBAAyB,UAAU,IAAI,CAChF;iBACA,IAAI,CAAC,IAAI,CAAC,CAAA;YAEf,OAAO,CACH,6DAA6D;gBAC7D,SAAS,aAAa,mCAAmC;gBACzD,0GAA0G;gBAC1G,UAAU,SAAS,GAAG,CACzB,CAAA;QACL,CAAC,CAAC;aACD,IAAI,CAAC,aAAa,CAAC,CAAA;QAExB,MAAM,cAAc,GAAG,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC;aACnD,GAAG,CAAC,CAAC,CAAC,aAAa,EAAE,MAAM,CAAC,EAAE,EAAE;YAC7B,MAAM,UAAU,GAAG,MAAM;iBACpB,GAAG,CACA,CAAC,EAAE,UAAU,EAAE,YAAY,EAAE,EAAE,EAAE,CAC7B,qCAAqC,YAAY,wCAAwC,UAAU,IAAI,CAC9G;iBACA,IAAI,CAAC,MAAM,CAAC,CAAA;YAEjB,OAAO,CACH,oFAAoF;gBACpF,SAAS,aAAa,kEAAkE;gBACxF,eAAe,aAAa,gEAAgE;gBAC5F,KAAK;gBACL,8EAA8E;gBAC9E,wEAAwE;gBACxE,gEAAgE;gBAChE,cAAc,aAAa,oCAAoC;gBAC/D,KAAK;gBACL,+IAA+I;gBAC/I,QAAQ;gBACR,IAAI,UAAU,QAAQ;gBACtB,4EAA4E,CAC/E,CAAA;QACL,CAAC,CAAC;aACD,IAAI,CAAC,aAAa,CAAC,CAAA;QAExB,MAAM,cAAc,GAAG,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC;aACnD,GAAG,CAAC,CAAC,CAAC,aAAa,EAAE,MAAM,CAAC,EAAE,EAAE;YAC7B,MAAM,UAAU,GAAG,MAAM;iBACpB,GAAG,CACA,CAAC,EAAE,UAAU,EAAE,YAAY,EAAE,EAAE,EAAE,CAC7B,mBAAmB,YAAY,wBAAwB,UAAU,IAAI,CAC5E;iBACA,IAAI,CAAC,MAAM,CAAC,CAAA;YAEjB,OAAO,CACH,qCAAqC,aAAa,oFAAoF;gBACtI,0HAA0H;gBAC1H,6GAA6G;gBAC7G,SAAS,aAAa,8BAA8B;gBACpD,eAAe,aAAa,yFAAyF;gBACrH,eAAe,aAAa,sEAAsE;gBAClG,eAAe,aAAa,gEAAgE;gBAC5F,eAAe,aAAa,0EAA0E;gBACtG,eAAe,aAAa,gEAAgE;gBAC5F,eAAe,aAAa,6HAA6H;gBACzJ,eAAe,aAAa,qIAAqI;gBACjK,UAAU,UAAU,GAAG,CAC1B,CAAA;QACL,CAAC,CAAC;aACD,IAAI,CAAC,aAAa,CAAC,CAAA;QAExB,MAAM,kBAAkB,GAAG,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC;aACvD,GAAG,CAAC,CAAC,CAAC,aAAa,EAAE,MAAM,CAAC,EAAE,EAAE;YAC7B,MAAM,UAAU,GAAG,MAAM;iBACpB,GAAG,CACA,CAAC,EAAE,UAAU,EAAE,YAAY,EAAE,EAAE,EAAE,CAC7B,sBAAsB,YAAY,yBAAyB,UAAU,IAAI,CAChF;iBACA,IAAI,CAAC,MAAM,CAAC,CAAA;YAEjB,OAAO,CACH,sEAAsE;gBACtE,SAAS,aAAa,mCAAmC;gBACzD,QAAQ;gBACR,yBAAyB,aAAa,qLAAqL;gBAC3N,IAAI,UAAU,GAAG,CACpB,CAAA;QACL,CAAC,CAAC;aACD,IAAI,CAAC,aAAa,CAAC,CAAA;QAExB,MAAM,eAAe,GAAG,wDAAwD,CAAA;QAEhF,MAAM,UAAU,GAAG,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC;aAC/C,GAAG,CAAC,CAAC,CAAC,aAAa,EAAE,MAAM,CAAC,EAAE,EAAE;YAC7B,MAAM,UAAU,GAAG,MAAM;iBACpB,GAAG,CACA,CAAC,EAAE,UAAU,EAAE,YAAY,EAAE,EAAE,EAAE,CAC7B,kBAAkB,YAAY,uBAAuB,UAAU,IAAI,CAC1E;iBACA,IAAI,CAAC,MAAM,CAAC,CAAA;YAEjB,OAAO,CACH,WAAW,aAAa,kFAAkF;gBAC1G,0IAA0I;gBAC1I,SAAS,aAAa,0BAA0B;gBAChD,eAAe,aAAa,8GAA8G;gBAC1I,eAAe,aAAa,2GAA2G;gBACvI,eAAe,aAAa,8DAA8D;gBAC1F,eAAe,aAAa,6DAA6D;gBACzF,QAAQ;gBACR,kGAAkG;gBAClG,IAAI,UAAU,GAAG,CACpB,CAAA;QACL,CAAC,CAAC;aACD,IAAI,CAAC,aAAa,CAAC,CAAA;QAExB,MAAM,CACF,SAAS,EACT,aAAa,EACb,aAAa,EACb,iBAAiB,EACjB,YAAY,EACZ,SAAS,EACZ,GAAsB,MAAM,OAAO,CAAC,GAAG,CAAC;YACrC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC;YACtB,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC;YAC1B,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC;YAC1B,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC;YAC9B,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC;YAC3B,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC;SACzB,CAAC,CAAA;QAEF,yCAAyC;QACzC,OAAO,MAAM,OAAO,CAAC,GAAG,CACpB,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE;YAC3B,MAAM,KAAK,GAAG,IAAI,aAAK,EAAE,CAAA;YAEzB,MAAM,gBAAgB,GAAG,CAAC,QAAa,EAAE,GAAW,EAAE,EAAE;gBACpD,OAAO,QAAQ,CAAC,GAAG,CAAC,KAAK,aAAa;oBAClC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM;wBACxB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,KAAK,aAAa,CAAC;oBACjD,CAAC,CAAC,SAAS;oBACX,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAA;YACvB,CAAC,CAAA;YAED,qFAAqF;YACrF,MAAM,EAAE,GACJ,OAAO,CAAC,eAAe,CAAC,KAAK,eAAe;gBACxC,CAAC,CAAC,SAAS;gBACX,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC,CAAA;YAClC,MAAM,MAAM,GAAG,gBAAgB,CAAC,OAAO,EAAE,cAAc,CAAC,CAAA;YACxD,KAAK,CAAC,QAAQ,GAAG,OAAO,CAAC,eAAe,CAAC,CAAA;YACzC,KAAK,CAAC,MAAM,GAAG,OAAO,CAAC,cAAc,CAAC,CAAA;YACtC,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CACnC,OAAO,CAAC,YAAY,CAAC,EACrB,MAAM,EACN,EAAE,CACL,CAAA;YAED,MAAM,gBAAgB,GAAG,YAAY,CAAC,IAAI,CACtC,CAAC,WAAW,EAAE,EAAE,CACZ,WAAW,CAAC,MAAM,CAAC,KAAK,OAAO,CAAC,eAAe,CAAC,CACtD,CAAA;YAEF,yCAAyC;YACzC,KAAK,CAAC,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAC7B,SAAS;iBACJ,MAAM,CACH,CAAC,QAAQ,EAAE,EAAE,CACT,QAAQ,CAAC,YAAY,CAAC;gBAClB,OAAO,CAAC,YAAY,CAAC;gBACzB,QAAQ,CAAC,cAAc,CAAC;oBACpB,OAAO,CAAC,cAAc,CAAC;gBAC3B,QAAQ,CAAC,eAAe,CAAC;oBACrB,OAAO,CAAC,eAAe,CAAC,CACnC;iBACA,GAAG,CAAC,KAAK,EAAE,QAAQ,EAAE,EAAE;gBACpB,MAAM,iBAAiB,GAAG,aAAa,CAAC,MAAM,CAC1C,CAAC,YAAY,EAAE,EAAE,CACb,YAAY,CAAC,YAAY,CAAC;oBACtB,QAAQ,CAAC,YAAY,CAAC;oBAC1B,YAAY,CAAC,cAAc,CAAC;wBACxB,QAAQ,CAAC,cAAc,CAAC;oBAC5B,YAAY,CAAC,eAAe,CAAC;wBACzB,QAAQ,CAAC,eAAe,CAAC;oBAC7B,YAAY,CAAC,aAAa,CAAC;wBACvB,QAAQ,CAAC,aAAa,CAAC,CAClC,CAAA;gBAED,MAAM,iBAAiB,GAAG,iBAAiB,CAAC,MAAM,CAC9C,CAAC,UAAU,EAAE,EAAE,CACX,UAAU,CAAC,iBAAiB,CAAC,KAAK,QAAQ,CACjD,CAAA;gBACD,MAAM,qBAAqB,GACvB,iBAAiB,CAAC,KAAK,CAAC,CAAC,gBAAgB,EAAE,EAAE;oBACzC,OAAO,aAAa,CAAC,IAAI,CACrB,CAAC,YAAY,EAAE,EAAE,CACb,YAAY,CAAC,iBAAiB,CAAC;wBAC3B,QAAQ;wBACZ,YAAY,CAAC,iBAAiB,CAAC;4BAC3B,gBAAgB,CACZ,iBAAiB,CACpB;wBACL,YAAY,CAAC,cAAc,CAAC;4BACxB,QAAQ,CAAC,cAAc,CAAC;wBAC5B,YAAY,CAAC,eAAe,CAAC;4BACzB,QAAQ,CAAC,eAAe,CAAC;wBAC7B,YAAY,CAAC,aAAa,CAAC;4BACvB,QAAQ,CAAC,aAAa,CAAC,CAClC,CAAA;gBACL,CAAC,CAAC,CAAA;gBAEN,MAAM,WAAW,GAAG,CAAC,CAAC,iBAAiB,CAAC,IAAI,CACxC,CAAC,MAAM,EAAE,EAAE,CACP,MAAM,CAAC,YAAY,CAAC;oBAChB,QAAQ,CAAC,YAAY,CAAC;oBAC1B,MAAM,CAAC,cAAc,CAAC;wBAClB,QAAQ,CAAC,cAAc,CAAC;oBAC5B,MAAM,CAAC,eAAe,CAAC;wBACnB,QAAQ,CAAC,eAAe,CAAC;oBAC7B,MAAM,CAAC,aAAa,CAAC;wBACjB,QAAQ,CAAC,aAAa,CAAC,CAClC,CAAA;gBAED,MAAM,WAAW,GAAG,IAAI,yBAAW,EAAE,CAAA;gBACrC,WAAW,CAAC,IAAI,GAAG,QAAQ,CAAC,aAAa,CAAC,CAAA;gBAC1C,WAAW,CAAC,IAAI;oBACZ,QAAQ,CAAC,WAAW,CAAC,CAAC,WAAW,EAAE,CAAA;gBAEvC,+CAA+C;gBAC/C,IACI,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,OAAO,CACrC,WAAW,CAAC,IAAkB,CACjC,KAAK,CAAC,CAAC;oBACR,QAAQ,CAAC,0BAA0B,CAAC,EACtC,CAAC;oBACC,MAAM,MAAM,GACR,QAAQ,CACJ,0BAA0B,CAC7B,CAAC,QAAQ,EAAE,CAAA;oBAChB,IAAI,MAAM,KAAK,IAAI,EAAE,CAAC;wBAClB,WAAW,CAAC,MAAM,GAAG,KAAK,CAAA;oBAC9B,CAAC;yBAAM,CAAC;wBACJ,WAAW,CAAC,MAAM;4BACd,CAAC,IAAI,CAAC,qBAAqB,CACvB,KAAK,EACL,WAAW,EACX,MAAM,CACT;gCACG,CAAC,CAAC,MAAM;gCACR,CAAC,CAAC,EAAE,CAAA;oBAChB,CAAC;gBACL,CAAC;gBAED,IACI,WAAW,CAAC,IAAI,KAAK,SAAS;oBAC9B,WAAW,CAAC,IAAI,KAAK,SAAS,EAChC,CAAC;oBACC,IACI,QAAQ,CAAC,mBAAmB,CAAC,KAAK,IAAI;wBACtC,CAAC,IAAI,CAAC,wBAAwB,CAC1B,KAAK,EACL,WAAW,EACX,QAAQ,CAAC,mBAAmB,CAAC,CAChC;wBAED,WAAW,CAAC,SAAS;4BACjB,QAAQ,CAAC,mBAAmB,CAAC,CAAA;oBACrC,IACI,QAAQ,CAAC,eAAe,CAAC,KAAK,IAAI;wBAClC,CAAC,IAAI,CAAC,oBAAoB,CACtB,KAAK,EACL,WAAW,EACX,QAAQ,CAAC,eAAe,CAAC,CAC5B;wBAED,WAAW,CAAC,KAAK;4BACb,QAAQ,CAAC,eAAe,CAAC,CAAA;gBACrC,CAAC;gBAED,IAAI,WAAW,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;oBAClC,2BAA2B;oBAC3B,MAAM,sBAAsB,GACxB,iBAAiB,CAAC,MAAM,CACpB,CAAC,UAAU,EAAE,EAAE,CACX,UAAU,CAAC,iBAAiB,CAAC;wBAC7B,OAAO,CACd,CAAA;oBACL,IAAI,sBAAsB,CAAC,MAAM,EAAE,CAAC;wBAChC,oIAAoI;wBACpI,KAAK,MAAM,eAAe,IAAI,sBAAsB,EAAE,CAAC;4BACnD,IACI,IAAI,CAAC,qBAAqB,CACtB,eAAe,CACX,iBAAiB,CACpB,CACJ,EACH,CAAC;gCACC,uDAAuD;gCACvD,WAAW,CAAC,IAAI,GAAG,EAAE,CAAA;gCACrB,MAAM,eAAe,GAAG,IAAI,MAAM,CAC9B,KAAK;oCACD,WAAW,CAAC,IAAI;oCAChB,eAAe,EACnB,GAAG,CACN,CAAA;gCACD,IAAI,MAAM,CAAA;gCACV,OACI,CAAC,MAAM,GAAG,eAAe,CAAC,IAAI,CAC1B,eAAe,CACX,YAAY,CACf,CACJ,CAAC,KAAK,IAAI,EACb,CAAC;oCACC,WAAW,CAAC,IAAI,CAAC,OAAO,CACpB,MAAM,CAAC,CAAC,CAAC,CACZ,CAAA;gCACL,CAAC;gCACD,gCAAgC;gCAChC,MAAK;4BACT,CAAC;wBACL,CAAC;oBACL,CAAC;gBACL,CAAC;gBAED,MAAM,iBAAiB,GAAG,iBAAiB,CAAC,IAAI,CAC5C,CAAC,UAAU,EAAE,EAAE,CACX,UAAU,CAAC,iBAAiB,CAAC;oBAC7B,aAAa,CACpB,CAAA;gBACD,IAAI,iBAAiB,EAAE,CAAC;oBACpB,WAAW,CAAC,SAAS,GAAG,IAAI,CAAA;oBAC5B,0DAA0D;oBAC1D,MAAM,yBAAyB,GAC3B,aAAa,CAAC,MAAM,CAChB,CAAC,UAAU,EAAE,EAAE,CACX,UAAU,CAAC,YAAY,CAAC;wBACpB,QAAQ,CAAC,YAAY,CAAC;wBAC1B,UAAU,CAAC,cAAc,CAAC;4BACtB,QAAQ,CAAC,cAAc,CAAC;wBAC5B,UAAU,CAAC,eAAe,CAAC;4BACvB,QAAQ,CAAC,eAAe,CAAC;wBAC7B,UAAU,CAAC,aAAa,CAAC;4BACrB,QAAQ,CAAC,aAAa,CAAC;wBAC3B,UAAU,CAAC,iBAAiB,CAAC;4BACzB,aAAa,CACxB,CAAA;oBAEL,2BAA2B;oBAC3B,MAAM,WAAW,GACb,yBAAyB,CAAC,GAAG,CACzB,CAAC,UAAU,EAAE,EAAE,CACX,UAAU,CAAC,aAAa,CAAC,CAChC,CAAA;oBACL,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAA;oBAEzC,4CAA4C;oBAC5C,MAAM,MAAM,GACR,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,KAAK,EACL,WAAW,CACd,CAAA;oBAEL,4EAA4E;oBAC5E,IACI,iBAAiB,CAAC,iBAAiB,CAAC;wBACpC,MAAM,EACR,CAAC;wBACC,WAAW,CAAC,wBAAwB;4BAChC,iBAAiB,CAAC,iBAAiB,CAAC,CAAA;oBAC5C,CAAC;gBACL,CAAC;gBAED,WAAW,CAAC,OAAO;oBACf,QAAQ,CAAC,gBAAgB,CAAC,KAAK,IAAI;wBACnC,QAAQ,CAAC,gBAAgB,CAAC,KAAK,SAAS;wBACpC,CAAC,CAAC,IAAI,CAAC,4BAA4B,CAC7B,QAAQ,CAAC,gBAAgB,CAAC,CAC7B;wBACH,CAAC,CAAC,SAAS,CAAA;gBACnB,WAAW,CAAC,UAAU;oBAClB,QAAQ,CAAC,aAAa,CAAC,KAAK,KAAK,CAAA;gBACrC,WAAW,CAAC,QAAQ;oBAChB,iBAAiB,CAAC,MAAM,GAAG,CAAC;wBAC5B,CAAC,qBAAqB,CAAA;gBAC1B,WAAW,CAAC,WAAW,GAAG,WAAW,CAAA;gBACrC,IAAI,WAAW;oBACX,WAAW,CAAC,kBAAkB,GAAG,WAAW,CAAA;gBAChD,IAAI,WAAW,CAAC,OAAO,KAAK,mBAAmB,EAAE,CAAC;oBAC9C,WAAW,CAAC,WAAW,GAAG,IAAI,CAAA;oBAC9B,WAAW,CAAC,kBAAkB,GAAG,MAAM,CAAA;oBACvC,WAAW,CAAC,OAAO,GAAG,SAAS,CAAA;gBACnC,CAAC;gBAED,sCAAsC;gBACtC,wDAAwD;gBACxD,IAAI,QAAQ,CAAC,gBAAgB,CAAC;oBAC1B,WAAW,CAAC,SAAS;wBACjB,QAAQ,CAAC,gBAAgB,CAAC;4BAC1B,gBAAgB,CAAC,gBAAgB,CAAC;4BAC9B,CAAC,CAAC,SAAS;4BACX,CAAC,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAA;gBAExC,IACI,WAAW,CAAC,IAAI,KAAK,WAAW;oBAChC,WAAW,CAAC,IAAI,KAAK,MAAM;oBAC3B,WAAW,CAAC,IAAI,KAAK,gBAAgB,EACvC,CAAC;oBACC,WAAW,CAAC,SAAS;wBACjB,CAAC,IAAI,CAAC,wBAAwB,CAC1B,KAAK,EACL,WAAW,EACX,QAAQ,CAAC,oBAAoB,CAAC,CACjC;4BACG,CAAC,CAAC,QAAQ,CAAC,oBAAoB,CAAC;4BAChC,CAAC,CAAC,SAAS,CAAA;gBACvB,CAAC;gBAED,IACI,QAAQ,CAAC,cAAc,CAAC,KAAK,IAAI;oBACjC,QAAQ,CAAC,cAAc,CAAC,KAAK,SAAS;oBACtC,QAAQ,CAAC,YAAY,CAAC,EACxB,CAAC;oBACC,WAAW,CAAC,aAAa;wBACrB,QAAQ,CAAC,cAAc,CAAC,KAAK,IAAI;4BAC7B,CAAC,CAAC,QAAQ;4BACV,CAAC,CAAC,SAAS,CAAA;oBACnB,0GAA0G;oBAC1G,MAAM,iBAAiB,GACnB,IAAI,CAAC,wBAAwB,CAAC;wBAC1B,QAAQ,EAAE,OAAO,CAAC,eAAe,CAAC;wBAClC,MAAM,EAAE,OAAO,CAAC,cAAc,CAAC;wBAC/B,KAAK,EAAE,OAAO,CAAC,YAAY,CAAC;wBAC5B,IAAI,EAAE,qCAAiB,CAAC,gBAAgB;wBACxC,IAAI,EAAE,WAAW,CAAC,IAAI;qBACzB,CAAC,CAAA;oBAEN,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,KAAK,CAC5B,iBAAiB,CAAC,KAAK,EACvB,iBAAiB,CAAC,UAAU,CAC/B,CAAA;oBACD,IAAI,OAAO,CAAC,CAAC,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;wBACjC,WAAW,CAAC,YAAY,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAA;oBAC/C,CAAC;yBAAM,CAAC;wBACJ,WAAW,CAAC,YAAY,GAAG,EAAE,CAAA;oBACjC,CAAC;gBACL,CAAC;gBAED,OAAO,WAAW,CAAA;YACtB,CAAC,CAAC,CACT,CAAA;YAED,yFAAyF;YACzF,MAAM,sBAAsB,GAAG,mBAAQ,CAAC,IAAI,CACxC,aAAa,CAAC,MAAM,CAChB,CAAC,YAAY,EAAE,EAAE,CACb,YAAY,CAAC,YAAY,CAAC;gBACtB,OAAO,CAAC,YAAY,CAAC;gBACzB,YAAY,CAAC,cAAc,CAAC;oBACxB,OAAO,CAAC,cAAc,CAAC;gBAC3B,YAAY,CAAC,eAAe,CAAC;oBACzB,OAAO,CAAC,eAAe,CAAC;gBAC5B,YAAY,CAAC,iBAAiB,CAAC,KAAK,QAAQ,CACnD,EACD,CAAC,YAAY,EAAE,EAAE,CAAC,YAAY,CAAC,iBAAiB,CAAC,CACpD,CAAA;YAED,KAAK,CAAC,OAAO,GAAG,sBAAsB,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;gBACtD,MAAM,OAAO,GAAG,aAAa,CAAC,MAAM,CAChC,CAAC,GAAG,EAAE,EAAE,CACJ,GAAG,CAAC,iBAAiB,CAAC;oBACtB,UAAU,CAAC,iBAAiB,CAAC,CACpC,CAAA;gBACD,OAAO,IAAI,yBAAW,CAAC;oBACnB,IAAI,EAAE,UAAU,CAAC,iBAAiB,CAAC;oBACnC,WAAW,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC;iBACpD,CAAC,CAAA;YACN,CAAC,CAAC,CAAA;YAEF,uFAAuF;YACvF,MAAM,qBAAqB,GAAG,mBAAQ,CAAC,IAAI,CACvC,aAAa,CAAC,MAAM,CAChB,CAAC,YAAY,EAAE,EAAE,CACb,YAAY,CAAC,YAAY,CAAC;gBACtB,OAAO,CAAC,YAAY,CAAC;gBACzB,YAAY,CAAC,cAAc,CAAC;oBACxB,OAAO,CAAC,cAAc,CAAC;gBAC3B,YAAY,CAAC,eAAe,CAAC;oBACzB,OAAO,CAAC,eAAe,CAAC;gBAC5B,YAAY,CAAC,iBAAiB,CAAC,KAAK,OAAO,CAClD,EACD,CAAC,YAAY,EAAE,EAAE,CAAC,YAAY,CAAC,iBAAiB,CAAC,CACpD,CAAA;YAED,KAAK,CAAC,MAAM,GAAG,qBAAqB;iBAC/B,MAAM,CACH,CAAC,UAAU,EAAE,EAAE,CACX,CAAC,IAAI,CAAC,qBAAqB,CACvB,UAAU,CAAC,iBAAiB,CAAC,CAChC,CACR;iBACA,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;gBAChB,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,CAC/B,CAAC,GAAG,EAAE,EAAE,CACJ,GAAG,CAAC,iBAAiB,CAAC;oBACtB,UAAU,CAAC,iBAAiB,CAAC,CACpC,CAAA;gBACD,OAAO,IAAI,uBAAU,CAAC;oBAClB,IAAI,EAAE,UAAU,CAAC,iBAAiB,CAAC;oBACnC,WAAW,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC;oBAChD,UAAU,EAAE,UAAU,CAAC,YAAY,CAAC;iBACvC,CAAC,CAAA;YACN,CAAC,CAAC,CAAA;YAEN,kGAAkG;YAClG,MAAM,0BAA0B,GAAG,mBAAQ,CAAC,IAAI,CAC5C,aAAa,CAAC,MAAM,CAChB,CAAC,YAAY,EAAE,EAAE,CACb,YAAY,CAAC,YAAY,CAAC;gBACtB,OAAO,CAAC,YAAY,CAAC;gBACzB,YAAY,CAAC,cAAc,CAAC;oBACxB,OAAO,CAAC,cAAc,CAAC;gBAC3B,YAAY,CAAC,eAAe,CAAC;oBACzB,OAAO,CAAC,eAAe,CAAC,CACnC,EACD,CAAC,YAAY,EAAE,EAAE,CAAC,YAAY,CAAC,SAAS,CAAC,CAC5C,CAAA;YAED,KAAK,CAAC,WAAW,GAAG,0BAA0B,CAAC,GAAG,CAC9C,CAAC,YAAY,EAAE,EAAE;gBACb,MAAM,WAAW,GAAG,aAAa,CAAC,MAAM,CACpC,CAAC,IAAI,EAAE,EAAE,CACL,IAAI,CAAC,SAAS,CAAC,KAAK,YAAY,CAAC,SAAS,CAAC,CAClD,CAAA;gBAED,0HAA0H;gBAC1H,MAAM,EAAE,GACJ,YAAY,CAAC,eAAe,CAAC,KAAK,eAAe;oBAC7C,CAAC,CAAC,SAAS;oBACX,CAAC,CAAC,YAAY,CAAC,eAAe,CAAC,CAAA;gBACvC,MAAM,MAAM,GAAG,gBAAgB,CAC3B,YAAY,EACZ,YAAY,CACf,CAAA;gBACD,MAAM,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAClD,YAAY,CAAC,WAAW,CAAC,EACzB,MAAM,EACN,EAAE,CACL,CAAA;gBAED,OAAO,IAAI,iCAAe,CAAC;oBACvB,IAAI,EAAE,YAAY,CAAC,SAAS,CAAC;oBAC7B,WAAW,EAAE,WAAW,CAAC,GAAG,CACxB,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,CAChC;oBACD,kBAAkB,EAAE,YAAY,CAAC,eAAe,CAAC;oBACjD,gBAAgB,EAAE,YAAY,CAAC,YAAY,CAAC;oBAC5C,mBAAmB,EAAE,mBAAmB;oBACxC,qBAAqB,EAAE,WAAW,CAAC,GAAG,CAClC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,CAC/B;oBACD,QAAQ,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC,OAAO,CACvC,GAAG,EACH,GAAG,CACN,EAAE,oDAAoD;oBACvD,QAAQ,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC,OAAO,CACvC,GAAG,EACH,GAAG,CACN,EAAE,oDAAoD;iBAC1D,CAAC,CAAA;YACN,CAAC,CACJ,CAAA;YAED,uFAAuF;YACvF,MAAM,qBAAqB,GAAG,mBAAQ,CAAC,IAAI,CACvC,SAAS,CAAC,MAAM,CACZ,CAAC,OAAO,EAAE,EAAE,CACR,OAAO,CAAC,YAAY,CAAC,KAAK,OAAO,CAAC,YAAY,CAAC;gBAC/C,OAAO,CAAC,cAAc,CAAC;oBACnB,OAAO,CAAC,cAAc,CAAC;gBAC3B,OAAO,CAAC,eAAe,CAAC;oBACpB,OAAO,CAAC,eAAe,CAAC,CACnC,EACD,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,YAAY,CAAC,CACrC,CAAA;YAED,KAAK,CAAC,OAAO,GAAG,qBAAqB,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;gBACrD,MAAM,OAAO,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;oBACvC,OAAO,CACH,KAAK,CAAC,eAAe,CAAC;wBAClB,UAAU,CAAC,eAAe,CAAC;wBAC/B,KAAK,CAAC,cAAc,CAAC;4BACjB,UAAU,CAAC,cAAc,CAAC;wBAC9B,KAAK,CAAC,YAAY,CAAC,KAAK,UAAU,CAAC,YAAY,CAAC;wBAChD,KAAK,CAAC,YAAY,CAAC,KAAK,UAAU,CAAC,YAAY,CAAC,CACnD,CAAA;gBACL,CAAC,CAAC,CAAA;gBACF,OAAO,IAAI,uBAAU,CAAoB;oBACrC,KAAK,EAAE,KAAK;oBACZ,IAAI,EAAE,UAAU,CAAC,YAAY,CAAC;oBAC9B,WAAW,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC;oBACjD,QAAQ,EAAE,UAAU,CAAC,WAAW,CAAC;oBACjC,KAAK,EAAE,UAAU,CAAC,WAAW,CAAC;iBACjC,CAAC,CAAA;YACN,CAAC,CAAC,CAAA;YAEF,OAAO,KAAK,CAAA;QAChB,CAAC,CAAC,CACL,CAAA;IACL,CAAC;IAED;;OAEG;IACO,cAAc,CAAC,KAAY,EAAE,iBAA2B;QAC9D,MAAM,iBAAiB,GAAG,KAAK,CAAC,OAAO;aAClC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CACZ,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CACxD;aACA,IAAI,CAAC,IAAI,CAAC,CAAA;QACf,IAAI,GAAG,GAAG,gBAAgB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,iBAAiB,EAAE,CAAA;QAExE,KAAK,CAAC,OAAO;aACR,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC;aACnC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YAChB,MAAM,aAAa,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CACpC,CAAC,MAAM,EAAE,EAAE,CACP,MAAM,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC;gBAC/B,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,IAAI,CAC5C,CAAA;YACD,IAAI,CAAC,aAAa;gBACd,KAAK,CAAC,OAAO,CAAC,IAAI,CACd,IAAI,yBAAW,CAAC;oBACZ,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,oBAAoB,CACrD,KAAK,EACL,CAAC,MAAM,CAAC,IAAI,CAAC,CAChB;oBACD,WAAW,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC;iBAC7B,CAAC,CACL,CAAA;QACT,CAAC,CAAC,CAAA;QAEN,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC3B,MAAM,UAAU,GAAG,KAAK,CAAC,OAAO;iBAC3B,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE;gBACZ,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI;oBAC1B,CAAC,CAAC,MAAM,CAAC,IAAI;oBACb,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,oBAAoB,CAC/C,KAAK,EACL,MAAM,CAAC,WAAW,CACrB,CAAA;gBACP,MAAM,WAAW,GAAG,MAAM,CAAC,WAAW;qBACjC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,IAAI,UAAU,GAAG,CAAC;qBACtC,IAAI,CAAC,IAAI,CAAC,CAAA;gBACf,OAAO,eAAe,UAAU,aAAa,WAAW,GAAG,CAAA;YAC/D,CAAC,CAAC;iBACD,IAAI,CAAC,IAAI,CAAC,CAAA;YAEf,GAAG,IAAI,KAAK,UAAU,EAAE,CAAA;QAC5B,CAAC;QAED,IAAI,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC1B,MAAM,SAAS,GAAG,KAAK,CAAC,MAAM;iBACzB,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;gBACX,MAAM,SAAS,GAAG,KAAK,CAAC,IAAI;oBACxB,CAAC,CAAC,KAAK,CAAC,IAAI;oBACZ,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,mBAAmB,CAC9C,KAAK,EACL,KAAK,CAAC,UAAW,CACpB,CAAA;gBACP,OAAO,eAAe,SAAS,YAAY,KAAK,CAAC,UAAU,GAAG,CAAA;YAClE,CAAC,CAAC;iBACD,IAAI,CAAC,IAAI,CAAC,CAAA;YAEf,GAAG,IAAI,KAAK,SAAS,EAAE,CAAA;QAC3B,CAAC;QAED,IAAI,KAAK,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,IAAI,iBAAiB,EAAE,CAAC;YACpD,MAAM,cAAc,GAAG,KAAK,CAAC,WAAW;iBACnC,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE;gBACR,MAAM,WAAW,GAAG,EAAE,CAAC,WAAW;qBAC7B,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,IAAI,UAAU,GAAG,CAAC;qBACtC,IAAI,CAAC,IAAI,CAAC,CAAA;gBACf,IAAI,CAAC,EAAE,CAAC,IAAI;oBACR,EAAE,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACnD,KAAK,EACL,EAAE,CAAC,WAAW,EACd,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,EACrB,EAAE,CAAC,qBAAqB,CAC3B,CAAA;gBACL,MAAM,qBAAqB,GAAG,EAAE,CAAC,qBAAqB;qBACjD,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,IAAI,UAAU,GAAG,CAAC;qBACtC,IAAI,CAAC,IAAI,CAAC,CAAA;gBAEf,IAAI,UAAU,GAAG,eACb,EAAE,CAAC,IACP,kBAAkB,WAAW,gBAAgB,IAAI,CAAC,UAAU,CACxD,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,CACxB,KAAK,qBAAqB,GAAG,CAAA;gBAC9B,IAAI,EAAE,CAAC,QAAQ;oBAAE,UAAU,IAAI,cAAc,EAAE,CAAC,QAAQ,EAAE,CAAA;gBAC1D,IAAI,EAAE,CAAC,QAAQ;oBAAE,UAAU,IAAI,cAAc,EAAE,CAAC,QAAQ,EAAE,CAAA;gBAE1D,OAAO,UAAU,CAAA;YACrB,CAAC,CAAC;iBACD,IAAI,CAAC,IAAI,CAAC,CAAA;YAEf,GAAG,IAAI,KAAK,cAAc,EAAE,CAAA;QAChC,CAAC;QAED,MAAM,cAAc,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CACvC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,SAAS,CAC/B,CAAA;QACD,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC5B,MAAM,cAAc,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;gBAC7D,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB;gBAC5C,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,KAAK,EACL,cAAc,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAC9C,CAAA;YAEP,MAAM,WAAW,GAAG,cAAc;iBAC7B,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC;iBACnC,IAAI,CAAC,IAAI,CAAC,CAAA;YACf,GAAG,IAAI,iBAAiB,cAAc,kBAAkB,WAAW,GAAG,CAAA;QAC1E,CAAC;QAED,GAAG,IAAI,GAAG,CAAA;QAEV,OAAO,IAAI,aAAK,CAAC,GAAG,CAAC,CAAA;IACzB,CAAC;IAED;;OAEG;IACO,YAAY,CAClB,WAA2B,EAC3B,OAAiB;QAEjB,MAAM,KAAK,GAAG,OAAO;YACjB,CAAC,CAAC,wBAAwB,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,EAAE;YACxD,CAAC,CAAC,cAAc,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,EAAE,CAAA;QAClD,OAAO,IAAI,aAAK,CAAC,KAAK,CAAC,CAAA;IAC3B,CAAC;IAES,aAAa,CAAC,IAAU;QAC9B,MAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAA;QAEnD,oFAAoF;QACpF,MAAM,cAAc,GAAG,UAAU,CAAC,MAAM;YACpC,CAAC,CAAC,IAAI,UAAU,CAAC,MAAM,MAAM,UAAU,CAAC,SAAS,GAAG;YACpD,CAAC,CAAC,IAAI,UAAU,CAAC,SAAS,GAAG,CAAA;QAEjC,IAAI,OAAO,IAAI,CAAC,UAAU,KAAK,QAAQ,EAAE,CAAC;YACtC,OAAO,IAAI,aAAK,CACZ,eAAe,cAAc,OAAO,IAAI,CAAC,UAAU,EAAE,CACxD,CAAA;QACL,CAAC;aAAM,CAAC;YACJ,OAAO,IAAI,aAAK,CACZ,eAAe,cAAc,OAAO,IAAI;iBACnC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC;iBAC3B,QAAQ,EAAE,EAAE,CACpB,CAAA;QACL,CAAC;IACL,CAAC;IAES,KAAK,CAAC,uBAAuB,CAAC,IAAU;QAC9C,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAA;QAExD,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;YAC1B,eAAe,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAA;QAC1D,CAAC;QAED,MAAM,UAAU,GACZ,OAAO,IAAI,CAAC,UAAU,KAAK,QAAQ;YAC/B,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE;YACxB,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,QAAQ,EAAE,CAAA;QACrD,OAAO,IAAI,CAAC,wBAAwB,CAAC;YACjC,IAAI,EAAE,qCAAiB,CAAC,IAAI;YAC5B,QAAQ,EAAE,eAAe,CAAC,QAAQ;YAClC,MAAM,EAAE,eAAe,CAAC,MAAM;YAC9B,IAAI,EAAE,eAAe,CAAC,SAAS;YAC/B,KAAK,EAAE,UAAU;SACpB,CAAC,CAAA;IACN,CAAC;IAED;;OAEG;IACO,WAAW,CAAC,UAAyB;QAC3C,OAAO,IAAI,aAAK,CAAC,aAAa,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,CAAA;IAChE,CAAC;IAED;;OAEG;IACO,KAAK,CAAC,uBAAuB,CACnC,UAAyB;QAEzB,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,UAAU,CAAC,CAAA;QAE9D,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;YAC1B,eAAe,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAA;QAC1D,CAAC;QAED,OAAO,IAAI,CAAC,wBAAwB,CAAC;YACjC,IAAI,EAAE,qCAAiB,CAAC,IAAI;YAC5B,QAAQ,EAAE,eAAe,CAAC,QAAQ;YAClC,MAAM,EAAE,eAAe,CAAC,MAAM;YAC9B,IAAI,EAAE,eAAe,CAAC,SAAS;SAClC,CAAC,CAAA;IACN,CAAC;IAED;;OAEG;IACO,cAAc,CAAC,KAAY,EAAE,KAAiB;QACpD,MAAM,OAAO,GAAG,KAAK,CAAC,WAAW;aAC5B,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,IAAI,UAAU,GAAG,CAAC;aACtC,IAAI,CAAC,IAAI,CAAC,CAAA;QACf,OAAO,IAAI,aAAK,CACZ,UAAU,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,UACrC,KAAK,CAAC,IACV,QAAQ,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,OAAO,KACtC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAC3C,EAAE,CACL,CAAA;IACL,CAAC;IAED;;OAEG;IACO,YAAY,CAClB,KAAY,EACZ,WAAgC;QAEhC,IAAI,SAAS,GAAG,iCAAe,CAAC,YAAY,CAAC,WAAW,CAAC;YACrD,CAAC,CAAC,WAAW,CAAC,IAAI;YAClB,CAAC,CAAC,WAAW,CAAA;QACjB,OAAO,IAAI,aAAK,CACZ,eAAe,SAAS,QAAQ,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,CAC3D,CAAA;IACL,CAAC;IAED;;OAEG;IACO,mBAAmB,CACzB,KAAY,EACZ,WAAqB,EACrB,cAAuB;QAEvB,MAAM,cAAc,GAAG,cAAc;YACjC,CAAC,CAAC,cAAc;YAChB,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CAAC,KAAK,EAAE,WAAW,CAAC,CAAA;QAEvE,MAAM,iBAAiB,GAAG,WAAW;aAChC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,IAAI,UAAU,GAAG,CAAC;aACtC,IAAI,CAAC,IAAI,CAAC,CAAA;QACf,OAAO,IAAI,aAAK,CACZ,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,oBAAoB,cAAc,kBAAkB,iBAAiB,GAAG,CAC5E,CAAA;IACL,CAAC;IAED;;OAEG;IACO,iBAAiB,CAAC,KAAY;QACpC,MAAM,WAAW,GAAG,KAAK,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;QACrE,MAAM,cAAc,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,wBAAwB,CAAA;QACvE,MAAM,cAAc,GAAG,cAAc;YACjC,CAAC,CAAC,cAAc;YAChB,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CAAC,KAAK,EAAE,WAAW,CAAC,CAAA;QAEvE,OAAO,IAAI,aAAK,CACZ,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,cAAc,GAAG,CAC1C,CAAA;IACL,CAAC;IAED;;OAEG;IACO,yBAAyB,CAC/B,KAAY,EACZ,gBAA6B;QAE7B,MAAM,WAAW,GAAG,gBAAgB,CAAC,WAAW;aAC3C,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,GAAG,GAAG,MAAM,GAAG,GAAG,CAAC;aACnC,IAAI,CAAC,IAAI,CAAC,CAAA;QACf,OAAO,IAAI,aAAK,CACZ,eAAe,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,oBACjC,gBAAgB,CAAC,IACrB,aAAa,WAAW,GAAG,CAC9B,CAAA;IACL,CAAC;IAED;;OAEG;IACO,uBAAuB,CAC7B,KAAY,EACZ,YAAkC;QAElC,MAAM,UAAU,GAAG,iCAAe,CAAC,aAAa,CAAC,YAAY,CAAC;YAC1D,CAAC,CAAC,YAAY,CAAC,IAAI;YACnB,CAAC,CAAC,YAAY,CAAA;QAClB,OAAO,IAAI,aAAK,CACZ,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,UAAU,GAAG,CACtC,CAAA;IACL,CAAC;IAED;;OAEG;IACO,wBAAwB,CAC9B,KAAY,EACZ,eAA2B;QAE3B,OAAO,IAAI,aAAK,CACZ,eAAe,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,oBACjC,eAAe,CAAC,IACpB,YAAY,eAAe,CAAC,UAAU,GAAG,CAC5C,CAAA;IACL,CAAC;IAED;;OAEG;IACO,sBAAsB,CAC5B,KAAY,EACZ,WAAgC;QAEhC,MAAM,SAAS,GAAG,iCAAe,CAAC,YAAY,CAAC,WAAW,CAAC;YACvD,CAAC,CAAC,WAAW,CAAC,IAAI;YAClB,CAAC,CAAC,WAAW,CAAA;QACjB,OAAO,IAAI,aAAK,CACZ,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,SAAS,GAAG,CACrC,CAAA;IACL,CAAC;IAED;;OAEG;IACO,mBAAmB,CACzB,KAAY,EACZ,UAA2B;QAE3B,MAAM,WAAW,GAAG,UAAU,CAAC,WAAW;aACrC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,GAAG,GAAG,MAAM,GAAG,GAAG,CAAC;aACnC,IAAI,CAAC,IAAI,CAAC,CAAA;QACf,MAAM,qBAAqB,GAAG,UAAU,CAAC,qBAAqB;aACzD,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,GAAG,GAAG,MAAM,GAAG,GAAG,CAAC;aACnC,IAAI,CAAC,GAAG,CAAC,CAAA;QACd,IAAI,GAAG,GACH,eAAe,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,oBACjC,UAAU,CAAC,IACf,kBAAkB,WAAW,IAAI;YACjC,cAAc,IAAI,CAAC,UAAU,CACzB,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAChC,IAAI,qBAAqB,GAAG,CAAA;QACjC,IAAI,UAAU,CAAC,QAAQ;YAAE,GAAG,IAAI,cAAc,UAAU,CAAC,QAAQ,EAAE,CAAA;QACnE,IAAI,UAAU,CAAC,QAAQ;YAAE,GAAG,IAAI,cAAc,UAAU,CAAC,QAAQ,EAAE,CAAA;QAEnE,OAAO,IAAI,aAAK,CAAC,GAAG,CAAC,CAAA;IACzB,CAAC;IAED;;OAEG;IACO,iBAAiB,CACvB,KAAY,EACZ,gBAA0C;QAE1C,MAAM,cAAc,GAAG,iCAAe,CAAC,iBAAiB,CACpD,gBAAgB,CACnB;YACG,CAAC,CAAC,gBAAgB,CAAC,IAAI;YACvB,CAAC,CAAC,gBAAgB,CAAA;QACtB,OAAO,IAAI,aAAK,CACZ,eAAe,IAAI,CAAC,UAAU,CAC1B,KAAK,CACR,qBAAqB,cAAc,GAAG,CAC1C,CAAA;IACL,CAAC;IAED;;OAEG;IACO,UAAU,CAAC,MAA6B;QAC9C,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,GACjC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA;QAEtC,IAAI,QAAQ,IAAI,QAAQ,KAAK,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;YAChD,IAAI,MAAM,IAAI,MAAM,KAAK,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC;gBAChD,OAAO,IAAI,QAAQ,MAAM,MAAM,MAAM,SAAS,GAAG,CAAA;YACrD,CAAC;YAED,OAAO,IAAI,QAAQ,OAAO,SAAS,GAAG,CAAA;QAC1C,CAAC;QAED,IAAI,MAAM,IAAI,MAAM,KAAK,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC;YAChD,OAAO,IAAI,MAAM,MAAM,SAAS,GAAG,CAAA;QACvC,CAAC;QAED,OAAO,IAAI,SAAS,GAAG,CAAA;IAC3B,CAAC;IAED;;;OAGG;IACO,mBAAmB,CACzB,MAAc,EACd,UAA8B,EAC9B,MAA0B;QAE1B,IAAI,YAAY,GAAG,MAAM,CAAA;QACzB,IAAI,UAAU,IAAI,UAAU,KAAK,IAAI,CAAC,MAAM,CAAC,YAAY;YACrD,YAAY,GAAG,UAAU,GAAG,GAAG,GAAG,YAAY,CAAA;QAClD,IAAI,MAAM,IAAI,MAAM,KAAK,IAAI,CAAC,MAAM,CAAC,QAAQ;YACzC,YAAY,GAAG,MAAM,GAAG,GAAG,GAAG,YAAY,CAAA;QAE9C,OAAO,YAAY,CAAA;IACvB,CAAC;IAED;;;;;;OAMG;IACO,4BAA4B,CAAC,YAAoB;QACvD,IAAI,YAAY,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG;YAAE,OAAO,YAAY,CAAA;QAC1D,MAAM,iBAAiB,GAAG,YAAY,CAAC,MAAM,CACzC,CAAC,EACD,YAAY,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CACpC,CAAA;QACD,OAAO,IAAI,CAAC,4BAA4B,CAAC,iBAAiB,CAAC,CAAA;IAC/D,CAAC;IAED;;OAEG;IACO,oBAAoB,CAC1B,KAAY,EACZ,MAAmB,EACnB,YAAqB,EACrB,aAAsB,EACtB,QAAkB;QAElB,IAAI,CAAC,GAAG,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,cAAc,CAC7D,MAAM,CACT,EAAE,CAAA;QAEH,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,IAAI,EAAE,CAAC;YAC3B,MAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAA;YACjD,MAAM,SAAS,GACX,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,mBAAmB,CAC9C,KAAK,EACL,UAAU,EACV,IAAI,CACP,CAAA;YACL,CAAC,IAAI,eAAe,SAAS,UAAU,UAAU,GAAG,CAAA;QACxD,CAAC;QAED,IAAI,MAAM,CAAC,SAAS;YAAE,CAAC,IAAI,WAAW,GAAG,MAAM,CAAC,SAAS,CAAA;QAEzD,IAAI,MAAM,CAAC,YAAY,EAAE,CAAC;YACtB,CAAC,IAAI,QAAQ,MAAM,CAAC,YAAY,GAAG,CAAA;YACnC,IAAI,MAAM,CAAC,aAAa,KAAK,QAAQ,EAAE,CAAC;gBACpC,CAAC,IAAI,YAAY,CAAA;gBAEjB,qFAAqF;gBACrF,IAAI,MAAM,CAAC,UAAU,KAAK,IAAI;oBAAE,CAAC,IAAI,WAAW,CAAA;YACpD,CAAC;QACL,CAAC;aAAM,CAAC;YACJ,IAAI,MAAM,CAAC,UAAU,KAAK,IAAI;gBAAE,CAAC,IAAI,WAAW,CAAA;QACpD,CAAC;QAED,IACI,MAAM,CAAC,WAAW,KAAK,IAAI;YAC3B,MAAM,CAAC,kBAAkB,KAAK,WAAW;YACzC,CAAC,YAAY;YAEb,8FAA8F;YAC9F,CAAC,IAAI,gBAAgB,CAAA;QAEzB,IACI,MAAM,CAAC,OAAO,KAAK,SAAS;YAC5B,MAAM,CAAC,OAAO,KAAK,IAAI;YACvB,aAAa,EACf,CAAC;YACC,2FAA2F;YAC3F,MAAM,WAAW,GACb,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,qBAAqB,CAChD,KAAK,EACL,MAAM,CAAC,IAAI,CACd,CAAA;YACL,CAAC,IAAI,gBAAgB,WAAW,aAAa,MAAM,CAAC,OAAO,EAAE,CAAA;QACjE,CAAC;QAED,IACI,MAAM,CAAC,WAAW;YAClB,MAAM,CAAC,kBAAkB,KAAK,MAAM;YACpC,CAAC,MAAM,CAAC,OAAO,EACjB,CAAC;YACC,2FAA2F;YAC3F,MAAM,WAAW,GACb,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,qBAAqB,CAChD,KAAK,EACL,MAAM,CAAC,IAAI,CACd,CAAA;YACL,CAAC,IAAI,gBAAgB,WAAW,6BAA6B,CAAA;QACjE,CAAC;QACD,OAAO,CAAC,CAAA;IACZ,CAAC;IAEO,iBAAiB,CAAC,MAAmB;QACzC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;YACf,MAAM,IAAI,KAAK,CAAC,iCAAiC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAA;QACnE,CAAC;QACD,OAAO,CACH,MAAM,CAAC,IAAI;YACX,OAAO;YACP,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;YACnD,GAAG,CACN,CAAA;IACL,CAAC;IAES,qBAAqB,CAAC,IAAY;QACxC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAA;IACtE,CAAC;IAED;;OAEG;IACO,+BAA+B,CAAC,SAAyB;QAC/D,QAAQ,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,IAAI,EAAE,SAAS,CAAC,IAAW,EAAE,CAAC,EAAE,CAAC;YACjE,KAAK,KAAK;gBACN,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAA;YAChC,KAAK,QAAQ;gBACT,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAA;YACnC,KAAK,SAAS;gBACV,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;YACzD,KAAK,OAAO;gBACR,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAA;YAClC,KAAK,KAAK;gBACN,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAA;YAChC,KAAK,OAAO;gBACR,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAA;YAClC,KAAK,SAAS;gBACV,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;YACzD,KAAK,UAAU;gBACX,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAA;YACrC,KAAK,YAAY;gBACb,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAA;YACvC,KAAK,MAAM;gBACP,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAA;YACjC,KAAK,SAAS;gBACV,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAA;YACpC,KAAK,MAAM;gBACP,IACI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO;oBACvB,EAAE,oCAAoC,EAC5C,CAAC;oBACC,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;gBACtD,CAAC;gBACD,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;YACvD,KAAK,OAAO;gBACR,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;YACvD,KAAK,MAAM;gBACP,IACI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO;oBACvB,EAAE,oCAAoC,EAC5C,CAAC;oBACC,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAA;gBACjC,CAAC;gBACD,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAA;YAClC,KAAK,OAAO;gBACR,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAA;YAClC,KAAK,SAAS;gBACV,IACI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO;oBACvB,EAAE,oCAAoC,EAC5C,CAAC;oBACC,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;gBACzD,CAAC;gBACD,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;YAC1D,KAAK,UAAU;gBACX,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;YAC1D,KAAK,KAAK;gBACN,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAA;YAChC,KAAK,MAAM;gBACP,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;YACtD,KAAK,MAAM;gBACP,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAA;YACjC,KAAK,UAAU;gBACX,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAA;YACrC,KAAK,WAAW;gBACZ,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;YAC3D,KAAK,gBAAgB;gBACjB,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;YAChE,KAAK,eAAe;gBAChB,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAA;YAC1C,KAAK,kBAAkB;gBACnB,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,gBAAgB,CAAA;YAC7C,KAAK,SAAS;gBACV,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAA;YACpC,KAAK,QAAQ;gBACT,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAA;YACnC,KAAK,WAAW;gBACZ,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;YAC3D,KAAK,OAAO;gBACR,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAA;YAClC,KAAK,KAAK;gBACN,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAA;YAChC,KAAK,YAAY;gBACb,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAA;QAC3C,CAAC;IACL,CAAC;IAED;;;OAGG;IACH,qBAAqB,CAAC,SAAyB;QAC3C,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,eAAe,CAAA;QACzD,QAAQ,SAAS,EAAE,CAAC;YAChB,KAAK,kBAAkB;gBACnB,OAAO,eAAe,CAAC,gBAAgB,CAAA;YAC3C,KAAK,iBAAiB;gBAClB,OAAO,eAAe,CAAC,eAAe,CAAA;YAC1C,KAAK,cAAc;gBACf,OAAO,eAAe,CAAC,YAAY,CAAA;YAEvC,KAAK,gBAAgB,CAAC;YACtB;gBACI,OAAO,eAAe,CAAC,cAAc,CAAA;QAC7C,CAAC;IACL,CAAC;IAED;;OAEG;IACH,kBAAkB,CACd,WAA2B,EAC3B,OAAgB;QAEhB,MAAM,IAAI,oBAAY,CAClB,yDAAyD,CAC5D,CAAA;IACL,CAAC;CACJ;AA7iID,oDA6iIC","file":"SqlServerQueryRunner.js","sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { ReadStream } from \"../../platform/PlatformTools\"\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { TableIndexOptions } from \"../../schema-builder/options/TableIndexOptions\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\"\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { Query } from \"../Query\"\nimport { IsolationLevel } from \"../types/IsolationLevel\"\nimport { MssqlParameter } from \"./MssqlParameter\"\nimport { SqlServerDriver } from \"./SqlServerDriver\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { TypeORMError } from \"../../error\"\nimport { QueryLock } from \"../../query-runner/QueryLock\"\nimport { MetadataTableType } from \"../types/MetadataTableType\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\"\n\n/**\n * Runs queries on a single SQL Server database connection.\n */\nexport class SqlServerQueryRunner\n    extends BaseQueryRunner\n    implements QueryRunner\n{\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: SqlServerDriver\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private lock: QueryLock = new QueryLock()\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: SqlServerDriver, mode: ReplicationMode) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.broadcaster = new Broadcaster(this)\n        this.mode = mode\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    connect(): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Releases used database connection.\n     * You cannot use query runner methods once its released.\n     */\n    release(): Promise<void> {\n        this.isReleased = true\n        return Promise.resolve()\n    }\n\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n        await new Promise<void>(async (ok, fail) => {\n            const transactionCallback = (err: any) => {\n                if (err) {\n                    this.isTransactionActive = false\n                    return fail(err)\n                }\n                ok()\n            }\n\n            if (this.transactionDepth === 0) {\n                this.transactionDepth += 1\n                const pool = await (this.mode === \"slave\"\n                    ? this.driver.obtainSlaveConnection()\n                    : this.driver.obtainMasterConnection())\n                this.databaseConnection = pool.transaction()\n                this.connection.logger.logQuery(\"BEGIN TRANSACTION\")\n                if (isolationLevel) {\n                    this.databaseConnection.begin(\n                        this.convertIsolationLevel(isolationLevel),\n                        transactionCallback,\n                    )\n                    this.connection.logger.logQuery(\n                        \"SET TRANSACTION ISOLATION LEVEL \" + isolationLevel,\n                    )\n                } else {\n                    this.databaseConnection.begin(transactionCallback)\n                }\n            } else {\n                this.transactionDepth += 1\n                await this.query(\n                    `SAVE TRANSACTION typeorm_${this.transactionDepth - 1}`,\n                )\n                ok()\n            }\n        })\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        if (this.transactionDepth === 1) {\n            return new Promise<void>((ok, fail) => {\n                this.transactionDepth -= 1\n                this.databaseConnection.commit(async (err: any) => {\n                    if (err) return fail(err)\n                    this.isTransactionActive = false\n                    this.databaseConnection = null\n\n                    await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n\n                    ok()\n                    this.connection.logger.logQuery(\"COMMIT\")\n                })\n            })\n        }\n        this.transactionDepth -= 1\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        if (this.transactionDepth > 1) {\n            this.transactionDepth -= 1\n            await this.query(\n                `ROLLBACK TRANSACTION typeorm_${this.transactionDepth}`,\n            )\n        } else {\n            return new Promise<void>((ok, fail) => {\n                this.transactionDepth -= 1\n                this.databaseConnection.rollback(async (err: any) => {\n                    if (err) return fail(err)\n                    this.isTransactionActive = false\n                    this.databaseConnection = null\n\n                    await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n\n                    ok()\n                    this.connection.logger.logQuery(\"ROLLBACK\")\n                })\n            })\n        }\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const release = await this.lock.acquire()\n\n        const broadcasterResult = new BroadcasterResult()\n\n        try {\n            this.driver.connection.logger.logQuery(query, parameters, this)\n            this.broadcaster.broadcastBeforeQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n            )\n\n            const pool = await (this.mode === \"slave\"\n                ? this.driver.obtainSlaveConnection()\n                : this.driver.obtainMasterConnection())\n            const request = new this.driver.mssql.Request(\n                this.isTransactionActive ? this.databaseConnection : pool,\n            )\n            if (parameters && parameters.length) {\n                parameters.forEach((parameter, index) => {\n                    const parameterName = index.toString()\n                    if (InstanceChecker.isMssqlParameter(parameter)) {\n                        const mssqlParameter =\n                            this.mssqlParameterToNativeParameter(parameter)\n                        if (mssqlParameter) {\n                            request.input(\n                                parameterName,\n                                mssqlParameter,\n                                parameter.value,\n                            )\n                        } else {\n                            request.input(parameterName, parameter.value)\n                        }\n                    } else {\n                        request.input(parameterName, parameter)\n                    }\n                })\n            }\n            const queryStartTime = +new Date()\n\n            const raw = await new Promise<any>((ok, fail) => {\n                request.query(query, (err: any, raw: any) => {\n                    // log slow queries if maxQueryExecution time is set\n                    const maxQueryExecutionTime =\n                        this.driver.options.maxQueryExecutionTime\n                    const queryEndTime = +new Date()\n                    const queryExecutionTime = queryEndTime - queryStartTime\n\n                    this.broadcaster.broadcastAfterQueryEvent(\n                        broadcasterResult,\n                        query,\n                        parameters,\n                        true,\n                        queryExecutionTime,\n                        raw,\n                        undefined,\n                    )\n\n                    if (\n                        maxQueryExecutionTime &&\n                        queryExecutionTime > maxQueryExecutionTime\n                    ) {\n                        this.driver.connection.logger.logQuerySlow(\n                            queryExecutionTime,\n                            query,\n                            parameters,\n                            this,\n                        )\n                    }\n\n                    if (err) {\n                        fail(new QueryFailedError(query, parameters, err))\n                    }\n\n                    ok(raw)\n                })\n            })\n\n            const result = new QueryResult()\n\n            if (raw?.hasOwnProperty(\"recordset\")) {\n                result.records = raw.recordset\n            }\n\n            if (raw?.hasOwnProperty(\"rowsAffected\")) {\n                result.affected = raw.rowsAffected[0]\n            }\n\n            const queryType = query.slice(0, query.indexOf(\" \"))\n            switch (queryType) {\n                case \"DELETE\":\n                    // for DELETE query additionally return number of affected rows\n                    result.raw = [raw.recordset, raw.rowsAffected[0]]\n                    break\n                default:\n                    result.raw = raw.recordset\n            }\n\n            if (useStructuredResult) {\n                return result\n            } else {\n                return result.raw\n            }\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            this.broadcaster.broadcastAfterQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n                false,\n                undefined,\n                undefined,\n                err,\n            )\n\n            throw err\n        } finally {\n            await broadcasterResult.wait()\n\n            release()\n        }\n    }\n\n    /**\n     * Returns raw data stream.\n     */\n    async stream(\n        query: string,\n        parameters?: any[],\n        onEnd?: Function,\n        onError?: Function,\n    ): Promise<ReadStream> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const release = await this.lock.acquire()\n\n        this.driver.connection.logger.logQuery(query, parameters, this)\n        const pool = await (this.mode === \"slave\"\n            ? this.driver.obtainSlaveConnection()\n            : this.driver.obtainMasterConnection())\n        const request = new this.driver.mssql.Request(\n            this.isTransactionActive ? this.databaseConnection : pool,\n        )\n        if (parameters && parameters.length) {\n            parameters.forEach((parameter, index) => {\n                const parameterName = index.toString()\n                if (InstanceChecker.isMssqlParameter(parameter)) {\n                    request.input(\n                        parameterName,\n                        this.mssqlParameterToNativeParameter(parameter),\n                        parameter.value,\n                    )\n                } else {\n                    request.input(parameterName, parameter)\n                }\n            })\n        }\n\n        request.query(query)\n\n        const streamRequest = request.toReadableStream()\n\n        streamRequest.on(\"error\", (err: any) => {\n            release()\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n        })\n\n        streamRequest.on(\"end\", () => {\n            release()\n        })\n\n        if (onEnd) {\n            streamRequest.on(\"end\", onEnd)\n        }\n\n        if (onError) {\n            streamRequest.on(\"error\", onError)\n        }\n\n        return streamRequest\n    }\n\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases(): Promise<string[]> {\n        const results: ObjectLiteral[] = await this.query(`EXEC sp_databases`)\n        return results.map((result) => result[\"DATABASE_NAME\"])\n    }\n\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database?: string): Promise<string[]> {\n        const query = database\n            ? `SELECT * FROM \"${database}\".\"sys\".\"schema\"`\n            : `SELECT * FROM \"sys\".\"schemas\"`\n        const results: ObjectLiteral[] = await this.query(query)\n        return results.map((result) => result[\"name\"])\n    }\n\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database: string): Promise<boolean> {\n        const result = await this.query(\n            `SELECT DB_ID('${database}') as \"db_id\"`,\n        )\n        const dbId = result[0][\"db_id\"]\n        return !!dbId\n    }\n\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase(): Promise<string> {\n        const currentDBQuery = await this.query(`SELECT DB_NAME() AS \"db_name\"`)\n        return currentDBQuery[0][\"db_name\"]\n    }\n\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema: string): Promise<boolean> {\n        const result = await this.query(\n            `SELECT SCHEMA_ID('${schema}') as \"schema_id\"`,\n        )\n        const schemaId = result[0][\"schema_id\"]\n        return !!schemaId\n    }\n\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema(): Promise<string> {\n        const currentSchemaQuery = await this.query(\n            `SELECT SCHEMA_NAME() AS \"schema_name\"`,\n        )\n        return currentSchemaQuery[0][\"schema_name\"]\n    }\n\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName: Table | string): Promise<boolean> {\n        const parsedTableName = this.driver.parseTableName(tableOrName)\n\n        if (!parsedTableName.database) {\n            parsedTableName.database = await this.getCurrentDatabase()\n        }\n\n        if (!parsedTableName.schema) {\n            parsedTableName.schema = await this.getCurrentSchema()\n        }\n\n        const sql = `SELECT * FROM \"${parsedTableName.database}\".\"INFORMATION_SCHEMA\".\"TABLES\" WHERE \"TABLE_NAME\" = '${parsedTableName.tableName}' AND \"TABLE_SCHEMA\" = '${parsedTableName.schema}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Checks if column exist in the table.\n     */\n    async hasColumn(\n        tableOrName: Table | string,\n        columnName: string,\n    ): Promise<boolean> {\n        const parsedTableName = this.driver.parseTableName(tableOrName)\n\n        if (!parsedTableName.database) {\n            parsedTableName.database = await this.getCurrentDatabase()\n        }\n\n        if (!parsedTableName.schema) {\n            parsedTableName.schema = await this.getCurrentSchema()\n        }\n\n        const sql = `SELECT * FROM \"${parsedTableName.database}\".\"INFORMATION_SCHEMA\".\"COLUMNS\" WHERE \"TABLE_NAME\" = '${parsedTableName.tableName}' AND \"TABLE_SCHEMA\" = '${parsedTableName.schema}' AND \"COLUMN_NAME\" = '${columnName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Creates a new database.\n     */\n    async createDatabase(\n        database: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        const up = ifNotExist\n            ? `IF DB_ID('${database}') IS NULL CREATE DATABASE \"${database}\"`\n            : `CREATE DATABASE \"${database}\"`\n        const down = `DROP DATABASE \"${database}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Drops database.\n     */\n    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {\n        const up = ifExist\n            ? `IF DB_ID('${database}') IS NOT NULL DROP DATABASE \"${database}\"`\n            : `DROP DATABASE \"${database}\"`\n        const down = `CREATE DATABASE \"${database}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Creates table schema.\n     * If database name also specified (e.g. 'dbName.schemaName') schema will be created in specified database.\n     */\n    async createSchema(\n        schemaPath: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (schemaPath.indexOf(\".\") === -1) {\n            const upQuery = ifNotExist\n                ? `IF SCHEMA_ID('${schemaPath}') IS NULL BEGIN EXEC ('CREATE SCHEMA \"${schemaPath}\"') END`\n                : `CREATE SCHEMA \"${schemaPath}\"`\n            upQueries.push(new Query(upQuery))\n            downQueries.push(new Query(`DROP SCHEMA \"${schemaPath}\"`))\n        } else {\n            const dbName = schemaPath.split(\".\")[0]\n            const schema = schemaPath.split(\".\")[1]\n            const currentDB = await this.getCurrentDatabase()\n            upQueries.push(new Query(`USE \"${dbName}\"`))\n            downQueries.push(new Query(`USE \"${currentDB}\"`))\n\n            const upQuery = ifNotExist\n                ? `IF SCHEMA_ID('${schema}') IS NULL BEGIN EXEC ('CREATE SCHEMA \"${schema}\"') END`\n                : `CREATE SCHEMA \"${schema}\"`\n            upQueries.push(new Query(upQuery))\n            downQueries.push(new Query(`DROP SCHEMA \"${schema}\"`))\n\n            upQueries.push(new Query(`USE \"${currentDB}\"`))\n            downQueries.push(new Query(`USE \"${dbName}\"`))\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops table schema.\n     * If database name also specified (e.g. 'dbName.schemaName') schema will be dropped in specified database.\n     */\n    async dropSchema(schemaPath: string, ifExist?: boolean): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (schemaPath.indexOf(\".\") === -1) {\n            const upQuery = ifExist\n                ? `IF SCHEMA_ID('${schemaPath}') IS NULL BEGIN EXEC ('DROP SCHEMA \"${schemaPath}\"') END`\n                : `DROP SCHEMA \"${schemaPath}\"`\n            upQueries.push(new Query(upQuery))\n            downQueries.push(new Query(`CREATE SCHEMA \"${schemaPath}\"`))\n        } else {\n            const dbName = schemaPath.split(\".\")[0]\n            const schema = schemaPath.split(\".\")[1]\n            const currentDB = await this.getCurrentDatabase()\n            upQueries.push(new Query(`USE \"${dbName}\"`))\n            downQueries.push(new Query(`USE \"${currentDB}\"`))\n\n            const upQuery = ifExist\n                ? `IF SCHEMA_ID('${schema}') IS NULL BEGIN EXEC ('DROP SCHEMA \"${schema}\"') END`\n                : `DROP SCHEMA \"${schema}\"`\n            upQueries.push(new Query(upQuery))\n            downQueries.push(new Query(`CREATE SCHEMA \"${schema}\"`))\n\n            upQueries.push(new Query(`USE \"${currentDB}\"`))\n            downQueries.push(new Query(`USE \"${dbName}\"`))\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new table.\n     */\n    async createTable(\n        table: Table,\n        ifNotExist: boolean = false,\n        createForeignKeys: boolean = true,\n        createIndices: boolean = true,\n    ): Promise<void> {\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table)\n            if (isTableExist) return Promise.resolve()\n        }\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        upQueries.push(this.createTableSql(table, createForeignKeys))\n        downQueries.push(this.dropTableSql(table))\n\n        // if createForeignKeys is true, we must drop created foreign keys in down query.\n        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n        if (createForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                downQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        if (createIndices) {\n            table.indices.forEach((index) => {\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name)\n                    index.name = this.connection.namingStrategy.indexName(\n                        table,\n                        index.columnNames,\n                        index.where,\n                    )\n                upQueries.push(this.createIndexSql(table, index))\n                downQueries.push(this.dropIndexSql(table, index))\n            })\n        }\n\n        // if table have column with generated type, we must add the expression to the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n\n        for (const column of generatedColumns) {\n            const parsedTableName = this.driver.parseTableName(table)\n\n            if (!parsedTableName.schema) {\n                parsedTableName.schema = await this.getCurrentSchema()\n            }\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: parsedTableName.database,\n                schema: parsedTableName.schema,\n                table: parsedTableName.tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: parsedTableName.database,\n                schema: parsedTableName.schema,\n                table: parsedTableName.tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the table.\n     */\n    async dropTable(\n        tableOrName: Table | string,\n        ifExist?: boolean,\n        dropForeignKeys: boolean = true,\n        dropIndices: boolean = true,\n    ): Promise<void> {\n        if (ifExist) {\n            const isTableExist = await this.hasTable(tableOrName)\n            if (!isTableExist) return Promise.resolve()\n        }\n\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys: boolean = dropForeignKeys\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n        // to perform drop queries for foreign keys and indices.\n\n        if (dropIndices) {\n            table.indices.forEach((index) => {\n                upQueries.push(this.dropIndexSql(table, index))\n                downQueries.push(this.createIndexSql(table, index))\n            })\n        }\n\n        // if dropForeignKeys is true, we just drop the table, otherwise we also drop table foreign keys.\n        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n        if (dropForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                upQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        upQueries.push(this.dropTableSql(table))\n        downQueries.push(this.createTableSql(table, createForeignKeys))\n\n        // if table had columns with generated type, we must remove the expression from the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n\n        for (const column of generatedColumns) {\n            const parsedTableName = this.driver.parseTableName(table)\n\n            if (!parsedTableName.schema) {\n                parsedTableName.schema = await this.getCurrentSchema()\n            }\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: parsedTableName.database,\n                schema: parsedTableName.schema,\n                table: parsedTableName.tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: parsedTableName.database,\n                schema: parsedTableName.schema,\n                table: parsedTableName.tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new view.\n     */\n    async createView(\n        view: View,\n        syncWithMetadata: boolean = false,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(this.createViewSql(view))\n        if (syncWithMetadata)\n            upQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.dropViewSql(view))\n        if (syncWithMetadata)\n            downQueries.push(await this.deleteViewDefinitionSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the view.\n     */\n    async dropView(target: View | string): Promise<void> {\n        const viewName = InstanceChecker.isView(target) ? target.name : target\n        const view = await this.getCachedView(viewName)\n\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(await this.deleteViewDefinitionSql(view))\n        upQueries.push(this.dropViewSql(view))\n        downQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.createViewSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Renames a table.\n     */\n    async renameTable(\n        oldTableOrName: Table | string,\n        newTableName: string,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        const oldTable = InstanceChecker.isTable(oldTableOrName)\n            ? oldTableOrName\n            : await this.getCachedTable(oldTableOrName)\n        let newTable = oldTable.clone()\n\n        // we need database name and schema name to rename FK constraints\n        let dbName: string | undefined = undefined\n        let schemaName: string | undefined = undefined\n        let oldTableName: string = oldTable.name\n        const splittedName = oldTable.name.split(\".\")\n        if (splittedName.length === 3) {\n            dbName = splittedName[0]\n            oldTableName = splittedName[2]\n            if (splittedName[1] !== \"\") schemaName = splittedName[1]\n        } else if (splittedName.length === 2) {\n            schemaName = splittedName[0]\n            oldTableName = splittedName[1]\n        }\n\n        newTable.name = this.driver.buildTableName(\n            newTableName,\n            schemaName,\n            dbName,\n        )\n\n        // if we have tables with database which differs from database specified in config, we must change currently used database.\n        // This need because we can not rename objects from another database.\n        const currentDB = await this.getCurrentDatabase()\n        if (dbName && dbName !== currentDB) {\n            upQueries.push(new Query(`USE \"${dbName}\"`))\n            downQueries.push(new Query(`USE \"${currentDB}\"`))\n        }\n\n        // rename table\n        upQueries.push(\n            new Query(\n                `EXEC sp_rename \"${this.getTablePath(\n                    oldTable,\n                )}\", \"${newTableName}\"`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `EXEC sp_rename \"${this.getTablePath(\n                    newTable,\n                )}\", \"${oldTableName}\"`,\n            ),\n        )\n\n        // rename primary key constraint\n        if (\n            newTable.primaryColumns.length > 0 &&\n            !newTable.primaryColumns[0].primaryKeyConstraintName\n        ) {\n            const columnNames = newTable.primaryColumns.map(\n                (column) => column.name,\n            )\n\n            const oldPkName = this.connection.namingStrategy.primaryKeyName(\n                oldTable,\n                columnNames,\n            )\n            const newPkName = this.connection.namingStrategy.primaryKeyName(\n                newTable,\n                columnNames,\n            )\n\n            // rename primary constraint\n            upQueries.push(\n                new Query(\n                    `EXEC sp_rename \"${this.getTablePath(\n                        newTable,\n                    )}.${oldPkName}\", \"${newPkName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `EXEC sp_rename \"${this.getTablePath(\n                        newTable,\n                    )}.${newPkName}\", \"${oldPkName}\"`,\n                ),\n            )\n        }\n\n        // rename unique constraints\n        newTable.uniques.forEach((unique) => {\n            const oldUniqueName =\n                this.connection.namingStrategy.uniqueConstraintName(\n                    oldTable,\n                    unique.columnNames,\n                )\n\n            // Skip renaming if Unique has user defined constraint name\n            if (unique.name !== oldUniqueName) return\n\n            // build new constraint name\n            const newUniqueName =\n                this.connection.namingStrategy.uniqueConstraintName(\n                    newTable,\n                    unique.columnNames,\n                )\n\n            // build queries\n            upQueries.push(\n                new Query(\n                    `EXEC sp_rename \"${this.getTablePath(newTable)}.${\n                        unique.name\n                    }\", \"${newUniqueName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `EXEC sp_rename \"${this.getTablePath(\n                        newTable,\n                    )}.${newUniqueName}\", \"${unique.name}\"`,\n                ),\n            )\n\n            // replace constraint name\n            unique.name = newUniqueName\n        })\n\n        // rename index constraints\n        newTable.indices.forEach((index) => {\n            const oldIndexName = this.connection.namingStrategy.indexName(\n                oldTable,\n                index.columnNames,\n                index.where,\n            )\n\n            // Skip renaming if Index has user defined constraint name\n            if (index.name !== oldIndexName) return\n\n            // build new constraint name\n            const newIndexName = this.connection.namingStrategy.indexName(\n                newTable,\n                index.columnNames,\n                index.where,\n            )\n\n            // build queries\n            upQueries.push(\n                new Query(\n                    `EXEC sp_rename \"${this.getTablePath(newTable)}.${\n                        index.name\n                    }\", \"${newIndexName}\", \"INDEX\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `EXEC sp_rename \"${this.getTablePath(\n                        newTable,\n                    )}.${newIndexName}\", \"${index.name}\", \"INDEX\"`,\n                ),\n            )\n\n            // replace constraint name\n            index.name = newIndexName\n        })\n\n        // rename foreign key constraints\n        newTable.foreignKeys.forEach((foreignKey) => {\n            const oldForeignKeyName =\n                this.connection.namingStrategy.foreignKeyName(\n                    oldTable,\n                    foreignKey.columnNames,\n                    this.getTablePath(foreignKey),\n                    foreignKey.referencedColumnNames,\n                )\n\n            // Skip renaming if foreign key has user defined constraint name\n            if (foreignKey.name !== oldForeignKeyName) return\n\n            // build new constraint name\n            const newForeignKeyName =\n                this.connection.namingStrategy.foreignKeyName(\n                    newTable,\n                    foreignKey.columnNames,\n                    this.getTablePath(foreignKey),\n                    foreignKey.referencedColumnNames,\n                )\n\n            // build queries\n            upQueries.push(\n                new Query(\n                    `EXEC sp_rename \"${this.buildForeignKeyName(\n                        foreignKey.name!,\n                        schemaName,\n                        dbName,\n                    )}\", \"${newForeignKeyName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `EXEC sp_rename \"${this.buildForeignKeyName(\n                        newForeignKeyName,\n                        schemaName,\n                        dbName,\n                    )}\", \"${foreignKey.name}\"`,\n                ),\n            )\n\n            // replace constraint name\n            foreignKey.name = newForeignKeyName\n        })\n\n        // change currently used database back to default db.\n        if (dbName && dbName !== currentDB) {\n            upQueries.push(new Query(`USE \"${currentDB}\"`))\n            downQueries.push(new Query(`USE \"${dbName}\"`))\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        // rename old table and replace it in cached tabled;\n        oldTable.name = newTable.name\n        this.replaceCachedTable(oldTable, newTable)\n    }\n\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(\n        tableOrName: Table | string,\n        column: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(\n                    table,\n                    column,\n                    false,\n                    true,\n                )}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${\n                    column.name\n                }\"`,\n            ),\n        )\n\n        // create or update primary key constraint\n        if (column.isPrimary) {\n            const primaryColumns = clonedTable.primaryColumns\n            // if table already have primary key, me must drop it and recreate again\n            if (primaryColumns.length > 0) {\n                const pkName = primaryColumns[0].primaryKeyConstraintName\n                    ? primaryColumns[0].primaryKeyConstraintName\n                    : this.connection.namingStrategy.primaryKeyName(\n                          clonedTable,\n                          primaryColumns.map((column) => column.name),\n                      )\n\n                const columnNames = primaryColumns\n                    .map((column) => `\"${column.name}\"`)\n                    .join(\", \")\n\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            table,\n                        )} DROP CONSTRAINT \"${pkName}\"`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            table,\n                        )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                    ),\n                )\n            }\n\n            primaryColumns.push(column)\n            const pkName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      clonedTable,\n                      primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNames = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \")\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} DROP CONSTRAINT \"${pkName}\"`,\n                ),\n            )\n        }\n\n        // create column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            upQueries.push(this.createIndexSql(table, columnIndex))\n            downQueries.push(this.dropIndexSql(table, columnIndex))\n        }\n\n        // create unique constraint\n        if (column.isUnique) {\n            const uniqueConstraint = new TableUnique({\n                name: this.connection.namingStrategy.uniqueConstraintName(\n                    table,\n                    [column.name],\n                ),\n                columnNames: [column.name],\n            })\n            clonedTable.uniques.push(uniqueConstraint)\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                        uniqueConstraint.name\n                    }\" UNIQUE (\"${column.name}\")`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${\n                        uniqueConstraint.name\n                    }\"`,\n                ),\n            )\n        }\n\n        // remove default constraint\n        if (column.default !== null && column.default !== undefined) {\n            const defaultName =\n                this.connection.namingStrategy.defaultConstraintName(\n                    table,\n                    column.name,\n                )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} DROP CONSTRAINT \"${defaultName}\"`,\n                ),\n            )\n        }\n\n        if (column.generatedType && column.asExpression) {\n            const parsedTableName = this.driver.parseTableName(table)\n\n            if (!parsedTableName.schema) {\n                parsedTableName.schema = await this.getCurrentSchema()\n            }\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: parsedTableName.database,\n                schema: parsedTableName.schema,\n                table: parsedTableName.tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: parsedTableName.database,\n                schema: parsedTableName.schema,\n                table: parsedTableName.tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.addColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.addColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newTableColumnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        let newColumn: TableColumn | undefined = undefined\n        if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n            newColumn = newTableColumnOrName\n        } else {\n            newColumn = oldColumn.clone()\n            newColumn.name = newTableColumnOrName\n        }\n\n        await this.changeColumn(table, oldColumn, newColumn)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newColumn: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        let clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find(\n                  (column) => column.name === oldTableColumnOrName,\n              )\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        if (\n            (newColumn.isGenerated !== oldColumn.isGenerated &&\n                newColumn.generationStrategy !== \"uuid\") ||\n            newColumn.type !== oldColumn.type ||\n            newColumn.length !== oldColumn.length ||\n            newColumn.asExpression !== oldColumn.asExpression ||\n            newColumn.generatedType !== oldColumn.generatedType\n        ) {\n            // SQL Server does not support changing of IDENTITY column, so we must drop column and recreate it again.\n            // Also, we recreate column if column type changed\n            await this.dropColumn(table, oldColumn)\n            await this.addColumn(table, newColumn)\n\n            // update cloned table\n            clonedTable = table.clone()\n        } else {\n            if (newColumn.name !== oldColumn.name) {\n                // we need database name and schema name to rename FK constraints\n                let dbName: string | undefined = undefined\n                let schemaName: string | undefined = undefined\n                const splittedName = table.name.split(\".\")\n                if (splittedName.length === 3) {\n                    dbName = splittedName[0]\n                    if (splittedName[1] !== \"\") schemaName = splittedName[1]\n                } else if (splittedName.length === 2) {\n                    schemaName = splittedName[0]\n                }\n\n                // if we have tables with database which differs from database specified in config, we must change currently used database.\n                // This need because we can not rename objects from another database.\n                const currentDB = await this.getCurrentDatabase()\n                if (dbName && dbName !== currentDB) {\n                    upQueries.push(new Query(`USE \"${dbName}\"`))\n                    downQueries.push(new Query(`USE \"${currentDB}\"`))\n                }\n\n                // rename the column\n                upQueries.push(\n                    new Query(\n                        `EXEC sp_rename \"${this.getTablePath(table)}.${\n                            oldColumn.name\n                        }\", \"${newColumn.name}\"`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `EXEC sp_rename \"${this.getTablePath(table)}.${\n                            newColumn.name\n                        }\", \"${oldColumn.name}\"`,\n                    ),\n                )\n\n                // rename column primary key constraint\n                if (\n                    oldColumn.isPrimary === true &&\n                    !oldColumn.primaryKeyConstraintName\n                ) {\n                    const primaryColumns = clonedTable.primaryColumns\n\n                    // build old primary constraint name\n                    const columnNames = primaryColumns.map(\n                        (column) => column.name,\n                    )\n                    const oldPkName =\n                        this.connection.namingStrategy.primaryKeyName(\n                            clonedTable,\n                            columnNames,\n                        )\n\n                    // replace old column name with new column name\n                    columnNames.splice(columnNames.indexOf(oldColumn.name), 1)\n                    columnNames.push(newColumn.name)\n\n                    // build new primary constraint name\n                    const newPkName =\n                        this.connection.namingStrategy.primaryKeyName(\n                            clonedTable,\n                            columnNames,\n                        )\n\n                    // rename primary constraint\n                    upQueries.push(\n                        new Query(\n                            `EXEC sp_rename \"${this.getTablePath(\n                                clonedTable,\n                            )}.${oldPkName}\", \"${newPkName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `EXEC sp_rename \"${this.getTablePath(\n                                clonedTable,\n                            )}.${newPkName}\", \"${oldPkName}\"`,\n                        ),\n                    )\n                }\n\n                // rename index constraints\n                clonedTable.findColumnIndices(oldColumn).forEach((index) => {\n                    const oldIndexName =\n                        this.connection.namingStrategy.indexName(\n                            clonedTable,\n                            index.columnNames,\n                            index.where,\n                        )\n\n                    // Skip renaming if Index has user defined constraint name\n                    if (index.name !== oldIndexName) return\n\n                    // build new constraint name\n                    index.columnNames.splice(\n                        index.columnNames.indexOf(oldColumn.name),\n                        1,\n                    )\n                    index.columnNames.push(newColumn.name)\n                    const newIndexName =\n                        this.connection.namingStrategy.indexName(\n                            clonedTable,\n                            index.columnNames,\n                            index.where,\n                        )\n\n                    // build queries\n                    upQueries.push(\n                        new Query(\n                            `EXEC sp_rename \"${this.getTablePath(\n                                clonedTable,\n                            )}.${index.name}\", \"${newIndexName}\", \"INDEX\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `EXEC sp_rename \"${this.getTablePath(\n                                clonedTable,\n                            )}.${newIndexName}\", \"${index.name}\", \"INDEX\"`,\n                        ),\n                    )\n\n                    // replace constraint name\n                    index.name = newIndexName\n                })\n\n                // rename foreign key constraints\n                clonedTable\n                    .findColumnForeignKeys(oldColumn)\n                    .forEach((foreignKey) => {\n                        const foreignKeyName =\n                            this.connection.namingStrategy.foreignKeyName(\n                                clonedTable,\n                                foreignKey.columnNames,\n                                this.getTablePath(foreignKey),\n                                foreignKey.referencedColumnNames,\n                            )\n\n                        // Skip renaming if foreign key has user defined constraint name\n                        if (foreignKey.name !== foreignKeyName) return\n\n                        // build new constraint name\n                        foreignKey.columnNames.splice(\n                            foreignKey.columnNames.indexOf(oldColumn.name),\n                            1,\n                        )\n                        foreignKey.columnNames.push(newColumn.name)\n                        const newForeignKeyName =\n                            this.connection.namingStrategy.foreignKeyName(\n                                clonedTable,\n                                foreignKey.columnNames,\n                                this.getTablePath(foreignKey),\n                                foreignKey.referencedColumnNames,\n                            )\n\n                        // build queries\n                        upQueries.push(\n                            new Query(\n                                `EXEC sp_rename \"${this.buildForeignKeyName(\n                                    foreignKey.name!,\n                                    schemaName,\n                                    dbName,\n                                )}\", \"${newForeignKeyName}\"`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `EXEC sp_rename \"${this.buildForeignKeyName(\n                                    newForeignKeyName,\n                                    schemaName,\n                                    dbName,\n                                )}\", \"${foreignKey.name}\"`,\n                            ),\n                        )\n\n                        // replace constraint name\n                        foreignKey.name = newForeignKeyName\n                    })\n\n                // rename check constraints\n                clonedTable.findColumnChecks(oldColumn).forEach((check) => {\n                    // build new constraint name\n                    check.columnNames!.splice(\n                        check.columnNames!.indexOf(oldColumn.name),\n                        1,\n                    )\n                    check.columnNames!.push(newColumn.name)\n                    const newCheckName =\n                        this.connection.namingStrategy.checkConstraintName(\n                            clonedTable,\n                            check.expression!,\n                        )\n\n                    // build queries\n                    upQueries.push(\n                        new Query(\n                            `EXEC sp_rename \"${this.getTablePath(\n                                clonedTable,\n                            )}.${check.name}\", \"${newCheckName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `EXEC sp_rename \"${this.getTablePath(\n                                clonedTable,\n                            )}.${newCheckName}\", \"${check.name}\"`,\n                        ),\n                    )\n\n                    // replace constraint name\n                    check.name = newCheckName\n                })\n\n                // rename unique constraints\n                clonedTable.findColumnUniques(oldColumn).forEach((unique) => {\n                    const oldUniqueName =\n                        this.connection.namingStrategy.uniqueConstraintName(\n                            clonedTable,\n                            unique.columnNames,\n                        )\n\n                    // Skip renaming if Unique has user defined constraint name\n                    if (unique.name !== oldUniqueName) return\n\n                    // build new constraint name\n                    unique.columnNames.splice(\n                        unique.columnNames.indexOf(oldColumn.name),\n                        1,\n                    )\n                    unique.columnNames.push(newColumn.name)\n                    const newUniqueName =\n                        this.connection.namingStrategy.uniqueConstraintName(\n                            clonedTable,\n                            unique.columnNames,\n                        )\n\n                    // build queries\n                    upQueries.push(\n                        new Query(\n                            `EXEC sp_rename \"${this.getTablePath(\n                                clonedTable,\n                            )}.${unique.name}\", \"${newUniqueName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `EXEC sp_rename \"${this.getTablePath(\n                                clonedTable,\n                            )}.${newUniqueName}\", \"${unique.name}\"`,\n                        ),\n                    )\n\n                    // replace constraint name\n                    unique.name = newUniqueName\n                })\n\n                // rename default constraints\n                if (\n                    oldColumn.default !== null &&\n                    oldColumn.default !== undefined\n                ) {\n                    const oldDefaultName =\n                        this.connection.namingStrategy.defaultConstraintName(\n                            table,\n                            oldColumn.name,\n                        )\n                    const newDefaultName =\n                        this.connection.namingStrategy.defaultConstraintName(\n                            table,\n                            newColumn.name,\n                        )\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${oldDefaultName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${oldDefaultName}\" DEFAULT ${\n                                oldColumn.default\n                            } FOR \"${newColumn.name}\"`,\n                        ),\n                    )\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${newDefaultName}\" DEFAULT ${\n                                oldColumn.default\n                            } FOR \"${newColumn.name}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${newDefaultName}\"`,\n                        ),\n                    )\n                }\n\n                // change currently used database back to default db.\n                if (dbName && dbName !== currentDB) {\n                    upQueries.push(new Query(`USE \"${currentDB}\"`))\n                    downQueries.push(new Query(`USE \"${dbName}\"`))\n                }\n\n                // rename old column in the Table object\n                const oldTableColumn = clonedTable.columns.find(\n                    (column) => column.name === oldColumn.name,\n                )\n                clonedTable.columns[\n                    clonedTable.columns.indexOf(oldTableColumn!)\n                ].name = newColumn.name\n                oldColumn.name = newColumn.name\n            }\n\n            if (\n                this.isColumnChanged(oldColumn, newColumn, false, false, false)\n            ) {\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            table,\n                        )} ALTER COLUMN ${this.buildCreateColumnSql(\n                            table,\n                            newColumn,\n                            true,\n                            false,\n                            true,\n                        )}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            table,\n                        )} ALTER COLUMN ${this.buildCreateColumnSql(\n                            table,\n                            oldColumn,\n                            true,\n                            false,\n                            true,\n                        )}`,\n                    ),\n                )\n            }\n\n            if (this.isEnumChanged(oldColumn, newColumn)) {\n                const oldExpression = this.getEnumExpression(oldColumn)\n                const oldCheck = new TableCheck({\n                    name: this.connection.namingStrategy.checkConstraintName(\n                        table,\n                        oldExpression,\n                        true,\n                    ),\n                    expression: oldExpression,\n                })\n\n                const newExpression = this.getEnumExpression(newColumn)\n                const newCheck = new TableCheck({\n                    name: this.connection.namingStrategy.checkConstraintName(\n                        table,\n                        newExpression,\n                        true,\n                    ),\n                    expression: newExpression,\n                })\n\n                upQueries.push(this.dropCheckConstraintSql(table, oldCheck))\n                upQueries.push(this.createCheckConstraintSql(table, newCheck))\n\n                downQueries.push(this.dropCheckConstraintSql(table, newCheck))\n                downQueries.push(this.createCheckConstraintSql(table, oldCheck))\n            }\n\n            if (newColumn.isPrimary !== oldColumn.isPrimary) {\n                const primaryColumns = clonedTable.primaryColumns\n\n                // if primary column state changed, we must always drop existed constraint.\n                if (primaryColumns.length > 0) {\n                    const pkName = primaryColumns[0].primaryKeyConstraintName\n                        ? primaryColumns[0].primaryKeyConstraintName\n                        : this.connection.namingStrategy.primaryKeyName(\n                              clonedTable,\n                              primaryColumns.map((column) => column.name),\n                          )\n\n                    const columnNames = primaryColumns\n                        .map((column) => `\"${column.name}\"`)\n                        .join(\", \")\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${pkName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                        ),\n                    )\n                }\n\n                if (newColumn.isPrimary === true) {\n                    primaryColumns.push(newColumn)\n                    // update column in table\n                    const column = clonedTable.columns.find(\n                        (column) => column.name === newColumn.name,\n                    )\n                    column!.isPrimary = true\n                    const pkName = primaryColumns[0].primaryKeyConstraintName\n                        ? primaryColumns[0].primaryKeyConstraintName\n                        : this.connection.namingStrategy.primaryKeyName(\n                              clonedTable,\n                              primaryColumns.map((column) => column.name),\n                          )\n\n                    const columnNames = primaryColumns\n                        .map((column) => `\"${column.name}\"`)\n                        .join(\", \")\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${pkName}\"`,\n                        ),\n                    )\n                } else {\n                    const primaryColumn = primaryColumns.find(\n                        (c) => c.name === newColumn.name,\n                    )\n                    primaryColumns.splice(\n                        primaryColumns.indexOf(primaryColumn!),\n                        1,\n                    )\n\n                    // update column in table\n                    const column = clonedTable.columns.find(\n                        (column) => column.name === newColumn.name,\n                    )\n                    column!.isPrimary = false\n\n                    // if we have another primary keys, we must recreate constraint.\n                    if (primaryColumns.length > 0) {\n                        const pkName = primaryColumns[0]\n                            .primaryKeyConstraintName\n                            ? primaryColumns[0].primaryKeyConstraintName\n                            : this.connection.namingStrategy.primaryKeyName(\n                                  clonedTable,\n                                  primaryColumns.map((column) => column.name),\n                              )\n\n                        const columnNames = primaryColumns\n                            .map((column) => `\"${column.name}\"`)\n                            .join(\", \")\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} DROP CONSTRAINT \"${pkName}\"`,\n                            ),\n                        )\n                    }\n                }\n            }\n\n            if (newColumn.isUnique !== oldColumn.isUnique) {\n                if (newColumn.isUnique === true) {\n                    const uniqueConstraint = new TableUnique({\n                        name: this.connection.namingStrategy.uniqueConstraintName(\n                            table,\n                            [newColumn.name],\n                        ),\n                        columnNames: [newColumn.name],\n                    })\n                    clonedTable.uniques.push(uniqueConstraint)\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${\n                                uniqueConstraint.name\n                            }\" UNIQUE (\"${newColumn.name}\")`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${uniqueConstraint.name}\"`,\n                        ),\n                    )\n                } else {\n                    const uniqueConstraint = clonedTable.uniques.find(\n                        (unique) => {\n                            return (\n                                unique.columnNames.length === 1 &&\n                                !!unique.columnNames.find(\n                                    (columnName) =>\n                                        columnName === newColumn.name,\n                                )\n                            )\n                        },\n                    )\n                    clonedTable.uniques.splice(\n                        clonedTable.uniques.indexOf(uniqueConstraint!),\n                        1,\n                    )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${uniqueConstraint!.name}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${\n                                uniqueConstraint!.name\n                            }\" UNIQUE (\"${newColumn.name}\")`,\n                        ),\n                    )\n                }\n            }\n\n            if (newColumn.default !== oldColumn.default) {\n                // (note) if there is a previous default, we need to drop its constraint first\n                if (\n                    oldColumn.default !== null &&\n                    oldColumn.default !== undefined\n                ) {\n                    const defaultName =\n                        this.connection.namingStrategy.defaultConstraintName(\n                            table,\n                            oldColumn.name,\n                        )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${defaultName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${defaultName}\" DEFAULT ${\n                                oldColumn.default\n                            } FOR \"${oldColumn.name}\"`,\n                        ),\n                    )\n                }\n\n                if (\n                    newColumn.default !== null &&\n                    newColumn.default !== undefined\n                ) {\n                    const defaultName =\n                        this.connection.namingStrategy.defaultConstraintName(\n                            table,\n                            newColumn.name,\n                        )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${defaultName}\" DEFAULT ${\n                                newColumn.default\n                            } FOR \"${newColumn.name}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${defaultName}\"`,\n                        ),\n                    )\n                }\n            }\n\n            await this.executeQueries(upQueries, downQueries)\n            this.replaceCachedTable(table, clonedTable)\n        }\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumns(\n        tableOrName: Table | string,\n        changedColumns: { newColumn: TableColumn; oldColumn: TableColumn }[],\n    ): Promise<void> {\n        for (const { oldColumn, newColumn } of changedColumns) {\n            await this.changeColumn(tableOrName, oldColumn, newColumn)\n        }\n    }\n\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(\n        tableOrName: Table | string,\n        columnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const column = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName\n            : table.findColumnByName(columnOrName)\n        if (!column)\n            throw new TypeORMError(\n                `Column \"${columnOrName}\" was not found in table \"${table.name}\"`,\n            )\n\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // drop primary key constraint\n        if (column.isPrimary) {\n            const pkName = column.primaryKeyConstraintName\n                ? column.primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      clonedTable,\n                      clonedTable.primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNames = clonedTable.primaryColumns\n                .map((primaryColumn) => `\"${primaryColumn.name}\"`)\n                .join(\", \")\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        clonedTable,\n                    )} DROP CONSTRAINT \"${pkName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        clonedTable,\n                    )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                ),\n            )\n\n            // update column in table\n            const tableColumn = clonedTable.findColumnByName(column.name)\n            tableColumn!.isPrimary = false\n\n            // if primary key have multiple columns, we must recreate it without dropped column\n            if (clonedTable.primaryColumns.length > 0) {\n                const pkName = clonedTable.primaryColumns[0]\n                    .primaryKeyConstraintName\n                    ? clonedTable.primaryColumns[0].primaryKeyConstraintName\n                    : this.connection.namingStrategy.primaryKeyName(\n                          clonedTable,\n                          clonedTable.primaryColumns.map(\n                              (column) => column.name,\n                          ),\n                      )\n\n                const columnNames = clonedTable.primaryColumns\n                    .map((primaryColumn) => `\"${primaryColumn.name}\"`)\n                    .join(\", \")\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            clonedTable,\n                        )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            clonedTable,\n                        )} DROP CONSTRAINT \"${pkName}\"`,\n                    ),\n                )\n            }\n        }\n\n        // drop column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            clonedTable.indices.splice(\n                clonedTable.indices.indexOf(columnIndex),\n                1,\n            )\n            upQueries.push(this.dropIndexSql(table, columnIndex))\n            downQueries.push(this.createIndexSql(table, columnIndex))\n        }\n\n        // drop column check\n        const columnCheck = clonedTable.checks.find(\n            (check) =>\n                !!check.columnNames &&\n                check.columnNames.length === 1 &&\n                check.columnNames[0] === column.name,\n        )\n        if (columnCheck) {\n            clonedTable.checks.splice(\n                clonedTable.checks.indexOf(columnCheck),\n                1,\n            )\n            upQueries.push(this.dropCheckConstraintSql(table, columnCheck))\n            downQueries.push(this.createCheckConstraintSql(table, columnCheck))\n        }\n\n        // drop column unique\n        const columnUnique = clonedTable.uniques.find(\n            (unique) =>\n                unique.columnNames.length === 1 &&\n                unique.columnNames[0] === column.name,\n        )\n        if (columnUnique) {\n            clonedTable.uniques.splice(\n                clonedTable.uniques.indexOf(columnUnique),\n                1,\n            )\n            upQueries.push(this.dropUniqueConstraintSql(table, columnUnique))\n            downQueries.push(\n                this.createUniqueConstraintSql(table, columnUnique),\n            )\n        }\n\n        // drop default constraint\n        if (column.default !== null && column.default !== undefined) {\n            const defaultName =\n                this.connection.namingStrategy.defaultConstraintName(\n                    table,\n                    column.name,\n                )\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} DROP CONSTRAINT \"${defaultName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD CONSTRAINT \"${defaultName}\" DEFAULT ${\n                        column.default\n                    } FOR \"${column.name}\"`,\n                ),\n            )\n        }\n\n        if (column.generatedType && column.asExpression) {\n            const parsedTableName = this.driver.parseTableName(table)\n\n            if (!parsedTableName.schema) {\n                parsedTableName.schema = await this.getCurrentSchema()\n            }\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: parsedTableName.database,\n                schema: parsedTableName.schema,\n                table: parsedTableName.tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: parsedTableName.database,\n                schema: parsedTableName.schema,\n                table: parsedTableName.tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${\n                    column.name\n                }\"`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(\n                    table,\n                    column,\n                    false,\n                    false,\n                )}`,\n            ),\n        )\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.removeColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[] | string[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.dropColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Creates a new primary key.\n     */\n    async createPrimaryKey(\n        tableOrName: Table | string,\n        columnNames: string[],\n        constraintName?: string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n\n        const up = this.createPrimaryKeySql(table, columnNames, constraintName)\n\n        // mark columns as primary, because dropPrimaryKeySql build constraint name from table primary column names.\n        clonedTable.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true\n        })\n        const down = this.dropPrimaryKeySql(clonedTable)\n\n        await this.executeQueries(up, down)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const columnNames = columns.map((column) => column.name)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // if table already have primary columns, we must drop them.\n        const primaryColumns = clonedTable.primaryColumns\n        if (primaryColumns.length > 0) {\n            const pkName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      clonedTable,\n                      primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNamesString = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \")\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} DROP CONSTRAINT \"${pkName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`,\n                ),\n            )\n        }\n\n        // update columns in table.\n        clonedTable.columns\n            .filter((column) => columnNames.indexOf(column.name) !== -1)\n            .forEach((column) => (column.isPrimary = true))\n\n        const pkName = primaryColumns[0].primaryKeyConstraintName\n            ? primaryColumns[0].primaryKeyConstraintName\n            : this.connection.namingStrategy.primaryKeyName(\n                  clonedTable,\n                  columnNames,\n              )\n\n        const columnNamesString = columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} DROP CONSTRAINT \"${pkName}\"`,\n            ),\n        )\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops a primary key.\n     */\n    async dropPrimaryKey(\n        tableOrName: Table | string,\n        constraintName?: string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const up = this.dropPrimaryKeySql(table)\n        const down = this.createPrimaryKeySql(\n            table,\n            table.primaryColumns.map((column) => column.name),\n            constraintName,\n        )\n        await this.executeQueries(up, down)\n        table.primaryColumns.forEach((column) => {\n            column.isPrimary = false\n        })\n    }\n\n    /**\n     * Creates a new unique constraint.\n     */\n    async createUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueConstraint: TableUnique,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new unique constraint may be passed without name. In this case we generate unique name manually.\n        if (!uniqueConstraint.name)\n            uniqueConstraint.name =\n                this.connection.namingStrategy.uniqueConstraintName(\n                    table,\n                    uniqueConstraint.columnNames,\n                )\n\n        const up = this.createUniqueConstraintSql(table, uniqueConstraint)\n        const down = this.dropUniqueConstraintSql(table, uniqueConstraint)\n        await this.executeQueries(up, down)\n        table.addUniqueConstraint(uniqueConstraint)\n    }\n\n    /**\n     * Creates a new unique constraints.\n     */\n    async createUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        const promises = uniqueConstraints.map((uniqueConstraint) =>\n            this.createUniqueConstraint(tableOrName, uniqueConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops unique constraint.\n     */\n    async dropUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueOrName: TableUnique | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName)\n            ? uniqueOrName\n            : table.uniques.find((u) => u.name === uniqueOrName)\n        if (!uniqueConstraint)\n            throw new TypeORMError(\n                `Supplied unique constraint was not found in table ${table.name}`,\n            )\n\n        const up = this.dropUniqueConstraintSql(table, uniqueConstraint)\n        const down = this.createUniqueConstraintSql(table, uniqueConstraint)\n        await this.executeQueries(up, down)\n        table.removeUniqueConstraint(uniqueConstraint)\n    }\n\n    /**\n     * Drops an unique constraints.\n     */\n    async dropUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        const promises = uniqueConstraints.map((uniqueConstraint) =>\n            this.dropUniqueConstraint(tableOrName, uniqueConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Creates a new check constraint.\n     */\n    async createCheckConstraint(\n        tableOrName: Table | string,\n        checkConstraint: TableCheck,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new unique constraint may be passed without name. In this case we generate unique name manually.\n        if (!checkConstraint.name)\n            checkConstraint.name =\n                this.connection.namingStrategy.checkConstraintName(\n                    table,\n                    checkConstraint.expression!,\n                )\n\n        const up = this.createCheckConstraintSql(table, checkConstraint)\n        const down = this.dropCheckConstraintSql(table, checkConstraint)\n        await this.executeQueries(up, down)\n        table.addCheckConstraint(checkConstraint)\n    }\n\n    /**\n     * Creates a new check constraints.\n     */\n    async createCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const promises = checkConstraints.map((checkConstraint) =>\n            this.createCheckConstraint(tableOrName, checkConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(\n        tableOrName: Table | string,\n        checkOrName: TableCheck | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const checkConstraint = InstanceChecker.isTableCheck(checkOrName)\n            ? checkOrName\n            : table.checks.find((c) => c.name === checkOrName)\n        if (!checkConstraint)\n            throw new TypeORMError(\n                `Supplied check constraint was not found in table ${table.name}`,\n            )\n\n        const up = this.dropCheckConstraintSql(table, checkConstraint)\n        const down = this.createCheckConstraintSql(table, checkConstraint)\n        await this.executeQueries(up, down)\n        table.removeCheckConstraint(checkConstraint)\n    }\n\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const promises = checkConstraints.map((checkConstraint) =>\n            this.dropCheckConstraint(tableOrName, checkConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Creates a new exclusion constraint.\n     */\n    async createExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionConstraint: TableExclusion,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `SqlServer does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Creates a new exclusion constraints.\n     */\n    async createExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `SqlServer does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionOrName: TableExclusion | string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `SqlServer does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `SqlServer does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(\n        tableOrName: Table | string,\n        foreignKey: TableForeignKey,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const metadata = this.connection.hasMetadata(table.name)\n            ? this.connection.getMetadata(table.name)\n            : undefined\n\n        if (\n            metadata &&\n            metadata.treeParentRelation &&\n            metadata.treeParentRelation!.isTreeParent &&\n            metadata.foreignKeys.find(\n                (foreignKey) => foreignKey.onDelete !== \"NO ACTION\",\n            )\n        )\n            throw new TypeORMError(\n                \"SqlServer does not support options in TreeParent.\",\n            )\n\n        // new FK may be passed without name. In this case we generate FK name manually.\n        if (!foreignKey.name)\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(\n                table,\n                foreignKey.columnNames,\n                this.getTablePath(foreignKey),\n                foreignKey.referencedColumnNames,\n            )\n\n        const up = this.createForeignKeySql(table, foreignKey)\n        const down = this.dropForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.addForeignKey(foreignKey)\n    }\n\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        const promises = foreignKeys.map((foreignKey) =>\n            this.createForeignKey(tableOrName, foreignKey),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops a foreign key from the table.\n     */\n    async dropForeignKey(\n        tableOrName: Table | string,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName)\n            ? foreignKeyOrName\n            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName)\n        if (!foreignKey)\n            throw new TypeORMError(\n                `Supplied foreign key was not found in table ${table.name}`,\n            )\n\n        const up = this.dropForeignKeySql(table, foreignKey)\n        const down = this.createForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.removeForeignKey(foreignKey)\n    }\n\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        const promises = foreignKeys.map((foreignKey) =>\n            this.dropForeignKey(tableOrName, foreignKey),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Creates a new index.\n     */\n    async createIndex(\n        tableOrName: Table | string,\n        index: TableIndex,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.createIndexSql(table, index)\n        const down = this.dropIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.addIndex(index)\n    }\n\n    /**\n     * Creates a new indices\n     */\n    async createIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        const promises = indices.map((index) =>\n            this.createIndex(tableOrName, index),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops an index.\n     */\n    async dropIndex(\n        tableOrName: Table | string,\n        indexOrName: TableIndex | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const index = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName\n            : table.indices.find((i) => i.name === indexOrName)\n        if (!index)\n            throw new TypeORMError(\n                `Supplied index was not found in table ${table.name}`,\n            )\n\n        // old index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.dropIndexSql(table, index)\n        const down = this.createIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.removeIndex(index)\n    }\n\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        const promises = indices.map((index) =>\n            this.dropIndex(tableOrName, index),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Clears all table contents.\n     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n     */\n    async clearTable(tablePath: string): Promise<void> {\n        await this.query(`TRUNCATE TABLE ${this.escapePath(tablePath)}`)\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase(database?: string): Promise<void> {\n        if (database) {\n            const isDatabaseExist = await this.hasDatabase(database)\n            if (!isDatabaseExist) return Promise.resolve()\n        }\n\n        const isAnotherTransactionActive = this.isTransactionActive\n        if (!isAnotherTransactionActive) await this.startTransaction()\n        try {\n            let allViewsSql = database\n                ? `SELECT * FROM \"${database}\".\"INFORMATION_SCHEMA\".\"VIEWS\"`\n                : `SELECT * FROM \"INFORMATION_SCHEMA\".\"VIEWS\"`\n            const allViewsResults: ObjectLiteral[] = await this.query(\n                allViewsSql,\n            )\n\n            await Promise.all(\n                allViewsResults.map((viewResult) => {\n                    // 'DROP VIEW' does not allow specifying the database name as a prefix to the object name.\n                    const dropTableSql = `DROP VIEW \"${viewResult[\"TABLE_SCHEMA\"]}\".\"${viewResult[\"TABLE_NAME\"]}\"`\n                    return this.query(dropTableSql)\n                }),\n            )\n\n            let allTablesSql = database\n                ? `SELECT * FROM \"${database}\".\"INFORMATION_SCHEMA\".\"TABLES\" WHERE \"TABLE_TYPE\" = 'BASE TABLE'`\n                : `SELECT * FROM \"INFORMATION_SCHEMA\".\"TABLES\" WHERE \"TABLE_TYPE\" = 'BASE TABLE'`\n            const allTablesResults: ObjectLiteral[] = await this.query(\n                allTablesSql,\n            )\n\n            if (allTablesResults.length > 0) {\n                const tablesByCatalog: {\n                    [key: string]: {\n                        TABLE_NAME: string\n                        TABLE_SCHEMA: string\n                    }[]\n                } = allTablesResults.reduce(\n                    (c, { TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME }) => {\n                        c[TABLE_CATALOG] = c[TABLE_CATALOG] || []\n                        c[TABLE_CATALOG].push({ TABLE_SCHEMA, TABLE_NAME })\n                        return c\n                    },\n                    {},\n                )\n\n                const foreignKeysSql = Object.entries(tablesByCatalog)\n                    .map(([TABLE_CATALOG, tables]) => {\n                        const conditions = tables\n                            .map(({ TABLE_SCHEMA, TABLE_NAME }) => {\n                                return `(\"fk\".\"referenced_object_id\" = OBJECT_ID('\"${TABLE_CATALOG}\".\"${TABLE_SCHEMA}\".\"${TABLE_NAME}\"'))`\n                            })\n                            .join(\" OR \")\n\n                        return `\n                        SELECT DISTINCT '${TABLE_CATALOG}' AS                                              \"TABLE_CATALOG\",\n                                        OBJECT_SCHEMA_NAME(\"fk\".\"parent_object_id\",\n                                                           DB_ID('${TABLE_CATALOG}')) AS                   \"TABLE_SCHEMA\",\n                                        OBJECT_NAME(\"fk\".\"parent_object_id\", DB_ID('${TABLE_CATALOG}')) AS \"TABLE_NAME\",\n                                        \"fk\".\"name\" AS                                                     \"CONSTRAINT_NAME\"\n                        FROM \"${TABLE_CATALOG}\".\"sys\".\"foreign_keys\" AS \"fk\"\n                        WHERE (${conditions})\n                    `\n                    })\n                    .join(\" UNION ALL \")\n\n                const foreignKeys: {\n                    TABLE_CATALOG: string\n                    TABLE_SCHEMA: string\n                    TABLE_NAME: string\n                    CONSTRAINT_NAME: string\n                }[] = await this.query(foreignKeysSql)\n\n                await Promise.all(\n                    foreignKeys.map(\n                        async ({\n                            TABLE_CATALOG,\n                            TABLE_SCHEMA,\n                            TABLE_NAME,\n                            CONSTRAINT_NAME,\n                        }) => {\n                            // Disable the constraint first.\n                            await this.query(\n                                `ALTER TABLE \"${TABLE_CATALOG}\".\"${TABLE_SCHEMA}\".\"${TABLE_NAME}\" ` +\n                                    `NOCHECK CONSTRAINT \"${CONSTRAINT_NAME}\"`,\n                            )\n\n                            await this.query(\n                                `ALTER TABLE \"${TABLE_CATALOG}\".\"${TABLE_SCHEMA}\".\"${TABLE_NAME}\" ` +\n                                    `DROP CONSTRAINT \"${CONSTRAINT_NAME}\" -- FROM CLEAR`,\n                            )\n                        },\n                    ),\n                )\n\n                await Promise.all(\n                    allTablesResults.map((tablesResult) => {\n                        if (tablesResult[\"TABLE_NAME\"].startsWith(\"#\")) {\n                            // don't try to drop temporary tables\n                            return\n                        }\n\n                        const dropTableSql = `DROP TABLE \"${tablesResult[\"TABLE_CATALOG\"]}\".\"${tablesResult[\"TABLE_SCHEMA\"]}\".\"${tablesResult[\"TABLE_NAME\"]}\"`\n                        return this.query(dropTableSql)\n                    }),\n                )\n            }\n\n            if (!isAnotherTransactionActive) await this.commitTransaction()\n        } catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive)\n                    await this.rollbackTransaction()\n            } catch (rollbackError) {}\n            throw error\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected async loadViews(viewPaths?: string[]): Promise<View[]> {\n        const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n        if (!hasTable) {\n            return []\n        }\n\n        if (!viewPaths) {\n            viewPaths = []\n        }\n\n        const currentSchema = await this.getCurrentSchema()\n        const currentDatabase = await this.getCurrentDatabase()\n\n        const dbNames = viewPaths\n            .map((viewPath) => this.driver.parseTableName(viewPath).database)\n            .filter((database) => database)\n\n        if (\n            this.driver.database &&\n            !dbNames.find((dbName) => dbName === this.driver.database)\n        )\n            dbNames.push(this.driver.database)\n\n        const viewsCondition = viewPaths\n            .map((viewPath) => {\n                let { schema, tableName: name } =\n                    this.driver.parseTableName(viewPath)\n\n                if (!schema) {\n                    schema = currentSchema\n                }\n                return `(\"T\".\"SCHEMA\" = '${schema}' AND \"T\".\"NAME\" = '${name}')`\n            })\n            .join(\" OR \")\n\n        const query = dbNames\n            .map((dbName) => {\n                return (\n                    `SELECT \"T\".*, \"V\".\"CHECK_OPTION\" FROM ${this.escapePath(\n                        this.getTypeormMetadataTableName(),\n                    )} \"t\" ` +\n                    `INNER JOIN \"${dbName}\".\"INFORMATION_SCHEMA\".\"VIEWS\" \"V\" ON \"V\".\"TABLE_SCHEMA\" = \"T\".\"SCHEMA\" AND \"v\".\"TABLE_NAME\" = \"T\".\"NAME\" WHERE \"T\".\"TYPE\" = '${\n                        MetadataTableType.VIEW\n                    }' ${viewsCondition ? `AND (${viewsCondition})` : \"\"}`\n                )\n            })\n            .join(\" UNION ALL \")\n\n        const dbViews = await this.query(query)\n        return dbViews.map((dbView: any) => {\n            const view = new View()\n            const db =\n                dbView[\"TABLE_CATALOG\"] === currentDatabase\n                    ? undefined\n                    : dbView[\"TABLE_CATALOG\"]\n            const schema =\n                dbView[\"schema\"] === currentSchema &&\n                !this.driver.options.schema\n                    ? undefined\n                    : dbView[\"schema\"]\n            view.database = dbView[\"TABLE_CATALOG\"]\n            view.schema = dbView[\"schema\"]\n            view.name = this.driver.buildTableName(dbView[\"name\"], schema, db)\n            view.expression = dbView[\"value\"]\n            return view\n        })\n    }\n\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    protected async loadTables(tableNames?: string[]): Promise<Table[]> {\n        // if no tables given then no need to proceed\n        if (tableNames && tableNames.length === 0) {\n            return []\n        }\n\n        const currentSchema = await this.getCurrentSchema()\n        const currentDatabase = await this.getCurrentDatabase()\n\n        const dbTables: {\n            TABLE_CATALOG: string\n            TABLE_SCHEMA: string\n            TABLE_NAME: string\n        }[] = []\n\n        if (!tableNames) {\n            const databasesSql =\n                `SELECT DISTINCT \"name\" ` +\n                `FROM \"master\".\"dbo\".\"sysdatabases\" ` +\n                `WHERE \"name\" NOT IN ('master', 'model', 'msdb')`\n            const dbDatabases: { name: string }[] = await this.query(\n                databasesSql,\n            )\n\n            const tablesSql = dbDatabases\n                .map(({ name }) => {\n                    return `\n                    SELECT DISTINCT\n                        \"TABLE_CATALOG\", \"TABLE_SCHEMA\", \"TABLE_NAME\"\n                    FROM \"${name}\".\"INFORMATION_SCHEMA\".\"TABLES\"\n                    WHERE\n                      \"TABLE_TYPE\" = 'BASE TABLE'\n                      AND\n                      \"TABLE_CATALOG\" = '${name}'\n                      AND\n                      ISNULL(Objectproperty(Object_id(\"TABLE_CATALOG\" + '.' + \"TABLE_SCHEMA\" + '.' + \"TABLE_NAME\"), 'IsMSShipped'), 0) = 0\n                `\n                })\n                .join(\" UNION ALL \")\n\n            dbTables.push(...(await this.query(tablesSql)))\n        } else {\n            const tableNamesByCatalog = tableNames\n                .map((tableName) => this.driver.parseTableName(tableName))\n                .reduce((c, { database, ...other }) => {\n                    database = database || currentDatabase\n                    c[database] = c[database] || []\n                    c[database].push({\n                        schema: other.schema || currentSchema,\n                        tableName: other.tableName,\n                    })\n                    return c\n                }, {} as { [key: string]: { schema: string; tableName: string }[] })\n\n            const tablesSql = Object.entries(tableNamesByCatalog)\n                .map(([database, tables]) => {\n                    const tablesCondition = tables\n                        .map(({ schema, tableName }) => {\n                            return `(\"TABLE_SCHEMA\" = '${schema}' AND \"TABLE_NAME\" = '${tableName}')`\n                        })\n                        .join(\" OR \")\n\n                    return `\n                    SELECT DISTINCT\n                        \"TABLE_CATALOG\", \"TABLE_SCHEMA\", \"TABLE_NAME\"\n                    FROM \"${database}\".\"INFORMATION_SCHEMA\".\"TABLES\"\n                    WHERE\n                          \"TABLE_TYPE\" = 'BASE TABLE' AND\n                          \"TABLE_CATALOG\" = '${database}' AND\n                          ${tablesCondition}\n                `\n                })\n                .join(\" UNION ALL \")\n\n            dbTables.push(...(await this.query(tablesSql)))\n        }\n\n        // if tables were not found in the db, no need to proceed\n        if (dbTables.length === 0) {\n            return []\n        }\n\n        const dbTablesByCatalog = dbTables.reduce(\n            (c, { TABLE_CATALOG, ...other }) => {\n                c[TABLE_CATALOG] = c[TABLE_CATALOG] || []\n                c[TABLE_CATALOG].push(other)\n                return c\n            },\n            {} as {\n                [key: string]: { TABLE_NAME: string; TABLE_SCHEMA: string }[]\n            },\n        )\n\n        const columnsSql = Object.entries(dbTablesByCatalog)\n            .map(([TABLE_CATALOG, tables]) => {\n                const condition = tables\n                    .map(\n                        ({ TABLE_SCHEMA, TABLE_NAME }) =>\n                            `(\"TABLE_SCHEMA\" = '${TABLE_SCHEMA}' AND \"TABLE_NAME\" = '${TABLE_NAME}')`,\n                    )\n                    .join(\"OR\")\n\n                return (\n                    `SELECT \"COLUMNS\".*, \"cc\".\"is_persisted\", \"cc\".\"definition\" ` +\n                    `FROM \"${TABLE_CATALOG}\".\"INFORMATION_SCHEMA\".\"COLUMNS\" ` +\n                    `LEFT JOIN \"sys\".\"computed_columns\" \"cc\" ON COL_NAME(\"cc\".\"object_id\", \"cc\".\"column_id\") = \"column_name\" ` +\n                    `WHERE (${condition})`\n                )\n            })\n            .join(\" UNION ALL \")\n\n        const constraintsSql = Object.entries(dbTablesByCatalog)\n            .map(([TABLE_CATALOG, tables]) => {\n                const conditions = tables\n                    .map(\n                        ({ TABLE_NAME, TABLE_SCHEMA }) =>\n                            `(\"columnUsages\".\"TABLE_SCHEMA\" = '${TABLE_SCHEMA}' AND \"columnUsages\".\"TABLE_NAME\" = '${TABLE_NAME}')`,\n                    )\n                    .join(\" OR \")\n\n                return (\n                    `SELECT \"columnUsages\".*, \"tableConstraints\".\"CONSTRAINT_TYPE\", \"chk\".\"definition\" ` +\n                    `FROM \"${TABLE_CATALOG}\".\"INFORMATION_SCHEMA\".\"CONSTRAINT_COLUMN_USAGE\" \"columnUsages\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"INFORMATION_SCHEMA\".\"TABLE_CONSTRAINTS\" \"tableConstraints\" ` +\n                    `ON ` +\n                    `\"tableConstraints\".\"CONSTRAINT_NAME\" = \"columnUsages\".\"CONSTRAINT_NAME\" AND ` +\n                    `\"tableConstraints\".\"TABLE_SCHEMA\" = \"columnUsages\".\"TABLE_SCHEMA\" AND ` +\n                    `\"tableConstraints\".\"TABLE_NAME\" = \"columnUsages\".\"TABLE_NAME\" ` +\n                    `LEFT JOIN \"${TABLE_CATALOG}\".\"sys\".\"check_constraints\" \"chk\" ` +\n                    `ON ` +\n                    `\"chk\".\"object_id\" = OBJECT_ID(\"columnUsages\".\"TABLE_CATALOG\" + '.' + \"columnUsages\".\"TABLE_SCHEMA\" + '.' + \"columnUsages\".\"CONSTRAINT_NAME\") ` +\n                    `WHERE ` +\n                    `(${conditions}) AND ` +\n                    `\"tableConstraints\".\"CONSTRAINT_TYPE\" IN ('PRIMARY KEY', 'UNIQUE', 'CHECK')`\n                )\n            })\n            .join(\" UNION ALL \")\n\n        const foreignKeysSql = Object.entries(dbTablesByCatalog)\n            .map(([TABLE_CATALOG, tables]) => {\n                const conditions = tables\n                    .map(\n                        ({ TABLE_NAME, TABLE_SCHEMA }) =>\n                            `(\"s1\".\"name\" = '${TABLE_SCHEMA}' AND \"t1\".\"name\" = '${TABLE_NAME}')`,\n                    )\n                    .join(\" OR \")\n\n                return (\n                    `SELECT \"fk\".\"name\" AS \"FK_NAME\", '${TABLE_CATALOG}' AS \"TABLE_CATALOG\", \"s1\".\"name\" AS \"TABLE_SCHEMA\", \"t1\".\"name\" AS \"TABLE_NAME\", ` +\n                    `\"col1\".\"name\" AS \"COLUMN_NAME\", \"s2\".\"name\" AS \"REF_SCHEMA\", \"t2\".\"name\" AS \"REF_TABLE\", \"col2\".\"name\" AS \"REF_COLUMN\", ` +\n                    `\"fk\".\"delete_referential_action_desc\" AS \"ON_DELETE\", \"fk\".\"update_referential_action_desc\" AS \"ON_UPDATE\" ` +\n                    `FROM \"${TABLE_CATALOG}\".\"sys\".\"foreign_keys\" \"fk\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"sys\".\"foreign_key_columns\" \"fkc\" ON \"fkc\".\"constraint_object_id\" = \"fk\".\"object_id\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"sys\".\"tables\" \"t1\" ON \"t1\".\"object_id\" = \"fk\".\"parent_object_id\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"sys\".\"schemas\" \"s1\" ON \"s1\".\"schema_id\" = \"t1\".\"schema_id\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"sys\".\"tables\" \"t2\" ON \"t2\".\"object_id\" = \"fk\".\"referenced_object_id\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"sys\".\"schemas\" \"s2\" ON \"s2\".\"schema_id\" = \"t2\".\"schema_id\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"sys\".\"columns\" \"col1\" ON \"col1\".\"column_id\" = \"fkc\".\"parent_column_id\" AND \"col1\".\"object_id\" = \"fk\".\"parent_object_id\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"sys\".\"columns\" \"col2\" ON \"col2\".\"column_id\" = \"fkc\".\"referenced_column_id\" AND \"col2\".\"object_id\" = \"fk\".\"referenced_object_id\" ` +\n                    `WHERE (${conditions})`\n                )\n            })\n            .join(\" UNION ALL \")\n\n        const identityColumnsSql = Object.entries(dbTablesByCatalog)\n            .map(([TABLE_CATALOG, tables]) => {\n                const conditions = tables\n                    .map(\n                        ({ TABLE_NAME, TABLE_SCHEMA }) =>\n                            `(\"TABLE_SCHEMA\" = '${TABLE_SCHEMA}' AND \"TABLE_NAME\" = '${TABLE_NAME}')`,\n                    )\n                    .join(\" OR \")\n\n                return (\n                    `SELECT \"TABLE_CATALOG\", \"TABLE_SCHEMA\", \"COLUMN_NAME\", \"TABLE_NAME\" ` +\n                    `FROM \"${TABLE_CATALOG}\".\"INFORMATION_SCHEMA\".\"COLUMNS\" ` +\n                    `WHERE ` +\n                    `EXISTS(SELECT 1 FROM \"${TABLE_CATALOG}\".\"sys\".\"columns\" \"S\" WHERE OBJECT_ID(\"TABLE_CATALOG\" + '.' + \"TABLE_SCHEMA\" + '.' + \"TABLE_NAME\") = \"S\".\"OBJECT_ID\" AND \"COLUMN_NAME\" = \"S\".\"NAME\" AND \"S\".\"is_identity\" = 1) AND ` +\n                    `(${conditions})`\n                )\n            })\n            .join(\" UNION ALL \")\n\n        const dbCollationsSql = `SELECT \"NAME\", \"COLLATION_NAME\" FROM \"sys\".\"databases\"`\n\n        const indicesSql = Object.entries(dbTablesByCatalog)\n            .map(([TABLE_CATALOG, tables]) => {\n                const conditions = tables\n                    .map(\n                        ({ TABLE_NAME, TABLE_SCHEMA }) =>\n                            `(\"s\".\"name\" = '${TABLE_SCHEMA}' AND \"t\".\"name\" = '${TABLE_NAME}')`,\n                    )\n                    .join(\" OR \")\n\n                return (\n                    `SELECT '${TABLE_CATALOG}' AS \"TABLE_CATALOG\", \"s\".\"name\" AS \"TABLE_SCHEMA\", \"t\".\"name\" AS \"TABLE_NAME\", ` +\n                    `\"ind\".\"name\" AS \"INDEX_NAME\", \"col\".\"name\" AS \"COLUMN_NAME\", \"ind\".\"is_unique\" AS \"IS_UNIQUE\", \"ind\".\"filter_definition\" as \"CONDITION\" ` +\n                    `FROM \"${TABLE_CATALOG}\".\"sys\".\"indexes\" \"ind\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"sys\".\"index_columns\" \"ic\" ON \"ic\".\"object_id\" = \"ind\".\"object_id\" AND \"ic\".\"index_id\" = \"ind\".\"index_id\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"sys\".\"columns\" \"col\" ON \"col\".\"object_id\" = \"ic\".\"object_id\" AND \"col\".\"column_id\" = \"ic\".\"column_id\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"sys\".\"tables\" \"t\" ON \"t\".\"object_id\" = \"ind\".\"object_id\" ` +\n                    `INNER JOIN \"${TABLE_CATALOG}\".\"sys\".\"schemas\" \"s\" ON \"s\".\"schema_id\" = \"t\".\"schema_id\" ` +\n                    `WHERE ` +\n                    `\"ind\".\"is_primary_key\" = 0 AND \"ind\".\"is_unique_constraint\" = 0 AND \"t\".\"is_ms_shipped\" = 0 AND ` +\n                    `(${conditions})`\n                )\n            })\n            .join(\" UNION ALL \")\n\n        const [\n            dbColumns,\n            dbConstraints,\n            dbForeignKeys,\n            dbIdentityColumns,\n            dbCollations,\n            dbIndices,\n        ]: ObjectLiteral[][] = await Promise.all([\n            this.query(columnsSql),\n            this.query(constraintsSql),\n            this.query(foreignKeysSql),\n            this.query(identityColumnsSql),\n            this.query(dbCollationsSql),\n            this.query(indicesSql),\n        ])\n\n        // create table schemas for loaded tables\n        return await Promise.all(\n            dbTables.map(async (dbTable) => {\n                const table = new Table()\n\n                const getSchemaFromKey = (dbObject: any, key: string) => {\n                    return dbObject[key] === currentSchema &&\n                        (!this.driver.options.schema ||\n                            this.driver.options.schema === currentSchema)\n                        ? undefined\n                        : dbObject[key]\n                }\n\n                // We do not need to join schema and database names, when db or schema is by default.\n                const db =\n                    dbTable[\"TABLE_CATALOG\"] === currentDatabase\n                        ? undefined\n                        : dbTable[\"TABLE_CATALOG\"]\n                const schema = getSchemaFromKey(dbTable, \"TABLE_SCHEMA\")\n                table.database = dbTable[\"TABLE_CATALOG\"]\n                table.schema = dbTable[\"TABLE_SCHEMA\"]\n                table.name = this.driver.buildTableName(\n                    dbTable[\"TABLE_NAME\"],\n                    schema,\n                    db,\n                )\n\n                const defaultCollation = dbCollations.find(\n                    (dbCollation) =>\n                        dbCollation[\"NAME\"] === dbTable[\"TABLE_CATALOG\"],\n                )!\n\n                // create columns from the loaded columns\n                table.columns = await Promise.all(\n                    dbColumns\n                        .filter(\n                            (dbColumn) =>\n                                dbColumn[\"TABLE_NAME\"] ===\n                                    dbTable[\"TABLE_NAME\"] &&\n                                dbColumn[\"TABLE_SCHEMA\"] ===\n                                    dbTable[\"TABLE_SCHEMA\"] &&\n                                dbColumn[\"TABLE_CATALOG\"] ===\n                                    dbTable[\"TABLE_CATALOG\"],\n                        )\n                        .map(async (dbColumn) => {\n                            const columnConstraints = dbConstraints.filter(\n                                (dbConstraint) =>\n                                    dbConstraint[\"TABLE_NAME\"] ===\n                                        dbColumn[\"TABLE_NAME\"] &&\n                                    dbConstraint[\"TABLE_SCHEMA\"] ===\n                                        dbColumn[\"TABLE_SCHEMA\"] &&\n                                    dbConstraint[\"TABLE_CATALOG\"] ===\n                                        dbColumn[\"TABLE_CATALOG\"] &&\n                                    dbConstraint[\"COLUMN_NAME\"] ===\n                                        dbColumn[\"COLUMN_NAME\"],\n                            )\n\n                            const uniqueConstraints = columnConstraints.filter(\n                                (constraint) =>\n                                    constraint[\"CONSTRAINT_TYPE\"] === \"UNIQUE\",\n                            )\n                            const isConstraintComposite =\n                                uniqueConstraints.every((uniqueConstraint) => {\n                                    return dbConstraints.some(\n                                        (dbConstraint) =>\n                                            dbConstraint[\"CONSTRAINT_TYPE\"] ===\n                                                \"UNIQUE\" &&\n                                            dbConstraint[\"CONSTRAINT_NAME\"] ===\n                                                uniqueConstraint[\n                                                    \"CONSTRAINT_NAME\"\n                                                ] &&\n                                            dbConstraint[\"TABLE_SCHEMA\"] ===\n                                                dbColumn[\"TABLE_SCHEMA\"] &&\n                                            dbConstraint[\"TABLE_CATALOG\"] ===\n                                                dbColumn[\"TABLE_CATALOG\"] &&\n                                            dbConstraint[\"COLUMN_NAME\"] !==\n                                                dbColumn[\"COLUMN_NAME\"],\n                                    )\n                                })\n\n                            const isGenerated = !!dbIdentityColumns.find(\n                                (column) =>\n                                    column[\"TABLE_NAME\"] ===\n                                        dbColumn[\"TABLE_NAME\"] &&\n                                    column[\"TABLE_SCHEMA\"] ===\n                                        dbColumn[\"TABLE_SCHEMA\"] &&\n                                    column[\"TABLE_CATALOG\"] ===\n                                        dbColumn[\"TABLE_CATALOG\"] &&\n                                    column[\"COLUMN_NAME\"] ===\n                                        dbColumn[\"COLUMN_NAME\"],\n                            )\n\n                            const tableColumn = new TableColumn()\n                            tableColumn.name = dbColumn[\"COLUMN_NAME\"]\n                            tableColumn.type =\n                                dbColumn[\"DATA_TYPE\"].toLowerCase()\n\n                            // check only columns that have length property\n                            if (\n                                this.driver.withLengthColumnTypes.indexOf(\n                                    tableColumn.type as ColumnType,\n                                ) !== -1 &&\n                                dbColumn[\"CHARACTER_MAXIMUM_LENGTH\"]\n                            ) {\n                                const length =\n                                    dbColumn[\n                                        \"CHARACTER_MAXIMUM_LENGTH\"\n                                    ].toString()\n                                if (length === \"-1\") {\n                                    tableColumn.length = \"MAX\"\n                                } else {\n                                    tableColumn.length =\n                                        !this.isDefaultColumnLength(\n                                            table,\n                                            tableColumn,\n                                            length,\n                                        )\n                                            ? length\n                                            : \"\"\n                                }\n                            }\n\n                            if (\n                                tableColumn.type === \"decimal\" ||\n                                tableColumn.type === \"numeric\"\n                            ) {\n                                if (\n                                    dbColumn[\"NUMERIC_PRECISION\"] !== null &&\n                                    !this.isDefaultColumnPrecision(\n                                        table,\n                                        tableColumn,\n                                        dbColumn[\"NUMERIC_PRECISION\"],\n                                    )\n                                )\n                                    tableColumn.precision =\n                                        dbColumn[\"NUMERIC_PRECISION\"]\n                                if (\n                                    dbColumn[\"NUMERIC_SCALE\"] !== null &&\n                                    !this.isDefaultColumnScale(\n                                        table,\n                                        tableColumn,\n                                        dbColumn[\"NUMERIC_SCALE\"],\n                                    )\n                                )\n                                    tableColumn.scale =\n                                        dbColumn[\"NUMERIC_SCALE\"]\n                            }\n\n                            if (tableColumn.type === \"nvarchar\") {\n                                // Check if this is an enum\n                                const columnCheckConstraints =\n                                    columnConstraints.filter(\n                                        (constraint) =>\n                                            constraint[\"CONSTRAINT_TYPE\"] ===\n                                            \"CHECK\",\n                                    )\n                                if (columnCheckConstraints.length) {\n                                    // const isEnumRegexp = new RegExp(\"^\\\\(\\\\[\" + tableColumn.name + \"\\\\]='[^']+'(?: OR \\\\[\" + tableColumn.name + \"\\\\]='[^']+')*\\\\)$\");\n                                    for (const checkConstraint of columnCheckConstraints) {\n                                        if (\n                                            this.isEnumCheckConstraint(\n                                                checkConstraint[\n                                                    \"CONSTRAINT_NAME\"\n                                                ],\n                                            )\n                                        ) {\n                                            // This is an enum constraint, make column into an enum\n                                            tableColumn.enum = []\n                                            const enumValueRegexp = new RegExp(\n                                                \"\\\\[\" +\n                                                    tableColumn.name +\n                                                    \"\\\\]='([^']+)'\",\n                                                \"g\",\n                                            )\n                                            let result\n                                            while (\n                                                (result = enumValueRegexp.exec(\n                                                    checkConstraint[\n                                                        \"definition\"\n                                                    ],\n                                                )) !== null\n                                            ) {\n                                                tableColumn.enum.unshift(\n                                                    result[1],\n                                                )\n                                            }\n                                            // Skip other column constraints\n                                            break\n                                        }\n                                    }\n                                }\n                            }\n\n                            const primaryConstraint = columnConstraints.find(\n                                (constraint) =>\n                                    constraint[\"CONSTRAINT_TYPE\"] ===\n                                    \"PRIMARY KEY\",\n                            )\n                            if (primaryConstraint) {\n                                tableColumn.isPrimary = true\n                                // find another columns involved in primary key constraint\n                                const anotherPrimaryConstraints =\n                                    dbConstraints.filter(\n                                        (constraint) =>\n                                            constraint[\"TABLE_NAME\"] ===\n                                                dbColumn[\"TABLE_NAME\"] &&\n                                            constraint[\"TABLE_SCHEMA\"] ===\n                                                dbColumn[\"TABLE_SCHEMA\"] &&\n                                            constraint[\"TABLE_CATALOG\"] ===\n                                                dbColumn[\"TABLE_CATALOG\"] &&\n                                            constraint[\"COLUMN_NAME\"] !==\n                                                dbColumn[\"COLUMN_NAME\"] &&\n                                            constraint[\"CONSTRAINT_TYPE\"] ===\n                                                \"PRIMARY KEY\",\n                                    )\n\n                                // collect all column names\n                                const columnNames =\n                                    anotherPrimaryConstraints.map(\n                                        (constraint) =>\n                                            constraint[\"COLUMN_NAME\"],\n                                    )\n                                columnNames.push(dbColumn[\"COLUMN_NAME\"])\n\n                                // build default primary key constraint name\n                                const pkName =\n                                    this.connection.namingStrategy.primaryKeyName(\n                                        table,\n                                        columnNames,\n                                    )\n\n                                // if primary key has user-defined constraint name, write it in table column\n                                if (\n                                    primaryConstraint[\"CONSTRAINT_NAME\"] !==\n                                    pkName\n                                ) {\n                                    tableColumn.primaryKeyConstraintName =\n                                        primaryConstraint[\"CONSTRAINT_NAME\"]\n                                }\n                            }\n\n                            tableColumn.default =\n                                dbColumn[\"COLUMN_DEFAULT\"] !== null &&\n                                dbColumn[\"COLUMN_DEFAULT\"] !== undefined\n                                    ? this.removeParenthesisFromDefault(\n                                          dbColumn[\"COLUMN_DEFAULT\"],\n                                      )\n                                    : undefined\n                            tableColumn.isNullable =\n                                dbColumn[\"IS_NULLABLE\"] === \"YES\"\n                            tableColumn.isUnique =\n                                uniqueConstraints.length > 0 &&\n                                !isConstraintComposite\n                            tableColumn.isGenerated = isGenerated\n                            if (isGenerated)\n                                tableColumn.generationStrategy = \"increment\"\n                            if (tableColumn.default === \"newsequentialid()\") {\n                                tableColumn.isGenerated = true\n                                tableColumn.generationStrategy = \"uuid\"\n                                tableColumn.default = undefined\n                            }\n\n                            // todo: unable to get default charset\n                            // tableColumn.charset = dbColumn[\"CHARACTER_SET_NAME\"];\n                            if (dbColumn[\"COLLATION_NAME\"])\n                                tableColumn.collation =\n                                    dbColumn[\"COLLATION_NAME\"] ===\n                                    defaultCollation[\"COLLATION_NAME\"]\n                                        ? undefined\n                                        : dbColumn[\"COLLATION_NAME\"]\n\n                            if (\n                                tableColumn.type === \"datetime2\" ||\n                                tableColumn.type === \"time\" ||\n                                tableColumn.type === \"datetimeoffset\"\n                            ) {\n                                tableColumn.precision =\n                                    !this.isDefaultColumnPrecision(\n                                        table,\n                                        tableColumn,\n                                        dbColumn[\"DATETIME_PRECISION\"],\n                                    )\n                                        ? dbColumn[\"DATETIME_PRECISION\"]\n                                        : undefined\n                            }\n\n                            if (\n                                dbColumn[\"is_persisted\"] !== null &&\n                                dbColumn[\"is_persisted\"] !== undefined &&\n                                dbColumn[\"definition\"]\n                            ) {\n                                tableColumn.generatedType =\n                                    dbColumn[\"is_persisted\"] === true\n                                        ? \"STORED\"\n                                        : \"VIRTUAL\"\n                                // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n                                const asExpressionQuery =\n                                    this.selectTypeormMetadataSql({\n                                        database: dbTable[\"TABLE_CATALOG\"],\n                                        schema: dbTable[\"TABLE_SCHEMA\"],\n                                        table: dbTable[\"TABLE_NAME\"],\n                                        type: MetadataTableType.GENERATED_COLUMN,\n                                        name: tableColumn.name,\n                                    })\n\n                                const results = await this.query(\n                                    asExpressionQuery.query,\n                                    asExpressionQuery.parameters,\n                                )\n                                if (results[0] && results[0].value) {\n                                    tableColumn.asExpression = results[0].value\n                                } else {\n                                    tableColumn.asExpression = \"\"\n                                }\n                            }\n\n                            return tableColumn\n                        }),\n                )\n\n                // find unique constraints of table, group them by constraint name and build TableUnique.\n                const tableUniqueConstraints = OrmUtils.uniq(\n                    dbConstraints.filter(\n                        (dbConstraint) =>\n                            dbConstraint[\"TABLE_NAME\"] ===\n                                dbTable[\"TABLE_NAME\"] &&\n                            dbConstraint[\"TABLE_SCHEMA\"] ===\n                                dbTable[\"TABLE_SCHEMA\"] &&\n                            dbConstraint[\"TABLE_CATALOG\"] ===\n                                dbTable[\"TABLE_CATALOG\"] &&\n                            dbConstraint[\"CONSTRAINT_TYPE\"] === \"UNIQUE\",\n                    ),\n                    (dbConstraint) => dbConstraint[\"CONSTRAINT_NAME\"],\n                )\n\n                table.uniques = tableUniqueConstraints.map((constraint) => {\n                    const uniques = dbConstraints.filter(\n                        (dbC) =>\n                            dbC[\"CONSTRAINT_NAME\"] ===\n                            constraint[\"CONSTRAINT_NAME\"],\n                    )\n                    return new TableUnique({\n                        name: constraint[\"CONSTRAINT_NAME\"],\n                        columnNames: uniques.map((u) => u[\"COLUMN_NAME\"]),\n                    })\n                })\n\n                // find check constraints of table, group them by constraint name and build TableCheck.\n                const tableCheckConstraints = OrmUtils.uniq(\n                    dbConstraints.filter(\n                        (dbConstraint) =>\n                            dbConstraint[\"TABLE_NAME\"] ===\n                                dbTable[\"TABLE_NAME\"] &&\n                            dbConstraint[\"TABLE_SCHEMA\"] ===\n                                dbTable[\"TABLE_SCHEMA\"] &&\n                            dbConstraint[\"TABLE_CATALOG\"] ===\n                                dbTable[\"TABLE_CATALOG\"] &&\n                            dbConstraint[\"CONSTRAINT_TYPE\"] === \"CHECK\",\n                    ),\n                    (dbConstraint) => dbConstraint[\"CONSTRAINT_NAME\"],\n                )\n\n                table.checks = tableCheckConstraints\n                    .filter(\n                        (constraint) =>\n                            !this.isEnumCheckConstraint(\n                                constraint[\"CONSTRAINT_NAME\"],\n                            ),\n                    )\n                    .map((constraint) => {\n                        const checks = dbConstraints.filter(\n                            (dbC) =>\n                                dbC[\"CONSTRAINT_NAME\"] ===\n                                constraint[\"CONSTRAINT_NAME\"],\n                        )\n                        return new TableCheck({\n                            name: constraint[\"CONSTRAINT_NAME\"],\n                            columnNames: checks.map((c) => c[\"COLUMN_NAME\"]),\n                            expression: constraint[\"definition\"],\n                        })\n                    })\n\n                // find foreign key constraints of table, group them by constraint name and build TableForeignKey.\n                const tableForeignKeyConstraints = OrmUtils.uniq(\n                    dbForeignKeys.filter(\n                        (dbForeignKey) =>\n                            dbForeignKey[\"TABLE_NAME\"] ===\n                                dbTable[\"TABLE_NAME\"] &&\n                            dbForeignKey[\"TABLE_SCHEMA\"] ===\n                                dbTable[\"TABLE_SCHEMA\"] &&\n                            dbForeignKey[\"TABLE_CATALOG\"] ===\n                                dbTable[\"TABLE_CATALOG\"],\n                    ),\n                    (dbForeignKey) => dbForeignKey[\"FK_NAME\"],\n                )\n\n                table.foreignKeys = tableForeignKeyConstraints.map(\n                    (dbForeignKey) => {\n                        const foreignKeys = dbForeignKeys.filter(\n                            (dbFk) =>\n                                dbFk[\"FK_NAME\"] === dbForeignKey[\"FK_NAME\"],\n                        )\n\n                        // if referenced table located in currently used db and schema, we don't need to concat db and schema names to table name.\n                        const db =\n                            dbForeignKey[\"TABLE_CATALOG\"] === currentDatabase\n                                ? undefined\n                                : dbForeignKey[\"TABLE_CATALOG\"]\n                        const schema = getSchemaFromKey(\n                            dbForeignKey,\n                            \"REF_SCHEMA\",\n                        )\n                        const referencedTableName = this.driver.buildTableName(\n                            dbForeignKey[\"REF_TABLE\"],\n                            schema,\n                            db,\n                        )\n\n                        return new TableForeignKey({\n                            name: dbForeignKey[\"FK_NAME\"],\n                            columnNames: foreignKeys.map(\n                                (dbFk) => dbFk[\"COLUMN_NAME\"],\n                            ),\n                            referencedDatabase: dbForeignKey[\"TABLE_CATALOG\"],\n                            referencedSchema: dbForeignKey[\"REF_SCHEMA\"],\n                            referencedTableName: referencedTableName,\n                            referencedColumnNames: foreignKeys.map(\n                                (dbFk) => dbFk[\"REF_COLUMN\"],\n                            ),\n                            onDelete: dbForeignKey[\"ON_DELETE\"].replace(\n                                \"_\",\n                                \" \",\n                            ), // SqlServer returns NO_ACTION, instead of NO ACTION\n                            onUpdate: dbForeignKey[\"ON_UPDATE\"].replace(\n                                \"_\",\n                                \" \",\n                            ), // SqlServer returns NO_ACTION, instead of NO ACTION\n                        })\n                    },\n                )\n\n                // find index constraints of table, group them by constraint name and build TableIndex.\n                const tableIndexConstraints = OrmUtils.uniq(\n                    dbIndices.filter(\n                        (dbIndex) =>\n                            dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] &&\n                            dbIndex[\"TABLE_SCHEMA\"] ===\n                                dbTable[\"TABLE_SCHEMA\"] &&\n                            dbIndex[\"TABLE_CATALOG\"] ===\n                                dbTable[\"TABLE_CATALOG\"],\n                    ),\n                    (dbIndex) => dbIndex[\"INDEX_NAME\"],\n                )\n\n                table.indices = tableIndexConstraints.map((constraint) => {\n                    const indices = dbIndices.filter((index) => {\n                        return (\n                            index[\"TABLE_CATALOG\"] ===\n                                constraint[\"TABLE_CATALOG\"] &&\n                            index[\"TABLE_SCHEMA\"] ===\n                                constraint[\"TABLE_SCHEMA\"] &&\n                            index[\"TABLE_NAME\"] === constraint[\"TABLE_NAME\"] &&\n                            index[\"INDEX_NAME\"] === constraint[\"INDEX_NAME\"]\n                        )\n                    })\n                    return new TableIndex(<TableIndexOptions>{\n                        table: table,\n                        name: constraint[\"INDEX_NAME\"],\n                        columnNames: indices.map((i) => i[\"COLUMN_NAME\"]),\n                        isUnique: constraint[\"IS_UNIQUE\"],\n                        where: constraint[\"CONDITION\"],\n                    })\n                })\n\n                return table\n            }),\n        )\n    }\n\n    /**\n     * Builds and returns SQL for create table.\n     */\n    protected createTableSql(table: Table, createForeignKeys?: boolean): Query {\n        const columnDefinitions = table.columns\n            .map((column) =>\n                this.buildCreateColumnSql(table, column, false, true),\n            )\n            .join(\", \")\n        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`\n\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n                const isUniqueExist = table.uniques.some(\n                    (unique) =>\n                        unique.columnNames.length === 1 &&\n                        unique.columnNames[0] === column.name,\n                )\n                if (!isUniqueExist)\n                    table.uniques.push(\n                        new TableUnique({\n                            name: this.connection.namingStrategy.uniqueConstraintName(\n                                table,\n                                [column.name],\n                            ),\n                            columnNames: [column.name],\n                        }),\n                    )\n            })\n\n        if (table.uniques.length > 0) {\n            const uniquesSql = table.uniques\n                .map((unique) => {\n                    const uniqueName = unique.name\n                        ? unique.name\n                        : this.connection.namingStrategy.uniqueConstraintName(\n                              table,\n                              unique.columnNames,\n                          )\n                    const columnNames = unique.columnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n                    return `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`\n                })\n                .join(\", \")\n\n            sql += `, ${uniquesSql}`\n        }\n\n        if (table.checks.length > 0) {\n            const checksSql = table.checks\n                .map((check) => {\n                    const checkName = check.name\n                        ? check.name\n                        : this.connection.namingStrategy.checkConstraintName(\n                              table,\n                              check.expression!,\n                          )\n                    return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`\n                })\n                .join(\", \")\n\n            sql += `, ${checksSql}`\n        }\n\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .map((fk) => {\n                    const columnNames = fk.columnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n                    if (!fk.name)\n                        fk.name = this.connection.namingStrategy.foreignKeyName(\n                            table,\n                            fk.columnNames,\n                            this.getTablePath(fk),\n                            fk.referencedColumnNames,\n                        )\n                    const referencedColumnNames = fk.referencedColumnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n\n                    let constraint = `CONSTRAINT \"${\n                        fk.name\n                    }\" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(\n                        this.getTablePath(fk),\n                    )} (${referencedColumnNames})`\n                    if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`\n                    if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`\n\n                    return constraint\n                })\n                .join(\", \")\n\n            sql += `, ${foreignKeysSql}`\n        }\n\n        const primaryColumns = table.columns.filter(\n            (column) => column.isPrimary,\n        )\n        if (primaryColumns.length > 0) {\n            const primaryKeyName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      table,\n                      primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNames = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \")\n            sql += `, CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNames})`\n        }\n\n        sql += `)`\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop table sql.\n     */\n    protected dropTableSql(\n        tableOrName: Table | string,\n        ifExist?: boolean,\n    ): Query {\n        const query = ifExist\n            ? `DROP TABLE IF EXISTS ${this.escapePath(tableOrName)}`\n            : `DROP TABLE ${this.escapePath(tableOrName)}`\n        return new Query(query)\n    }\n\n    protected createViewSql(view: View): Query {\n        const parsedName = this.driver.parseTableName(view)\n\n        // Can't use `escapePath` here because `CREATE VIEW` does not accept database names.\n        const viewIdentifier = parsedName.schema\n            ? `\"${parsedName.schema}\".\"${parsedName.tableName}\"`\n            : `\"${parsedName.tableName}\"`\n\n        if (typeof view.expression === \"string\") {\n            return new Query(\n                `CREATE VIEW ${viewIdentifier} AS ${view.expression}`,\n            )\n        } else {\n            return new Query(\n                `CREATE VIEW ${viewIdentifier} AS ${view\n                    .expression(this.connection)\n                    .getQuery()}`,\n            )\n        }\n    }\n\n    protected async insertViewDefinitionSql(view: View): Promise<Query> {\n        const parsedTableName = this.driver.parseTableName(view)\n\n        if (!parsedTableName.schema) {\n            parsedTableName.schema = await this.getCurrentSchema()\n        }\n\n        const expression =\n            typeof view.expression === \"string\"\n                ? view.expression.trim()\n                : view.expression(this.connection).getQuery()\n        return this.insertTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            database: parsedTableName.database,\n            schema: parsedTableName.schema,\n            name: parsedTableName.tableName,\n            value: expression,\n        })\n    }\n\n    /**\n     * Builds drop view sql.\n     */\n    protected dropViewSql(viewOrPath: View | string): Query {\n        return new Query(`DROP VIEW ${this.escapePath(viewOrPath)}`)\n    }\n\n    /**\n     * Builds remove view sql.\n     */\n    protected async deleteViewDefinitionSql(\n        viewOrPath: View | string,\n    ): Promise<Query> {\n        const parsedTableName = this.driver.parseTableName(viewOrPath)\n\n        if (!parsedTableName.schema) {\n            parsedTableName.schema = await this.getCurrentSchema()\n        }\n\n        return this.deleteTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            database: parsedTableName.database,\n            schema: parsedTableName.schema,\n            name: parsedTableName.tableName,\n        })\n    }\n\n    /**\n     * Builds create index sql.\n     */\n    protected createIndexSql(table: Table, index: TableIndex): Query {\n        const columns = index.columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n        return new Query(\n            `CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX \"${\n                index.name\n            }\" ON ${this.escapePath(table)} (${columns}) ${\n                index.where ? \"WHERE \" + index.where : \"\"\n            }`,\n        )\n    }\n\n    /**\n     * Builds drop index sql.\n     */\n    protected dropIndexSql(\n        table: Table,\n        indexOrName: TableIndex | string,\n    ): Query {\n        let indexName = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName.name\n            : indexOrName\n        return new Query(\n            `DROP INDEX \"${indexName}\" ON ${this.escapePath(table)}`,\n        )\n    }\n\n    /**\n     * Builds create primary key sql.\n     */\n    protected createPrimaryKeySql(\n        table: Table,\n        columnNames: string[],\n        constraintName?: string,\n    ): Query {\n        const primaryKeyName = constraintName\n            ? constraintName\n            : this.connection.namingStrategy.primaryKeyName(table, columnNames)\n\n        const columnNamesString = columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} ADD CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNamesString})`,\n        )\n    }\n\n    /**\n     * Builds drop primary key sql.\n     */\n    protected dropPrimaryKeySql(table: Table): Query {\n        const columnNames = table.primaryColumns.map((column) => column.name)\n        const constraintName = table.primaryColumns[0].primaryKeyConstraintName\n        const primaryKeyName = constraintName\n            ? constraintName\n            : this.connection.namingStrategy.primaryKeyName(table, columnNames)\n\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${primaryKeyName}\"`,\n        )\n    }\n\n    /**\n     * Builds create unique constraint sql.\n     */\n    protected createUniqueConstraintSql(\n        table: Table,\n        uniqueConstraint: TableUnique,\n    ): Query {\n        const columnNames = uniqueConstraint.columnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\", \")\n        return new Query(\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                uniqueConstraint.name\n            }\" UNIQUE (${columnNames})`,\n        )\n    }\n\n    /**\n     * Builds drop unique constraint sql.\n     */\n    protected dropUniqueConstraintSql(\n        table: Table,\n        uniqueOrName: TableUnique | string,\n    ): Query {\n        const uniqueName = InstanceChecker.isTableUnique(uniqueOrName)\n            ? uniqueOrName.name\n            : uniqueOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${uniqueName}\"`,\n        )\n    }\n\n    /**\n     * Builds create check constraint sql.\n     */\n    protected createCheckConstraintSql(\n        table: Table,\n        checkConstraint: TableCheck,\n    ): Query {\n        return new Query(\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                checkConstraint.name\n            }\" CHECK (${checkConstraint.expression})`,\n        )\n    }\n\n    /**\n     * Builds drop check constraint sql.\n     */\n    protected dropCheckConstraintSql(\n        table: Table,\n        checkOrName: TableCheck | string,\n    ): Query {\n        const checkName = InstanceChecker.isTableCheck(checkOrName)\n            ? checkOrName.name\n            : checkOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${checkName}\"`,\n        )\n    }\n\n    /**\n     * Builds create foreign key sql.\n     */\n    protected createForeignKeySql(\n        table: Table,\n        foreignKey: TableForeignKey,\n    ): Query {\n        const columnNames = foreignKey.columnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\", \")\n        const referencedColumnNames = foreignKey.referencedColumnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\",\")\n        let sql =\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                foreignKey.name\n            }\" FOREIGN KEY (${columnNames}) ` +\n            `REFERENCES ${this.escapePath(\n                this.getTablePath(foreignKey),\n            )}(${referencedColumnNames})`\n        if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`\n        if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop foreign key sql.\n     */\n    protected dropForeignKeySql(\n        table: Table,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Query {\n        const foreignKeyName = InstanceChecker.isTableForeignKey(\n            foreignKeyOrName,\n        )\n            ? foreignKeyOrName.name\n            : foreignKeyOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${foreignKeyName}\"`,\n        )\n    }\n\n    /**\n     * Escapes given table or View path.\n     */\n    protected escapePath(target: Table | View | string): string {\n        const { database, schema, tableName } =\n            this.driver.parseTableName(target)\n\n        if (database && database !== this.driver.database) {\n            if (schema && schema !== this.driver.searchSchema) {\n                return `\"${database}\".\"${schema}\".\"${tableName}\"`\n            }\n\n            return `\"${database}\"..\"${tableName}\"`\n        }\n\n        if (schema && schema !== this.driver.searchSchema) {\n            return `\"${schema}\".\"${tableName}\"`\n        }\n\n        return `\"${tableName}\"`\n    }\n\n    /**\n     * Concat database name and schema name to the foreign key name.\n     * Needs because FK name is relevant to the schema and database.\n     */\n    protected buildForeignKeyName(\n        fkName: string,\n        schemaName: string | undefined,\n        dbName: string | undefined,\n    ): string {\n        let joinedFkName = fkName\n        if (schemaName && schemaName !== this.driver.searchSchema)\n            joinedFkName = schemaName + \".\" + joinedFkName\n        if (dbName && dbName !== this.driver.database)\n            joinedFkName = dbName + \".\" + joinedFkName\n\n        return joinedFkName\n    }\n\n    /**\n     * Removes parenthesis around default value.\n     * Sql server returns default value with parenthesis around, e.g.\n     *  ('My text') - for string\n     *  ((1)) - for number\n     *  (newsequentialId()) - for function\n     */\n    protected removeParenthesisFromDefault(defaultValue: string): any {\n        if (defaultValue.substr(0, 1) !== \"(\") return defaultValue\n        const normalizedDefault = defaultValue.substr(\n            1,\n            defaultValue.lastIndexOf(\")\") - 1,\n        )\n        return this.removeParenthesisFromDefault(normalizedDefault)\n    }\n\n    /**\n     * Builds a query for create column.\n     */\n    protected buildCreateColumnSql(\n        table: Table,\n        column: TableColumn,\n        skipIdentity: boolean,\n        createDefault: boolean,\n        skipEnum?: boolean,\n    ) {\n        let c = `\"${column.name}\" ${this.connection.driver.createFullType(\n            column,\n        )}`\n\n        if (!skipEnum && column.enum) {\n            const expression = this.getEnumExpression(column)\n            const checkName =\n                this.connection.namingStrategy.checkConstraintName(\n                    table,\n                    expression,\n                    true,\n                )\n            c += ` CONSTRAINT ${checkName} CHECK(${expression})`\n        }\n\n        if (column.collation) c += \" COLLATE \" + column.collation\n\n        if (column.asExpression) {\n            c += ` AS (${column.asExpression})`\n            if (column.generatedType === \"STORED\") {\n                c += ` PERSISTED`\n\n                // NOT NULL can be specified for computed columns only if PERSISTED is also specified\n                if (column.isNullable !== true) c += \" NOT NULL\"\n            }\n        } else {\n            if (column.isNullable !== true) c += \" NOT NULL\"\n        }\n\n        if (\n            column.isGenerated === true &&\n            column.generationStrategy === \"increment\" &&\n            !skipIdentity\n        )\n            // don't use skipPrimary here since updates can update already exist primary without auto inc.\n            c += \" IDENTITY(1,1)\"\n\n        if (\n            column.default !== undefined &&\n            column.default !== null &&\n            createDefault\n        ) {\n            // we create named constraint to be able to delete this constraint when column been dropped\n            const defaultName =\n                this.connection.namingStrategy.defaultConstraintName(\n                    table,\n                    column.name,\n                )\n            c += ` CONSTRAINT \"${defaultName}\" DEFAULT ${column.default}`\n        }\n\n        if (\n            column.isGenerated &&\n            column.generationStrategy === \"uuid\" &&\n            !column.default\n        ) {\n            // we create named constraint to be able to delete this constraint when column been dropped\n            const defaultName =\n                this.connection.namingStrategy.defaultConstraintName(\n                    table,\n                    column.name,\n                )\n            c += ` CONSTRAINT \"${defaultName}\" DEFAULT NEWSEQUENTIALID()`\n        }\n        return c\n    }\n\n    private getEnumExpression(column: TableColumn) {\n        if (!column.enum) {\n            throw new Error(`Enum is not defined in column ${column.name}`)\n        }\n        return (\n            column.name +\n            \" IN (\" +\n            column.enum.map((val) => \"'\" + val + \"'\").join(\",\") +\n            \")\"\n        )\n    }\n\n    protected isEnumCheckConstraint(name: string): boolean {\n        return name.indexOf(\"CHK_\") !== -1 && name.indexOf(\"_ENUM\") !== -1\n    }\n\n    /**\n     * Converts MssqlParameter into real mssql parameter type.\n     */\n    protected mssqlParameterToNativeParameter(parameter: MssqlParameter): any {\n        switch (this.driver.normalizeType({ type: parameter.type as any })) {\n            case \"bit\":\n                return this.driver.mssql.Bit\n            case \"bigint\":\n                return this.driver.mssql.BigInt\n            case \"decimal\":\n                return this.driver.mssql.Decimal(...parameter.params)\n            case \"float\":\n                return this.driver.mssql.Float\n            case \"int\":\n                return this.driver.mssql.Int\n            case \"money\":\n                return this.driver.mssql.Money\n            case \"numeric\":\n                return this.driver.mssql.Numeric(...parameter.params)\n            case \"smallint\":\n                return this.driver.mssql.SmallInt\n            case \"smallmoney\":\n                return this.driver.mssql.SmallMoney\n            case \"real\":\n                return this.driver.mssql.Real\n            case \"tinyint\":\n                return this.driver.mssql.TinyInt\n            case \"char\":\n                if (\n                    this.driver.options.options\n                        ?.disableAsciiToUnicodeParamConversion\n                ) {\n                    return this.driver.mssql.Char(...parameter.params)\n                }\n                return this.driver.mssql.NChar(...parameter.params)\n            case \"nchar\":\n                return this.driver.mssql.NChar(...parameter.params)\n            case \"text\":\n                if (\n                    this.driver.options.options\n                        ?.disableAsciiToUnicodeParamConversion\n                ) {\n                    return this.driver.mssql.Text\n                }\n                return this.driver.mssql.Ntext\n            case \"ntext\":\n                return this.driver.mssql.Ntext\n            case \"varchar\":\n                if (\n                    this.driver.options.options\n                        ?.disableAsciiToUnicodeParamConversion\n                ) {\n                    return this.driver.mssql.VarChar(...parameter.params)\n                }\n                return this.driver.mssql.NVarChar(...parameter.params)\n            case \"nvarchar\":\n                return this.driver.mssql.NVarChar(...parameter.params)\n            case \"xml\":\n                return this.driver.mssql.Xml\n            case \"time\":\n                return this.driver.mssql.Time(...parameter.params)\n            case \"date\":\n                return this.driver.mssql.Date\n            case \"datetime\":\n                return this.driver.mssql.DateTime\n            case \"datetime2\":\n                return this.driver.mssql.DateTime2(...parameter.params)\n            case \"datetimeoffset\":\n                return this.driver.mssql.DateTimeOffset(...parameter.params)\n            case \"smalldatetime\":\n                return this.driver.mssql.SmallDateTime\n            case \"uniqueidentifier\":\n                return this.driver.mssql.UniqueIdentifier\n            case \"variant\":\n                return this.driver.mssql.Variant\n            case \"binary\":\n                return this.driver.mssql.Binary\n            case \"varbinary\":\n                return this.driver.mssql.VarBinary(...parameter.params)\n            case \"image\":\n                return this.driver.mssql.Image\n            case \"udt\":\n                return this.driver.mssql.UDT\n            case \"rowversion\":\n                return this.driver.mssql.RowVersion\n        }\n    }\n\n    /**\n     * Converts string literal of isolation level to enum.\n     * The underlying mssql driver requires an enum for the isolation level.\n     */\n    convertIsolationLevel(isolation: IsolationLevel) {\n        const ISOLATION_LEVEL = this.driver.mssql.ISOLATION_LEVEL\n        switch (isolation) {\n            case \"READ UNCOMMITTED\":\n                return ISOLATION_LEVEL.READ_UNCOMMITTED\n            case \"REPEATABLE READ\":\n                return ISOLATION_LEVEL.REPEATABLE_READ\n            case \"SERIALIZABLE\":\n                return ISOLATION_LEVEL.SERIALIZABLE\n\n            case \"READ COMMITTED\":\n            default:\n                return ISOLATION_LEVEL.READ_COMMITTED\n        }\n    }\n\n    /**\n     * Change table comment.\n     */\n    changeTableComment(\n        tableOrName: Table | string,\n        comment?: string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `sqlserver driver does not support change table comment.`,\n        )\n    }\n}\n"],"sourceRoot":"../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/SqlServerQueryRunner.ts b/driver/sqlserver/SqlServerQueryRunner.ts
new file mode 100644
index 0000000000000000000000000000000000000000..547b8a8074e4cb14fe5131bda4f43bd0bf1a2183
--- /dev/null
+++ b/driver/sqlserver/SqlServerQueryRunner.ts
@@ -0,0 +1,4176 @@
+import { ObjectLiteral } from "../../common/ObjectLiteral"
+import { QueryResult } from "../../query-runner/QueryResult"
+import { QueryFailedError } from "../../error/QueryFailedError"
+import { QueryRunnerAlreadyReleasedError } from "../../error/QueryRunnerAlreadyReleasedError"
+import { TransactionNotStartedError } from "../../error/TransactionNotStartedError"
+import { ColumnType } from "../types/ColumnTypes"
+import { ReadStream } from "../../platform/PlatformTools"
+import { BaseQueryRunner } from "../../query-runner/BaseQueryRunner"
+import { QueryRunner } from "../../query-runner/QueryRunner"
+import { TableIndexOptions } from "../../schema-builder/options/TableIndexOptions"
+import { Table } from "../../schema-builder/table/Table"
+import { TableCheck } from "../../schema-builder/table/TableCheck"
+import { TableColumn } from "../../schema-builder/table/TableColumn"
+import { TableExclusion } from "../../schema-builder/table/TableExclusion"
+import { TableForeignKey } from "../../schema-builder/table/TableForeignKey"
+import { TableIndex } from "../../schema-builder/table/TableIndex"
+import { TableUnique } from "../../schema-builder/table/TableUnique"
+import { View } from "../../schema-builder/view/View"
+import { Broadcaster } from "../../subscriber/Broadcaster"
+import { OrmUtils } from "../../util/OrmUtils"
+import { Query } from "../Query"
+import { IsolationLevel } from "../types/IsolationLevel"
+import { MssqlParameter } from "./MssqlParameter"
+import { SqlServerDriver } from "./SqlServerDriver"
+import { ReplicationMode } from "../types/ReplicationMode"
+import { TypeORMError } from "../../error"
+import { QueryLock } from "../../query-runner/QueryLock"
+import { MetadataTableType } from "../types/MetadataTableType"
+import { InstanceChecker } from "../../util/InstanceChecker"
+import { BroadcasterResult } from "../../subscriber/BroadcasterResult"
+
+/**
+ * Runs queries on a single SQL Server database connection.
+ */
+export class SqlServerQueryRunner
+    extends BaseQueryRunner
+    implements QueryRunner
+{
+    // -------------------------------------------------------------------------
+    // Public Implemented Properties
+    // -------------------------------------------------------------------------
+
+    /**
+     * Database driver used by connection.
+     */
+    driver: SqlServerDriver
+
+    // -------------------------------------------------------------------------
+    // Private Properties
+    // -------------------------------------------------------------------------
+
+    private lock: QueryLock = new QueryLock()
+
+    // -------------------------------------------------------------------------
+    // Constructor
+    // -------------------------------------------------------------------------
+
+    constructor(driver: SqlServerDriver, mode: ReplicationMode) {
+        super()
+        this.driver = driver
+        this.connection = driver.connection
+        this.broadcaster = new Broadcaster(this)
+        this.mode = mode
+    }
+
+    // -------------------------------------------------------------------------
+    // Public Methods
+    // -------------------------------------------------------------------------
+
+    /**
+     * Creates/uses database connection from the connection pool to perform further operations.
+     * Returns obtained database connection.
+     */
+    connect(): Promise<void> {
+        return Promise.resolve()
+    }
+
+    /**
+     * Releases used database connection.
+     * You cannot use query runner methods once its released.
+     */
+    release(): Promise<void> {
+        this.isReleased = true
+        return Promise.resolve()
+    }
+
+    /**
+     * Starts transaction.
+     */
+    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {
+        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()
+
+        this.isTransactionActive = true
+        try {
+            await this.broadcaster.broadcast("BeforeTransactionStart")
+        } catch (err) {
+            this.isTransactionActive = false
+            throw err
+        }
+        await new Promise<void>(async (ok, fail) => {
+            const transactionCallback = (err: any) => {
+                if (err) {
+                    this.isTransactionActive = false
+                    return fail(err)
+                }
+                ok()
+            }
+
+            if (this.transactionDepth === 0) {
+                this.transactionDepth += 1
+                const pool = await (this.mode === "slave"
+                    ? this.driver.obtainSlaveConnection()
+                    : this.driver.obtainMasterConnection())
+                this.databaseConnection = pool.transaction()
+                this.connection.logger.logQuery("BEGIN TRANSACTION")
+                if (isolationLevel) {
+                    this.databaseConnection.begin(
+                        this.convertIsolationLevel(isolationLevel),
+                        transactionCallback,
+                    )
+                    this.connection.logger.logQuery(
+                        "SET TRANSACTION ISOLATION LEVEL " + isolationLevel,
+                    )
+                } else {
+                    this.databaseConnection.begin(transactionCallback)
+                }
+            } else {
+                this.transactionDepth += 1
+                await this.query(
+                    `SAVE TRANSACTION typeorm_${this.transactionDepth - 1}`,
+                )
+                ok()
+            }
+        })
+
+        await this.broadcaster.broadcast("AfterTransactionStart")
+    }
+
+    /**
+     * Commits transaction.
+     * Error will be thrown if transaction was not started.
+     */
+    async commitTransaction(): Promise<void> {
+        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()
+
+        if (!this.isTransactionActive) throw new TransactionNotStartedError()
+
+        await this.broadcaster.broadcast("BeforeTransactionCommit")
+
+        if (this.transactionDepth === 1) {
+            return new Promise<void>((ok, fail) => {
+                this.transactionDepth -= 1
+                this.databaseConnection.commit(async (err: any) => {
+                    if (err) return fail(err)
+                    this.isTransactionActive = false
+                    this.databaseConnection = null
+
+                    await this.broadcaster.broadcast("AfterTransactionCommit")
+
+                    ok()
+                    this.connection.logger.logQuery("COMMIT")
+                })
+            })
+        }
+        this.transactionDepth -= 1
+    }
+
+    /**
+     * Rollbacks transaction.
+     * Error will be thrown if transaction was not started.
+     */
+    async rollbackTransaction(): Promise<void> {
+        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()
+
+        if (!this.isTransactionActive) throw new TransactionNotStartedError()
+
+        await this.broadcaster.broadcast("BeforeTransactionRollback")
+
+        if (this.transactionDepth > 1) {
+            this.transactionDepth -= 1
+            await this.query(
+                `ROLLBACK TRANSACTION typeorm_${this.transactionDepth}`,
+            )
+        } else {
+            return new Promise<void>((ok, fail) => {
+                this.transactionDepth -= 1
+                this.databaseConnection.rollback(async (err: any) => {
+                    if (err) return fail(err)
+                    this.isTransactionActive = false
+                    this.databaseConnection = null
+
+                    await this.broadcaster.broadcast("AfterTransactionRollback")
+
+                    ok()
+                    this.connection.logger.logQuery("ROLLBACK")
+                })
+            })
+        }
+    }
+
+    /**
+     * Executes a given SQL query.
+     */
+    async query(
+        query: string,
+        parameters?: any[],
+        useStructuredResult = false,
+    ): Promise<any> {
+        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()
+
+        const release = await this.lock.acquire()
+
+        const broadcasterResult = new BroadcasterResult()
+
+        try {
+            this.driver.connection.logger.logQuery(query, parameters, this)
+            this.broadcaster.broadcastBeforeQueryEvent(
+                broadcasterResult,
+                query,
+                parameters,
+            )
+
+            const pool = await (this.mode === "slave"
+                ? this.driver.obtainSlaveConnection()
+                : this.driver.obtainMasterConnection())
+            const request = new this.driver.mssql.Request(
+                this.isTransactionActive ? this.databaseConnection : pool,
+            )
+            if (parameters && parameters.length) {
+                parameters.forEach((parameter, index) => {
+                    const parameterName = index.toString()
+                    if (InstanceChecker.isMssqlParameter(parameter)) {
+                        const mssqlParameter =
+                            this.mssqlParameterToNativeParameter(parameter)
+                        if (mssqlParameter) {
+                            request.input(
+                                parameterName,
+                                mssqlParameter,
+                                parameter.value,
+                            )
+                        } else {
+                            request.input(parameterName, parameter.value)
+                        }
+                    } else {
+                        request.input(parameterName, parameter)
+                    }
+                })
+            }
+            const queryStartTime = +new Date()
+
+            const raw = await new Promise<any>((ok, fail) => {
+                request.query(query, (err: any, raw: any) => {
+                    // log slow queries if maxQueryExecution time is set
+                    const maxQueryExecutionTime =
+                        this.driver.options.maxQueryExecutionTime
+                    const queryEndTime = +new Date()
+                    const queryExecutionTime = queryEndTime - queryStartTime
+
+                    this.broadcaster.broadcastAfterQueryEvent(
+                        broadcasterResult,
+                        query,
+                        parameters,
+                        true,
+                        queryExecutionTime,
+                        raw,
+                        undefined,
+                    )
+
+                    if (
+                        maxQueryExecutionTime &&
+                        queryExecutionTime > maxQueryExecutionTime
+                    ) {
+                        this.driver.connection.logger.logQuerySlow(
+                            queryExecutionTime,
+                            query,
+                            parameters,
+                            this,
+                        )
+                    }
+
+                    if (err) {
+                        fail(new QueryFailedError(query, parameters, err))
+                    }
+
+                    ok(raw)
+                })
+            })
+
+            const result = new QueryResult()
+
+            if (raw?.hasOwnProperty("recordset")) {
+                result.records = raw.recordset
+            }
+
+            if (raw?.hasOwnProperty("rowsAffected")) {
+                result.affected = raw.rowsAffected[0]
+            }
+
+            const queryType = query.slice(0, query.indexOf(" "))
+            switch (queryType) {
+                case "DELETE":
+                    // for DELETE query additionally return number of affected rows
+                    result.raw = [raw.recordset, raw.rowsAffected[0]]
+                    break
+                default:
+                    result.raw = raw.recordset
+            }
+
+            if (useStructuredResult) {
+                return result
+            } else {
+                return result.raw
+            }
+        } catch (err) {
+            this.driver.connection.logger.logQueryError(
+                err,
+                query,
+                parameters,
+                this,
+            )
+            this.broadcaster.broadcastAfterQueryEvent(
+                broadcasterResult,
+                query,
+                parameters,
+                false,
+                undefined,
+                undefined,
+                err,
+            )
+
+            throw err
+        } finally {
+            await broadcasterResult.wait()
+
+            release()
+        }
+    }
+
+    /**
+     * Returns raw data stream.
+     */
+    async stream(
+        query: string,
+        parameters?: any[],
+        onEnd?: Function,
+        onError?: Function,
+    ): Promise<ReadStream> {
+        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()
+
+        const release = await this.lock.acquire()
+
+        this.driver.connection.logger.logQuery(query, parameters, this)
+        const pool = await (this.mode === "slave"
+            ? this.driver.obtainSlaveConnection()
+            : this.driver.obtainMasterConnection())
+        const request = new this.driver.mssql.Request(
+            this.isTransactionActive ? this.databaseConnection : pool,
+        )
+        if (parameters && parameters.length) {
+            parameters.forEach((parameter, index) => {
+                const parameterName = index.toString()
+                if (InstanceChecker.isMssqlParameter(parameter)) {
+                    request.input(
+                        parameterName,
+                        this.mssqlParameterToNativeParameter(parameter),
+                        parameter.value,
+                    )
+                } else {
+                    request.input(parameterName, parameter)
+                }
+            })
+        }
+
+        request.query(query)
+
+        const streamRequest = request.toReadableStream()
+
+        streamRequest.on("error", (err: any) => {
+            release()
+            this.driver.connection.logger.logQueryError(
+                err,
+                query,
+                parameters,
+                this,
+            )
+        })
+
+        streamRequest.on("end", () => {
+            release()
+        })
+
+        if (onEnd) {
+            streamRequest.on("end", onEnd)
+        }
+
+        if (onError) {
+            streamRequest.on("error", onError)
+        }
+
+        return streamRequest
+    }
+
+    /**
+     * Returns all available database names including system databases.
+     */
+    async getDatabases(): Promise<string[]> {
+        const results: ObjectLiteral[] = await this.query(`EXEC sp_databases`)
+        return results.map((result) => result["DATABASE_NAME"])
+    }
+
+    /**
+     * Returns all available schema names including system schemas.
+     * If database parameter specified, returns schemas of that database.
+     */
+    async getSchemas(database?: string): Promise<string[]> {
+        const query = database
+            ? `SELECT * FROM "${database}"."sys"."schema"`
+            : `SELECT * FROM "sys"."schemas"`
+        const results: ObjectLiteral[] = await this.query(query)
+        return results.map((result) => result["name"])
+    }
+
+    /**
+     * Checks if database with the given name exist.
+     */
+    async hasDatabase(database: string): Promise<boolean> {
+        const result = await this.query(
+            `SELECT DB_ID('${database}') as "db_id"`,
+        )
+        const dbId = result[0]["db_id"]
+        return !!dbId
+    }
+
+    /**
+     * Loads currently using database
+     */
+    async getCurrentDatabase(): Promise<string> {
+        const currentDBQuery = await this.query(`SELECT DB_NAME() AS "db_name"`)
+        return currentDBQuery[0]["db_name"]
+    }
+
+    /**
+     * Checks if schema with the given name exist.
+     */
+    async hasSchema(schema: string): Promise<boolean> {
+        const result = await this.query(
+            `SELECT SCHEMA_ID('${schema}') as "schema_id"`,
+        )
+        const schemaId = result[0]["schema_id"]
+        return !!schemaId
+    }
+
+    /**
+     * Loads currently using database schema
+     */
+    async getCurrentSchema(): Promise<string> {
+        const currentSchemaQuery = await this.query(
+            `SELECT SCHEMA_NAME() AS "schema_name"`,
+        )
+        return currentSchemaQuery[0]["schema_name"]
+    }
+
+    /**
+     * Checks if table with the given name exist in the database.
+     */
+    async hasTable(tableOrName: Table | string): Promise<boolean> {
+        const parsedTableName = this.driver.parseTableName(tableOrName)
+
+        if (!parsedTableName.database) {
+            parsedTableName.database = await this.getCurrentDatabase()
+        }
+
+        if (!parsedTableName.schema) {
+            parsedTableName.schema = await this.getCurrentSchema()
+        }
+
+        const sql = `SELECT * FROM "${parsedTableName.database}"."INFORMATION_SCHEMA"."TABLES" WHERE "TABLE_NAME" = '${parsedTableName.tableName}' AND "TABLE_SCHEMA" = '${parsedTableName.schema}'`
+        const result = await this.query(sql)
+        return result.length ? true : false
+    }
+
+    /**
+     * Checks if column exist in the table.
+     */
+    async hasColumn(
+        tableOrName: Table | string,
+        columnName: string,
+    ): Promise<boolean> {
+        const parsedTableName = this.driver.parseTableName(tableOrName)
+
+        if (!parsedTableName.database) {
+            parsedTableName.database = await this.getCurrentDatabase()
+        }
+
+        if (!parsedTableName.schema) {
+            parsedTableName.schema = await this.getCurrentSchema()
+        }
+
+        const sql = `SELECT * FROM "${parsedTableName.database}"."INFORMATION_SCHEMA"."COLUMNS" WHERE "TABLE_NAME" = '${parsedTableName.tableName}' AND "TABLE_SCHEMA" = '${parsedTableName.schema}' AND "COLUMN_NAME" = '${columnName}'`
+        const result = await this.query(sql)
+        return result.length ? true : false
+    }
+
+    /**
+     * Creates a new database.
+     */
+    async createDatabase(
+        database: string,
+        ifNotExist?: boolean,
+    ): Promise<void> {
+        const up = ifNotExist
+            ? `IF DB_ID('${database}') IS NULL CREATE DATABASE "${database}"`
+            : `CREATE DATABASE "${database}"`
+        const down = `DROP DATABASE "${database}"`
+        await this.executeQueries(new Query(up), new Query(down))
+    }
+
+    /**
+     * Drops database.
+     */
+    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {
+        const up = ifExist
+            ? `IF DB_ID('${database}') IS NOT NULL DROP DATABASE "${database}"`
+            : `DROP DATABASE "${database}"`
+        const down = `CREATE DATABASE "${database}"`
+        await this.executeQueries(new Query(up), new Query(down))
+    }
+
+    /**
+     * Creates table schema.
+     * If database name also specified (e.g. 'dbName.schemaName') schema will be created in specified database.
+     */
+    async createSchema(
+        schemaPath: string,
+        ifNotExist?: boolean,
+    ): Promise<void> {
+        const upQueries: Query[] = []
+        const downQueries: Query[] = []
+
+        if (schemaPath.indexOf(".") === -1) {
+            const upQuery = ifNotExist
+                ? `IF SCHEMA_ID('${schemaPath}') IS NULL BEGIN EXEC ('CREATE SCHEMA "${schemaPath}"') END`
+                : `CREATE SCHEMA "${schemaPath}"`
+            upQueries.push(new Query(upQuery))
+            downQueries.push(new Query(`DROP SCHEMA "${schemaPath}"`))
+        } else {
+            const dbName = schemaPath.split(".")[0]
+            const schema = schemaPath.split(".")[1]
+            const currentDB = await this.getCurrentDatabase()
+            upQueries.push(new Query(`USE "${dbName}"`))
+            downQueries.push(new Query(`USE "${currentDB}"`))
+
+            const upQuery = ifNotExist
+                ? `IF SCHEMA_ID('${schema}') IS NULL BEGIN EXEC ('CREATE SCHEMA "${schema}"') END`
+                : `CREATE SCHEMA "${schema}"`
+            upQueries.push(new Query(upQuery))
+            downQueries.push(new Query(`DROP SCHEMA "${schema}"`))
+
+            upQueries.push(new Query(`USE "${currentDB}"`))
+            downQueries.push(new Query(`USE "${dbName}"`))
+        }
+
+        await this.executeQueries(upQueries, downQueries)
+    }
+
+    /**
+     * Drops table schema.
+     * If database name also specified (e.g. 'dbName.schemaName') schema will be dropped in specified database.
+     */
+    async dropSchema(schemaPath: string, ifExist?: boolean): Promise<void> {
+        const upQueries: Query[] = []
+        const downQueries: Query[] = []
+
+        if (schemaPath.indexOf(".") === -1) {
+            const upQuery = ifExist
+                ? `IF SCHEMA_ID('${schemaPath}') IS NULL BEGIN EXEC ('DROP SCHEMA "${schemaPath}"') END`
+                : `DROP SCHEMA "${schemaPath}"`
+            upQueries.push(new Query(upQuery))
+            downQueries.push(new Query(`CREATE SCHEMA "${schemaPath}"`))
+        } else {
+            const dbName = schemaPath.split(".")[0]
+            const schema = schemaPath.split(".")[1]
+            const currentDB = await this.getCurrentDatabase()
+            upQueries.push(new Query(`USE "${dbName}"`))
+            downQueries.push(new Query(`USE "${currentDB}"`))
+
+            const upQuery = ifExist
+                ? `IF SCHEMA_ID('${schema}') IS NULL BEGIN EXEC ('DROP SCHEMA "${schema}"') END`
+                : `DROP SCHEMA "${schema}"`
+            upQueries.push(new Query(upQuery))
+            downQueries.push(new Query(`CREATE SCHEMA "${schema}"`))
+
+            upQueries.push(new Query(`USE "${currentDB}"`))
+            downQueries.push(new Query(`USE "${dbName}"`))
+        }
+
+        await this.executeQueries(upQueries, downQueries)
+    }
+
+    /**
+     * Creates a new table.
+     */
+    async createTable(
+        table: Table,
+        ifNotExist: boolean = false,
+        createForeignKeys: boolean = true,
+        createIndices: boolean = true,
+    ): Promise<void> {
+        if (ifNotExist) {
+            const isTableExist = await this.hasTable(table)
+            if (isTableExist) return Promise.resolve()
+        }
+        const upQueries: Query[] = []
+        const downQueries: Query[] = []
+
+        upQueries.push(this.createTableSql(table, createForeignKeys))
+        downQueries.push(this.dropTableSql(table))
+
+        // if createForeignKeys is true, we must drop created foreign keys in down query.
+        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.
+        if (createForeignKeys)
+            table.foreignKeys.forEach((foreignKey) =>
+                downQueries.push(this.dropForeignKeySql(table, foreignKey)),
+            )
+
+        if (createIndices) {
+            table.indices.forEach((index) => {
+                // new index may be passed without name. In this case we generate index name manually.
+                if (!index.name)
+                    index.name = this.connection.namingStrategy.indexName(
+                        table,
+                        index.columnNames,
+                        index.where,
+                    )
+                upQueries.push(this.createIndexSql(table, index))
+                downQueries.push(this.dropIndexSql(table, index))
+            })
+        }
+
+        // if table have column with generated type, we must add the expression to the metadata table
+        const generatedColumns = table.columns.filter(
+            (column) => column.generatedType && column.asExpression,
+        )
+
+        for (const column of generatedColumns) {
+            const parsedTableName = this.driver.parseTableName(table)
+
+            if (!parsedTableName.schema) {
+                parsedTableName.schema = await this.getCurrentSchema()
+            }
+
+            const insertQuery = this.insertTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+                value: column.asExpression,
+            })
+
+            const deleteQuery = this.deleteTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+            })
+
+            upQueries.push(insertQuery)
+            downQueries.push(deleteQuery)
+        }
+
+        await this.executeQueries(upQueries, downQueries)
+    }
+
+    /**
+     * Drops the table.
+     */
+    async dropTable(
+        tableOrName: Table | string,
+        ifExist?: boolean,
+        dropForeignKeys: boolean = true,
+        dropIndices: boolean = true,
+    ): Promise<void> {
+        if (ifExist) {
+            const isTableExist = await this.hasTable(tableOrName)
+            if (!isTableExist) return Promise.resolve()
+        }
+
+        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.
+        const createForeignKeys: boolean = dropForeignKeys
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const upQueries: Query[] = []
+        const downQueries: Query[] = []
+
+        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need
+        // to perform drop queries for foreign keys and indices.
+
+        if (dropIndices) {
+            table.indices.forEach((index) => {
+                upQueries.push(this.dropIndexSql(table, index))
+                downQueries.push(this.createIndexSql(table, index))
+            })
+        }
+
+        // if dropForeignKeys is true, we just drop the table, otherwise we also drop table foreign keys.
+        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.
+        if (dropForeignKeys)
+            table.foreignKeys.forEach((foreignKey) =>
+                upQueries.push(this.dropForeignKeySql(table, foreignKey)),
+            )
+
+        upQueries.push(this.dropTableSql(table))
+        downQueries.push(this.createTableSql(table, createForeignKeys))
+
+        // if table had columns with generated type, we must remove the expression from the metadata table
+        const generatedColumns = table.columns.filter(
+            (column) => column.generatedType && column.asExpression,
+        )
+
+        for (const column of generatedColumns) {
+            const parsedTableName = this.driver.parseTableName(table)
+
+            if (!parsedTableName.schema) {
+                parsedTableName.schema = await this.getCurrentSchema()
+            }
+
+            const deleteQuery = this.deleteTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+            })
+
+            const insertQuery = this.insertTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+                value: column.asExpression,
+            })
+
+            upQueries.push(deleteQuery)
+            downQueries.push(insertQuery)
+        }
+
+        await this.executeQueries(upQueries, downQueries)
+    }
+
+    /**
+     * Creates a new view.
+     */
+    async createView(
+        view: View,
+        syncWithMetadata: boolean = false,
+    ): Promise<void> {
+        const upQueries: Query[] = []
+        const downQueries: Query[] = []
+        upQueries.push(this.createViewSql(view))
+        if (syncWithMetadata)
+            upQueries.push(await this.insertViewDefinitionSql(view))
+        downQueries.push(this.dropViewSql(view))
+        if (syncWithMetadata)
+            downQueries.push(await this.deleteViewDefinitionSql(view))
+        await this.executeQueries(upQueries, downQueries)
+    }
+
+    /**
+     * Drops the view.
+     */
+    async dropView(target: View | string): Promise<void> {
+        const viewName = InstanceChecker.isView(target) ? target.name : target
+        const view = await this.getCachedView(viewName)
+
+        const upQueries: Query[] = []
+        const downQueries: Query[] = []
+        upQueries.push(await this.deleteViewDefinitionSql(view))
+        upQueries.push(this.dropViewSql(view))
+        downQueries.push(await this.insertViewDefinitionSql(view))
+        downQueries.push(this.createViewSql(view))
+        await this.executeQueries(upQueries, downQueries)
+    }
+
+    /**
+     * Renames a table.
+     */
+    async renameTable(
+        oldTableOrName: Table | string,
+        newTableName: string,
+    ): Promise<void> {
+        const upQueries: Query[] = []
+        const downQueries: Query[] = []
+        const oldTable = InstanceChecker.isTable(oldTableOrName)
+            ? oldTableOrName
+            : await this.getCachedTable(oldTableOrName)
+        let newTable = oldTable.clone()
+
+        // we need database name and schema name to rename FK constraints
+        let dbName: string | undefined = undefined
+        let schemaName: string | undefined = undefined
+        let oldTableName: string = oldTable.name
+        const splittedName = oldTable.name.split(".")
+        if (splittedName.length === 3) {
+            dbName = splittedName[0]
+            oldTableName = splittedName[2]
+            if (splittedName[1] !== "") schemaName = splittedName[1]
+        } else if (splittedName.length === 2) {
+            schemaName = splittedName[0]
+            oldTableName = splittedName[1]
+        }
+
+        newTable.name = this.driver.buildTableName(
+            newTableName,
+            schemaName,
+            dbName,
+        )
+
+        // if we have tables with database which differs from database specified in config, we must change currently used database.
+        // This need because we can not rename objects from another database.
+        const currentDB = await this.getCurrentDatabase()
+        if (dbName && dbName !== currentDB) {
+            upQueries.push(new Query(`USE "${dbName}"`))
+            downQueries.push(new Query(`USE "${currentDB}"`))
+        }
+
+        // rename table
+        upQueries.push(
+            new Query(
+                `EXEC sp_rename "${this.getTablePath(
+                    oldTable,
+                )}", "${newTableName}"`,
+            ),
+        )
+        downQueries.push(
+            new Query(
+                `EXEC sp_rename "${this.getTablePath(
+                    newTable,
+                )}", "${oldTableName}"`,
+            ),
+        )
+
+        // rename primary key constraint
+        if (
+            newTable.primaryColumns.length > 0 &&
+            !newTable.primaryColumns[0].primaryKeyConstraintName
+        ) {
+            const columnNames = newTable.primaryColumns.map(
+                (column) => column.name,
+            )
+
+            const oldPkName = this.connection.namingStrategy.primaryKeyName(
+                oldTable,
+                columnNames,
+            )
+            const newPkName = this.connection.namingStrategy.primaryKeyName(
+                newTable,
+                columnNames,
+            )
+
+            // rename primary constraint
+            upQueries.push(
+                new Query(
+                    `EXEC sp_rename "${this.getTablePath(
+                        newTable,
+                    )}.${oldPkName}", "${newPkName}"`,
+                ),
+            )
+            downQueries.push(
+                new Query(
+                    `EXEC sp_rename "${this.getTablePath(
+                        newTable,
+                    )}.${newPkName}", "${oldPkName}"`,
+                ),
+            )
+        }
+
+        // rename unique constraints
+        newTable.uniques.forEach((unique) => {
+            const oldUniqueName =
+                this.connection.namingStrategy.uniqueConstraintName(
+                    oldTable,
+                    unique.columnNames,
+                )
+
+            // Skip renaming if Unique has user defined constraint name
+            if (unique.name !== oldUniqueName) return
+
+            // build new constraint name
+            const newUniqueName =
+                this.connection.namingStrategy.uniqueConstraintName(
+                    newTable,
+                    unique.columnNames,
+                )
+
+            // build queries
+            upQueries.push(
+                new Query(
+                    `EXEC sp_rename "${this.getTablePath(newTable)}.${
+                        unique.name
+                    }", "${newUniqueName}"`,
+                ),
+            )
+            downQueries.push(
+                new Query(
+                    `EXEC sp_rename "${this.getTablePath(
+                        newTable,
+                    )}.${newUniqueName}", "${unique.name}"`,
+                ),
+            )
+
+            // replace constraint name
+            unique.name = newUniqueName
+        })
+
+        // rename index constraints
+        newTable.indices.forEach((index) => {
+            const oldIndexName = this.connection.namingStrategy.indexName(
+                oldTable,
+                index.columnNames,
+                index.where,
+            )
+
+            // Skip renaming if Index has user defined constraint name
+            if (index.name !== oldIndexName) return
+
+            // build new constraint name
+            const newIndexName = this.connection.namingStrategy.indexName(
+                newTable,
+                index.columnNames,
+                index.where,
+            )
+
+            // build queries
+            upQueries.push(
+                new Query(
+                    `EXEC sp_rename "${this.getTablePath(newTable)}.${
+                        index.name
+                    }", "${newIndexName}", "INDEX"`,
+                ),
+            )
+            downQueries.push(
+                new Query(
+                    `EXEC sp_rename "${this.getTablePath(
+                        newTable,
+                    )}.${newIndexName}", "${index.name}", "INDEX"`,
+                ),
+            )
+
+            // replace constraint name
+            index.name = newIndexName
+        })
+
+        // rename foreign key constraints
+        newTable.foreignKeys.forEach((foreignKey) => {
+            const oldForeignKeyName =
+                this.connection.namingStrategy.foreignKeyName(
+                    oldTable,
+                    foreignKey.columnNames,
+                    this.getTablePath(foreignKey),
+                    foreignKey.referencedColumnNames,
+                )
+
+            // Skip renaming if foreign key has user defined constraint name
+            if (foreignKey.name !== oldForeignKeyName) return
+
+            // build new constraint name
+            const newForeignKeyName =
+                this.connection.namingStrategy.foreignKeyName(
+                    newTable,
+                    foreignKey.columnNames,
+                    this.getTablePath(foreignKey),
+                    foreignKey.referencedColumnNames,
+                )
+
+            // build queries
+            upQueries.push(
+                new Query(
+                    `EXEC sp_rename "${this.buildForeignKeyName(
+                        foreignKey.name!,
+                        schemaName,
+                        dbName,
+                    )}", "${newForeignKeyName}"`,
+                ),
+            )
+            downQueries.push(
+                new Query(
+                    `EXEC sp_rename "${this.buildForeignKeyName(
+                        newForeignKeyName,
+                        schemaName,
+                        dbName,
+                    )}", "${foreignKey.name}"`,
+                ),
+            )
+
+            // replace constraint name
+            foreignKey.name = newForeignKeyName
+        })
+
+        // change currently used database back to default db.
+        if (dbName && dbName !== currentDB) {
+            upQueries.push(new Query(`USE "${currentDB}"`))
+            downQueries.push(new Query(`USE "${dbName}"`))
+        }
+
+        await this.executeQueries(upQueries, downQueries)
+
+        // rename old table and replace it in cached tabled;
+        oldTable.name = newTable.name
+        this.replaceCachedTable(oldTable, newTable)
+    }
+
+    /**
+     * Creates a new column from the column in the table.
+     */
+    async addColumn(
+        tableOrName: Table | string,
+        column: TableColumn,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const clonedTable = table.clone()
+        const upQueries: Query[] = []
+        const downQueries: Query[] = []
+
+        upQueries.push(
+            new Query(
+                `ALTER TABLE ${this.escapePath(
+                    table,
+                )} ADD ${this.buildCreateColumnSql(
+                    table,
+                    column,
+                    false,
+                    true,
+                )}`,
+            ),
+        )
+        downQueries.push(
+            new Query(
+                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${
+                    column.name
+                }"`,
+            ),
+        )
+
+        // create or update primary key constraint
+        if (column.isPrimary) {
+            const primaryColumns = clonedTable.primaryColumns
+            // if table already have primary key, me must drop it and recreate again
+            if (primaryColumns.length > 0) {
+                const pkName = primaryColumns[0].primaryKeyConstraintName
+                    ? primaryColumns[0].primaryKeyConstraintName
+                    : this.connection.namingStrategy.primaryKeyName(
+                          clonedTable,
+                          primaryColumns.map((column) => column.name),
+                      )
+
+                const columnNames = primaryColumns
+                    .map((column) => `"${column.name}"`)
+                    .join(", ")
+
+                upQueries.push(
+                    new Query(
+                        `ALTER TABLE ${this.escapePath(
+                            table,
+                        )} DROP CONSTRAINT "${pkName}"`,
+                    ),
+                )
+                downQueries.push(
+                    new Query(
+                        `ALTER TABLE ${this.escapePath(
+                            table,
+                        )} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`,
+                    ),
+                )
+            }
+
+            primaryColumns.push(column)
+            const pkName = primaryColumns[0].primaryKeyConstraintName
+                ? primaryColumns[0].primaryKeyConstraintName
+                : this.connection.namingStrategy.primaryKeyName(
+                      clonedTable,
+                      primaryColumns.map((column) => column.name),
+                  )
+
+            const columnNames = primaryColumns
+                .map((column) => `"${column.name}"`)
+                .join(", ")
+            upQueries.push(
+                new Query(
+                    `ALTER TABLE ${this.escapePath(
+                        table,
+                    )} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`,
+                ),
+            )
+            downQueries.push(
+                new Query(
+                    `ALTER TABLE ${this.escapePath(
+                        table,
+                    )} DROP CONSTRAINT "${pkName}"`,
+                ),
+            )
+        }
+
+        // create column index
+        const columnIndex = clonedTable.indices.find(
+            (index) =>
+                index.columnNames.length === 1 &&
+                index.columnNames[0] === column.name,
+        )
+        if (columnIndex) {
+            upQueries.push(this.createIndexSql(table, columnIndex))
+            downQueries.push(this.dropIndexSql(table, columnIndex))
+        }
+
+        // create unique constraint
+        if (column.isUnique) {
+            const uniqueConstraint = new TableUnique({
+                name: this.connection.namingStrategy.uniqueConstraintName(
+                    table,
+                    [column.name],
+                ),
+                columnNames: [column.name],
+            })
+            clonedTable.uniques.push(uniqueConstraint)
+            upQueries.push(
+                new Query(
+                    `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${
+                        uniqueConstraint.name
+                    }" UNIQUE ("${column.name}")`,
+                ),
+            )
+            downQueries.push(
+                new Query(
+                    `ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${
+                        uniqueConstraint.name
+                    }"`,
+                ),
+            )
+        }
+
+        // remove default constraint
+        if (column.default !== null && column.default !== undefined) {
+            const defaultName =
+                this.connection.namingStrategy.defaultConstraintName(
+                    table,
+                    column.name,
+                )
+            downQueries.push(
+                new Query(
+                    `ALTER TABLE ${this.escapePath(
+                        table,
+                    )} DROP CONSTRAINT "${defaultName}"`,
+                ),
+            )
+        }
+
+        if (column.generatedType && column.asExpression) {
+            const parsedTableName = this.driver.parseTableName(table)
+
+            if (!parsedTableName.schema) {
+                parsedTableName.schema = await this.getCurrentSchema()
+            }
+
+            const insertQuery = this.insertTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+                value: column.asExpression,
+            })
+
+            const deleteQuery = this.deleteTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+            })
+
+            upQueries.push(insertQuery)
+            downQueries.push(deleteQuery)
+        }
+
+        await this.executeQueries(upQueries, downQueries)
+
+        clonedTable.addColumn(column)
+        this.replaceCachedTable(table, clonedTable)
+    }
+
+    /**
+     * Creates a new columns from the column in the table.
+     */
+    async addColumns(
+        tableOrName: Table | string,
+        columns: TableColumn[],
+    ): Promise<void> {
+        for (const column of columns) {
+            await this.addColumn(tableOrName, column)
+        }
+    }
+
+    /**
+     * Renames column in the given table.
+     */
+    async renameColumn(
+        tableOrName: Table | string,
+        oldTableColumnOrName: TableColumn | string,
+        newTableColumnOrName: TableColumn | string,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)
+            ? oldTableColumnOrName
+            : table.columns.find((c) => c.name === oldTableColumnOrName)
+        if (!oldColumn)
+            throw new TypeORMError(
+                `Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`,
+            )
+
+        let newColumn: TableColumn | undefined = undefined
+        if (InstanceChecker.isTableColumn(newTableColumnOrName)) {
+            newColumn = newTableColumnOrName
+        } else {
+            newColumn = oldColumn.clone()
+            newColumn.name = newTableColumnOrName
+        }
+
+        await this.changeColumn(table, oldColumn, newColumn)
+    }
+
+    /**
+     * Changes a column in the table.
+     */
+    async changeColumn(
+        tableOrName: Table | string,
+        oldTableColumnOrName: TableColumn | string,
+        newColumn: TableColumn,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        let clonedTable = table.clone()
+        const upQueries: Query[] = []
+        const downQueries: Query[] = []
+
+        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)
+            ? oldTableColumnOrName
+            : table.columns.find(
+                  (column) => column.name === oldTableColumnOrName,
+              )
+        if (!oldColumn)
+            throw new TypeORMError(
+                `Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`,
+            )
+
+        if (
+            (newColumn.isGenerated !== oldColumn.isGenerated &&
+                newColumn.generationStrategy !== "uuid") ||
+            newColumn.type !== oldColumn.type ||
+            newColumn.length !== oldColumn.length ||
+            newColumn.asExpression !== oldColumn.asExpression ||
+            newColumn.generatedType !== oldColumn.generatedType
+        ) {
+            // SQL Server does not support changing of IDENTITY column, so we must drop column and recreate it again.
+            // Also, we recreate column if column type changed
+            await this.dropColumn(table, oldColumn)
+            await this.addColumn(table, newColumn)
+
+            // update cloned table
+            clonedTable = table.clone()
+        } else {
+            if (newColumn.name !== oldColumn.name) {
+                // we need database name and schema name to rename FK constraints
+                let dbName: string | undefined = undefined
+                let schemaName: string | undefined = undefined
+                const splittedName = table.name.split(".")
+                if (splittedName.length === 3) {
+                    dbName = splittedName[0]
+                    if (splittedName[1] !== "") schemaName = splittedName[1]
+                } else if (splittedName.length === 2) {
+                    schemaName = splittedName[0]
+                }
+
+                // if we have tables with database which differs from database specified in config, we must change currently used database.
+                // This need because we can not rename objects from another database.
+                const currentDB = await this.getCurrentDatabase()
+                if (dbName && dbName !== currentDB) {
+                    upQueries.push(new Query(`USE "${dbName}"`))
+                    downQueries.push(new Query(`USE "${currentDB}"`))
+                }
+
+                // rename the column
+                upQueries.push(
+                    new Query(
+                        `EXEC sp_rename "${this.getTablePath(table)}.${
+                            oldColumn.name
+                        }", "${newColumn.name}"`,
+                    ),
+                )
+                downQueries.push(
+                    new Query(
+                        `EXEC sp_rename "${this.getTablePath(table)}.${
+                            newColumn.name
+                        }", "${oldColumn.name}"`,
+                    ),
+                )
+
+                // rename column primary key constraint
+                if (
+                    oldColumn.isPrimary === true &&
+                    !oldColumn.primaryKeyConstraintName
+                ) {
+                    const primaryColumns = clonedTable.primaryColumns
+
+                    // build old primary constraint name
+                    const columnNames = primaryColumns.map(
+                        (column) => column.name,
+                    )
+                    const oldPkName =
+                        this.connection.namingStrategy.primaryKeyName(
+                            clonedTable,
+                            columnNames,
+                        )
+
+                    // replace old column name with new column name
+                    columnNames.splice(columnNames.indexOf(oldColumn.name), 1)
+                    columnNames.push(newColumn.name)
+
+                    // build new primary constraint name
+                    const newPkName =
+                        this.connection.namingStrategy.primaryKeyName(
+                            clonedTable,
+                            columnNames,
+                        )
+
+                    // rename primary constraint
+                    upQueries.push(
+                        new Query(
+                            `EXEC sp_rename "${this.getTablePath(
+                                clonedTable,
+                            )}.${oldPkName}", "${newPkName}"`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `EXEC sp_rename "${this.getTablePath(
+                                clonedTable,
+                            )}.${newPkName}", "${oldPkName}"`,
+                        ),
+                    )
+                }
+
+                // rename index constraints
+                clonedTable.findColumnIndices(oldColumn).forEach((index) => {
+                    const oldIndexName =
+                        this.connection.namingStrategy.indexName(
+                            clonedTable,
+                            index.columnNames,
+                            index.where,
+                        )
+
+                    // Skip renaming if Index has user defined constraint name
+                    if (index.name !== oldIndexName) return
+
+                    // build new constraint name
+                    index.columnNames.splice(
+                        index.columnNames.indexOf(oldColumn.name),
+                        1,
+                    )
+                    index.columnNames.push(newColumn.name)
+                    const newIndexName =
+                        this.connection.namingStrategy.indexName(
+                            clonedTable,
+                            index.columnNames,
+                            index.where,
+                        )
+
+                    // build queries
+                    upQueries.push(
+                        new Query(
+                            `EXEC sp_rename "${this.getTablePath(
+                                clonedTable,
+                            )}.${index.name}", "${newIndexName}", "INDEX"`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `EXEC sp_rename "${this.getTablePath(
+                                clonedTable,
+                            )}.${newIndexName}", "${index.name}", "INDEX"`,
+                        ),
+                    )
+
+                    // replace constraint name
+                    index.name = newIndexName
+                })
+
+                // rename foreign key constraints
+                clonedTable
+                    .findColumnForeignKeys(oldColumn)
+                    .forEach((foreignKey) => {
+                        const foreignKeyName =
+                            this.connection.namingStrategy.foreignKeyName(
+                                clonedTable,
+                                foreignKey.columnNames,
+                                this.getTablePath(foreignKey),
+                                foreignKey.referencedColumnNames,
+                            )
+
+                        // Skip renaming if foreign key has user defined constraint name
+                        if (foreignKey.name !== foreignKeyName) return
+
+                        // build new constraint name
+                        foreignKey.columnNames.splice(
+                            foreignKey.columnNames.indexOf(oldColumn.name),
+                            1,
+                        )
+                        foreignKey.columnNames.push(newColumn.name)
+                        const newForeignKeyName =
+                            this.connection.namingStrategy.foreignKeyName(
+                                clonedTable,
+                                foreignKey.columnNames,
+                                this.getTablePath(foreignKey),
+                                foreignKey.referencedColumnNames,
+                            )
+
+                        // build queries
+                        upQueries.push(
+                            new Query(
+                                `EXEC sp_rename "${this.buildForeignKeyName(
+                                    foreignKey.name!,
+                                    schemaName,
+                                    dbName,
+                                )}", "${newForeignKeyName}"`,
+                            ),
+                        )
+                        downQueries.push(
+                            new Query(
+                                `EXEC sp_rename "${this.buildForeignKeyName(
+                                    newForeignKeyName,
+                                    schemaName,
+                                    dbName,
+                                )}", "${foreignKey.name}"`,
+                            ),
+                        )
+
+                        // replace constraint name
+                        foreignKey.name = newForeignKeyName
+                    })
+
+                // rename check constraints
+                clonedTable.findColumnChecks(oldColumn).forEach((check) => {
+                    // build new constraint name
+                    check.columnNames!.splice(
+                        check.columnNames!.indexOf(oldColumn.name),
+                        1,
+                    )
+                    check.columnNames!.push(newColumn.name)
+                    const newCheckName =
+                        this.connection.namingStrategy.checkConstraintName(
+                            clonedTable,
+                            check.expression!,
+                        )
+
+                    // build queries
+                    upQueries.push(
+                        new Query(
+                            `EXEC sp_rename "${this.getTablePath(
+                                clonedTable,
+                            )}.${check.name}", "${newCheckName}"`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `EXEC sp_rename "${this.getTablePath(
+                                clonedTable,
+                            )}.${newCheckName}", "${check.name}"`,
+                        ),
+                    )
+
+                    // replace constraint name
+                    check.name = newCheckName
+                })
+
+                // rename unique constraints
+                clonedTable.findColumnUniques(oldColumn).forEach((unique) => {
+                    const oldUniqueName =
+                        this.connection.namingStrategy.uniqueConstraintName(
+                            clonedTable,
+                            unique.columnNames,
+                        )
+
+                    // Skip renaming if Unique has user defined constraint name
+                    if (unique.name !== oldUniqueName) return
+
+                    // build new constraint name
+                    unique.columnNames.splice(
+                        unique.columnNames.indexOf(oldColumn.name),
+                        1,
+                    )
+                    unique.columnNames.push(newColumn.name)
+                    const newUniqueName =
+                        this.connection.namingStrategy.uniqueConstraintName(
+                            clonedTable,
+                            unique.columnNames,
+                        )
+
+                    // build queries
+                    upQueries.push(
+                        new Query(
+                            `EXEC sp_rename "${this.getTablePath(
+                                clonedTable,
+                            )}.${unique.name}", "${newUniqueName}"`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `EXEC sp_rename "${this.getTablePath(
+                                clonedTable,
+                            )}.${newUniqueName}", "${unique.name}"`,
+                        ),
+                    )
+
+                    // replace constraint name
+                    unique.name = newUniqueName
+                })
+
+                // rename default constraints
+                if (
+                    oldColumn.default !== null &&
+                    oldColumn.default !== undefined
+                ) {
+                    const oldDefaultName =
+                        this.connection.namingStrategy.defaultConstraintName(
+                            table,
+                            oldColumn.name,
+                        )
+                    const newDefaultName =
+                        this.connection.namingStrategy.defaultConstraintName(
+                            table,
+                            newColumn.name,
+                        )
+
+                    upQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} DROP CONSTRAINT "${oldDefaultName}"`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} ADD CONSTRAINT "${oldDefaultName}" DEFAULT ${
+                                oldColumn.default
+                            } FOR "${newColumn.name}"`,
+                        ),
+                    )
+
+                    upQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} ADD CONSTRAINT "${newDefaultName}" DEFAULT ${
+                                oldColumn.default
+                            } FOR "${newColumn.name}"`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} DROP CONSTRAINT "${newDefaultName}"`,
+                        ),
+                    )
+                }
+
+                // change currently used database back to default db.
+                if (dbName && dbName !== currentDB) {
+                    upQueries.push(new Query(`USE "${currentDB}"`))
+                    downQueries.push(new Query(`USE "${dbName}"`))
+                }
+
+                // rename old column in the Table object
+                const oldTableColumn = clonedTable.columns.find(
+                    (column) => column.name === oldColumn.name,
+                )
+                clonedTable.columns[
+                    clonedTable.columns.indexOf(oldTableColumn!)
+                ].name = newColumn.name
+                oldColumn.name = newColumn.name
+            }
+
+            if (
+                this.isColumnChanged(oldColumn, newColumn, false, false, false)
+            ) {
+                upQueries.push(
+                    new Query(
+                        `ALTER TABLE ${this.escapePath(
+                            table,
+                        )} ALTER COLUMN ${this.buildCreateColumnSql(
+                            table,
+                            newColumn,
+                            true,
+                            false,
+                            true,
+                        )}`,
+                    ),
+                )
+                downQueries.push(
+                    new Query(
+                        `ALTER TABLE ${this.escapePath(
+                            table,
+                        )} ALTER COLUMN ${this.buildCreateColumnSql(
+                            table,
+                            oldColumn,
+                            true,
+                            false,
+                            true,
+                        )}`,
+                    ),
+                )
+            }
+
+            if (this.isEnumChanged(oldColumn, newColumn)) {
+                const oldExpression = this.getEnumExpression(oldColumn)
+                const oldCheck = new TableCheck({
+                    name: this.connection.namingStrategy.checkConstraintName(
+                        table,
+                        oldExpression,
+                        true,
+                    ),
+                    expression: oldExpression,
+                })
+
+                const newExpression = this.getEnumExpression(newColumn)
+                const newCheck = new TableCheck({
+                    name: this.connection.namingStrategy.checkConstraintName(
+                        table,
+                        newExpression,
+                        true,
+                    ),
+                    expression: newExpression,
+                })
+
+                upQueries.push(this.dropCheckConstraintSql(table, oldCheck))
+                upQueries.push(this.createCheckConstraintSql(table, newCheck))
+
+                downQueries.push(this.dropCheckConstraintSql(table, newCheck))
+                downQueries.push(this.createCheckConstraintSql(table, oldCheck))
+            }
+
+            if (newColumn.isPrimary !== oldColumn.isPrimary) {
+                const primaryColumns = clonedTable.primaryColumns
+
+                // if primary column state changed, we must always drop existed constraint.
+                if (primaryColumns.length > 0) {
+                    const pkName = primaryColumns[0].primaryKeyConstraintName
+                        ? primaryColumns[0].primaryKeyConstraintName
+                        : this.connection.namingStrategy.primaryKeyName(
+                              clonedTable,
+                              primaryColumns.map((column) => column.name),
+                          )
+
+                    const columnNames = primaryColumns
+                        .map((column) => `"${column.name}"`)
+                        .join(", ")
+                    upQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} DROP CONSTRAINT "${pkName}"`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`,
+                        ),
+                    )
+                }
+
+                if (newColumn.isPrimary === true) {
+                    primaryColumns.push(newColumn)
+                    // update column in table
+                    const column = clonedTable.columns.find(
+                        (column) => column.name === newColumn.name,
+                    )
+                    column!.isPrimary = true
+                    const pkName = primaryColumns[0].primaryKeyConstraintName
+                        ? primaryColumns[0].primaryKeyConstraintName
+                        : this.connection.namingStrategy.primaryKeyName(
+                              clonedTable,
+                              primaryColumns.map((column) => column.name),
+                          )
+
+                    const columnNames = primaryColumns
+                        .map((column) => `"${column.name}"`)
+                        .join(", ")
+                    upQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} DROP CONSTRAINT "${pkName}"`,
+                        ),
+                    )
+                } else {
+                    const primaryColumn = primaryColumns.find(
+                        (c) => c.name === newColumn.name,
+                    )
+                    primaryColumns.splice(
+                        primaryColumns.indexOf(primaryColumn!),
+                        1,
+                    )
+
+                    // update column in table
+                    const column = clonedTable.columns.find(
+                        (column) => column.name === newColumn.name,
+                    )
+                    column!.isPrimary = false
+
+                    // if we have another primary keys, we must recreate constraint.
+                    if (primaryColumns.length > 0) {
+                        const pkName = primaryColumns[0]
+                            .primaryKeyConstraintName
+                            ? primaryColumns[0].primaryKeyConstraintName
+                            : this.connection.namingStrategy.primaryKeyName(
+                                  clonedTable,
+                                  primaryColumns.map((column) => column.name),
+                              )
+
+                        const columnNames = primaryColumns
+                            .map((column) => `"${column.name}"`)
+                            .join(", ")
+                        upQueries.push(
+                            new Query(
+                                `ALTER TABLE ${this.escapePath(
+                                    table,
+                                )} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`,
+                            ),
+                        )
+                        downQueries.push(
+                            new Query(
+                                `ALTER TABLE ${this.escapePath(
+                                    table,
+                                )} DROP CONSTRAINT "${pkName}"`,
+                            ),
+                        )
+                    }
+                }
+            }
+
+            if (newColumn.isUnique !== oldColumn.isUnique) {
+                if (newColumn.isUnique === true) {
+                    const uniqueConstraint = new TableUnique({
+                        name: this.connection.namingStrategy.uniqueConstraintName(
+                            table,
+                            [newColumn.name],
+                        ),
+                        columnNames: [newColumn.name],
+                    })
+                    clonedTable.uniques.push(uniqueConstraint)
+                    upQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} ADD CONSTRAINT "${
+                                uniqueConstraint.name
+                            }" UNIQUE ("${newColumn.name}")`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} DROP CONSTRAINT "${uniqueConstraint.name}"`,
+                        ),
+                    )
+                } else {
+                    const uniqueConstraint = clonedTable.uniques.find(
+                        (unique) => {
+                            return (
+                                unique.columnNames.length === 1 &&
+                                !!unique.columnNames.find(
+                                    (columnName) =>
+                                        columnName === newColumn.name,
+                                )
+                            )
+                        },
+                    )
+                    clonedTable.uniques.splice(
+                        clonedTable.uniques.indexOf(uniqueConstraint!),
+                        1,
+                    )
+                    upQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} DROP CONSTRAINT "${uniqueConstraint!.name}"`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} ADD CONSTRAINT "${
+                                uniqueConstraint!.name
+                            }" UNIQUE ("${newColumn.name}")`,
+                        ),
+                    )
+                }
+            }
+
+            if (newColumn.default !== oldColumn.default) {
+                // (note) if there is a previous default, we need to drop its constraint first
+                if (
+                    oldColumn.default !== null &&
+                    oldColumn.default !== undefined
+                ) {
+                    const defaultName =
+                        this.connection.namingStrategy.defaultConstraintName(
+                            table,
+                            oldColumn.name,
+                        )
+                    upQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} DROP CONSTRAINT "${defaultName}"`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} ADD CONSTRAINT "${defaultName}" DEFAULT ${
+                                oldColumn.default
+                            } FOR "${oldColumn.name}"`,
+                        ),
+                    )
+                }
+
+                if (
+                    newColumn.default !== null &&
+                    newColumn.default !== undefined
+                ) {
+                    const defaultName =
+                        this.connection.namingStrategy.defaultConstraintName(
+                            table,
+                            newColumn.name,
+                        )
+                    upQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} ADD CONSTRAINT "${defaultName}" DEFAULT ${
+                                newColumn.default
+                            } FOR "${newColumn.name}"`,
+                        ),
+                    )
+                    downQueries.push(
+                        new Query(
+                            `ALTER TABLE ${this.escapePath(
+                                table,
+                            )} DROP CONSTRAINT "${defaultName}"`,
+                        ),
+                    )
+                }
+            }
+
+            await this.executeQueries(upQueries, downQueries)
+            this.replaceCachedTable(table, clonedTable)
+        }
+    }
+
+    /**
+     * Changes a column in the table.
+     */
+    async changeColumns(
+        tableOrName: Table | string,
+        changedColumns: { newColumn: TableColumn; oldColumn: TableColumn }[],
+    ): Promise<void> {
+        for (const { oldColumn, newColumn } of changedColumns) {
+            await this.changeColumn(tableOrName, oldColumn, newColumn)
+        }
+    }
+
+    /**
+     * Drops column in the table.
+     */
+    async dropColumn(
+        tableOrName: Table | string,
+        columnOrName: TableColumn | string,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const column = InstanceChecker.isTableColumn(columnOrName)
+            ? columnOrName
+            : table.findColumnByName(columnOrName)
+        if (!column)
+            throw new TypeORMError(
+                `Column "${columnOrName}" was not found in table "${table.name}"`,
+            )
+
+        const clonedTable = table.clone()
+        const upQueries: Query[] = []
+        const downQueries: Query[] = []
+
+        // drop primary key constraint
+        if (column.isPrimary) {
+            const pkName = column.primaryKeyConstraintName
+                ? column.primaryKeyConstraintName
+                : this.connection.namingStrategy.primaryKeyName(
+                      clonedTable,
+                      clonedTable.primaryColumns.map((column) => column.name),
+                  )
+
+            const columnNames = clonedTable.primaryColumns
+                .map((primaryColumn) => `"${primaryColumn.name}"`)
+                .join(", ")
+
+            upQueries.push(
+                new Query(
+                    `ALTER TABLE ${this.escapePath(
+                        clonedTable,
+                    )} DROP CONSTRAINT "${pkName}"`,
+                ),
+            )
+            downQueries.push(
+                new Query(
+                    `ALTER TABLE ${this.escapePath(
+                        clonedTable,
+                    )} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`,
+                ),
+            )
+
+            // update column in table
+            const tableColumn = clonedTable.findColumnByName(column.name)
+            tableColumn!.isPrimary = false
+
+            // if primary key have multiple columns, we must recreate it without dropped column
+            if (clonedTable.primaryColumns.length > 0) {
+                const pkName = clonedTable.primaryColumns[0]
+                    .primaryKeyConstraintName
+                    ? clonedTable.primaryColumns[0].primaryKeyConstraintName
+                    : this.connection.namingStrategy.primaryKeyName(
+                          clonedTable,
+                          clonedTable.primaryColumns.map(
+                              (column) => column.name,
+                          ),
+                      )
+
+                const columnNames = clonedTable.primaryColumns
+                    .map((primaryColumn) => `"${primaryColumn.name}"`)
+                    .join(", ")
+                upQueries.push(
+                    new Query(
+                        `ALTER TABLE ${this.escapePath(
+                            clonedTable,
+                        )} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`,
+                    ),
+                )
+                downQueries.push(
+                    new Query(
+                        `ALTER TABLE ${this.escapePath(
+                            clonedTable,
+                        )} DROP CONSTRAINT "${pkName}"`,
+                    ),
+                )
+            }
+        }
+
+        // drop column index
+        const columnIndex = clonedTable.indices.find(
+            (index) =>
+                index.columnNames.length === 1 &&
+                index.columnNames[0] === column.name,
+        )
+        if (columnIndex) {
+            clonedTable.indices.splice(
+                clonedTable.indices.indexOf(columnIndex),
+                1,
+            )
+            upQueries.push(this.dropIndexSql(table, columnIndex))
+            downQueries.push(this.createIndexSql(table, columnIndex))
+        }
+
+        // drop column check
+        const columnCheck = clonedTable.checks.find(
+            (check) =>
+                !!check.columnNames &&
+                check.columnNames.length === 1 &&
+                check.columnNames[0] === column.name,
+        )
+        if (columnCheck) {
+            clonedTable.checks.splice(
+                clonedTable.checks.indexOf(columnCheck),
+                1,
+            )
+            upQueries.push(this.dropCheckConstraintSql(table, columnCheck))
+            downQueries.push(this.createCheckConstraintSql(table, columnCheck))
+        }
+
+        // drop column unique
+        const columnUnique = clonedTable.uniques.find(
+            (unique) =>
+                unique.columnNames.length === 1 &&
+                unique.columnNames[0] === column.name,
+        )
+        if (columnUnique) {
+            clonedTable.uniques.splice(
+                clonedTable.uniques.indexOf(columnUnique),
+                1,
+            )
+            upQueries.push(this.dropUniqueConstraintSql(table, columnUnique))
+            downQueries.push(
+                this.createUniqueConstraintSql(table, columnUnique),
+            )
+        }
+
+        // drop default constraint
+        if (column.default !== null && column.default !== undefined) {
+            const defaultName =
+                this.connection.namingStrategy.defaultConstraintName(
+                    table,
+                    column.name,
+                )
+            upQueries.push(
+                new Query(
+                    `ALTER TABLE ${this.escapePath(
+                        table,
+                    )} DROP CONSTRAINT "${defaultName}"`,
+                ),
+            )
+            downQueries.push(
+                new Query(
+                    `ALTER TABLE ${this.escapePath(
+                        table,
+                    )} ADD CONSTRAINT "${defaultName}" DEFAULT ${
+                        column.default
+                    } FOR "${column.name}"`,
+                ),
+            )
+        }
+
+        if (column.generatedType && column.asExpression) {
+            const parsedTableName = this.driver.parseTableName(table)
+
+            if (!parsedTableName.schema) {
+                parsedTableName.schema = await this.getCurrentSchema()
+            }
+
+            const deleteQuery = this.deleteTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+            })
+            const insertQuery = this.insertTypeormMetadataSql({
+                database: parsedTableName.database,
+                schema: parsedTableName.schema,
+                table: parsedTableName.tableName,
+                type: MetadataTableType.GENERATED_COLUMN,
+                name: column.name,
+                value: column.asExpression,
+            })
+
+            upQueries.push(deleteQuery)
+            downQueries.push(insertQuery)
+        }
+
+        upQueries.push(
+            new Query(
+                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${
+                    column.name
+                }"`,
+            ),
+        )
+        downQueries.push(
+            new Query(
+                `ALTER TABLE ${this.escapePath(
+                    table,
+                )} ADD ${this.buildCreateColumnSql(
+                    table,
+                    column,
+                    false,
+                    false,
+                )}`,
+            ),
+        )
+
+        await this.executeQueries(upQueries, downQueries)
+
+        clonedTable.removeColumn(column)
+        this.replaceCachedTable(table, clonedTable)
+    }
+
+    /**
+     * Drops the columns in the table.
+     */
+    async dropColumns(
+        tableOrName: Table | string,
+        columns: TableColumn[] | string[],
+    ): Promise<void> {
+        for (const column of columns) {
+            await this.dropColumn(tableOrName, column)
+        }
+    }
+
+    /**
+     * Creates a new primary key.
+     */
+    async createPrimaryKey(
+        tableOrName: Table | string,
+        columnNames: string[],
+        constraintName?: string,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const clonedTable = table.clone()
+
+        const up = this.createPrimaryKeySql(table, columnNames, constraintName)
+
+        // mark columns as primary, because dropPrimaryKeySql build constraint name from table primary column names.
+        clonedTable.columns.forEach((column) => {
+            if (columnNames.find((columnName) => columnName === column.name))
+                column.isPrimary = true
+        })
+        const down = this.dropPrimaryKeySql(clonedTable)
+
+        await this.executeQueries(up, down)
+        this.replaceCachedTable(table, clonedTable)
+    }
+
+    /**
+     * Updates composite primary keys.
+     */
+    async updatePrimaryKeys(
+        tableOrName: Table | string,
+        columns: TableColumn[],
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const clonedTable = table.clone()
+        const columnNames = columns.map((column) => column.name)
+        const upQueries: Query[] = []
+        const downQueries: Query[] = []
+
+        // if table already have primary columns, we must drop them.
+        const primaryColumns = clonedTable.primaryColumns
+        if (primaryColumns.length > 0) {
+            const pkName = primaryColumns[0].primaryKeyConstraintName
+                ? primaryColumns[0].primaryKeyConstraintName
+                : this.connection.namingStrategy.primaryKeyName(
+                      clonedTable,
+                      primaryColumns.map((column) => column.name),
+                  )
+
+            const columnNamesString = primaryColumns
+                .map((column) => `"${column.name}"`)
+                .join(", ")
+
+            upQueries.push(
+                new Query(
+                    `ALTER TABLE ${this.escapePath(
+                        table,
+                    )} DROP CONSTRAINT "${pkName}"`,
+                ),
+            )
+            downQueries.push(
+                new Query(
+                    `ALTER TABLE ${this.escapePath(
+                        table,
+                    )} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`,
+                ),
+            )
+        }
+
+        // update columns in table.
+        clonedTable.columns
+            .filter((column) => columnNames.indexOf(column.name) !== -1)
+            .forEach((column) => (column.isPrimary = true))
+
+        const pkName = primaryColumns[0].primaryKeyConstraintName
+            ? primaryColumns[0].primaryKeyConstraintName
+            : this.connection.namingStrategy.primaryKeyName(
+                  clonedTable,
+                  columnNames,
+              )
+
+        const columnNamesString = columnNames
+            .map((columnName) => `"${columnName}"`)
+            .join(", ")
+
+        upQueries.push(
+            new Query(
+                `ALTER TABLE ${this.escapePath(
+                    table,
+                )} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`,
+            ),
+        )
+        downQueries.push(
+            new Query(
+                `ALTER TABLE ${this.escapePath(
+                    table,
+                )} DROP CONSTRAINT "${pkName}"`,
+            ),
+        )
+
+        await this.executeQueries(upQueries, downQueries)
+        this.replaceCachedTable(table, clonedTable)
+    }
+
+    /**
+     * Drops a primary key.
+     */
+    async dropPrimaryKey(
+        tableOrName: Table | string,
+        constraintName?: string,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const up = this.dropPrimaryKeySql(table)
+        const down = this.createPrimaryKeySql(
+            table,
+            table.primaryColumns.map((column) => column.name),
+            constraintName,
+        )
+        await this.executeQueries(up, down)
+        table.primaryColumns.forEach((column) => {
+            column.isPrimary = false
+        })
+    }
+
+    /**
+     * Creates a new unique constraint.
+     */
+    async createUniqueConstraint(
+        tableOrName: Table | string,
+        uniqueConstraint: TableUnique,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+
+        // new unique constraint may be passed without name. In this case we generate unique name manually.
+        if (!uniqueConstraint.name)
+            uniqueConstraint.name =
+                this.connection.namingStrategy.uniqueConstraintName(
+                    table,
+                    uniqueConstraint.columnNames,
+                )
+
+        const up = this.createUniqueConstraintSql(table, uniqueConstraint)
+        const down = this.dropUniqueConstraintSql(table, uniqueConstraint)
+        await this.executeQueries(up, down)
+        table.addUniqueConstraint(uniqueConstraint)
+    }
+
+    /**
+     * Creates a new unique constraints.
+     */
+    async createUniqueConstraints(
+        tableOrName: Table | string,
+        uniqueConstraints: TableUnique[],
+    ): Promise<void> {
+        const promises = uniqueConstraints.map((uniqueConstraint) =>
+            this.createUniqueConstraint(tableOrName, uniqueConstraint),
+        )
+        await Promise.all(promises)
+    }
+
+    /**
+     * Drops unique constraint.
+     */
+    async dropUniqueConstraint(
+        tableOrName: Table | string,
+        uniqueOrName: TableUnique | string,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName)
+            ? uniqueOrName
+            : table.uniques.find((u) => u.name === uniqueOrName)
+        if (!uniqueConstraint)
+            throw new TypeORMError(
+                `Supplied unique constraint was not found in table ${table.name}`,
+            )
+
+        const up = this.dropUniqueConstraintSql(table, uniqueConstraint)
+        const down = this.createUniqueConstraintSql(table, uniqueConstraint)
+        await this.executeQueries(up, down)
+        table.removeUniqueConstraint(uniqueConstraint)
+    }
+
+    /**
+     * Drops an unique constraints.
+     */
+    async dropUniqueConstraints(
+        tableOrName: Table | string,
+        uniqueConstraints: TableUnique[],
+    ): Promise<void> {
+        const promises = uniqueConstraints.map((uniqueConstraint) =>
+            this.dropUniqueConstraint(tableOrName, uniqueConstraint),
+        )
+        await Promise.all(promises)
+    }
+
+    /**
+     * Creates a new check constraint.
+     */
+    async createCheckConstraint(
+        tableOrName: Table | string,
+        checkConstraint: TableCheck,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+
+        // new unique constraint may be passed without name. In this case we generate unique name manually.
+        if (!checkConstraint.name)
+            checkConstraint.name =
+                this.connection.namingStrategy.checkConstraintName(
+                    table,
+                    checkConstraint.expression!,
+                )
+
+        const up = this.createCheckConstraintSql(table, checkConstraint)
+        const down = this.dropCheckConstraintSql(table, checkConstraint)
+        await this.executeQueries(up, down)
+        table.addCheckConstraint(checkConstraint)
+    }
+
+    /**
+     * Creates a new check constraints.
+     */
+    async createCheckConstraints(
+        tableOrName: Table | string,
+        checkConstraints: TableCheck[],
+    ): Promise<void> {
+        const promises = checkConstraints.map((checkConstraint) =>
+            this.createCheckConstraint(tableOrName, checkConstraint),
+        )
+        await Promise.all(promises)
+    }
+
+    /**
+     * Drops check constraint.
+     */
+    async dropCheckConstraint(
+        tableOrName: Table | string,
+        checkOrName: TableCheck | string,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const checkConstraint = InstanceChecker.isTableCheck(checkOrName)
+            ? checkOrName
+            : table.checks.find((c) => c.name === checkOrName)
+        if (!checkConstraint)
+            throw new TypeORMError(
+                `Supplied check constraint was not found in table ${table.name}`,
+            )
+
+        const up = this.dropCheckConstraintSql(table, checkConstraint)
+        const down = this.createCheckConstraintSql(table, checkConstraint)
+        await this.executeQueries(up, down)
+        table.removeCheckConstraint(checkConstraint)
+    }
+
+    /**
+     * Drops check constraints.
+     */
+    async dropCheckConstraints(
+        tableOrName: Table | string,
+        checkConstraints: TableCheck[],
+    ): Promise<void> {
+        const promises = checkConstraints.map((checkConstraint) =>
+            this.dropCheckConstraint(tableOrName, checkConstraint),
+        )
+        await Promise.all(promises)
+    }
+
+    /**
+     * Creates a new exclusion constraint.
+     */
+    async createExclusionConstraint(
+        tableOrName: Table | string,
+        exclusionConstraint: TableExclusion,
+    ): Promise<void> {
+        throw new TypeORMError(
+            `SqlServer does not support exclusion constraints.`,
+        )
+    }
+
+    /**
+     * Creates a new exclusion constraints.
+     */
+    async createExclusionConstraints(
+        tableOrName: Table | string,
+        exclusionConstraints: TableExclusion[],
+    ): Promise<void> {
+        throw new TypeORMError(
+            `SqlServer does not support exclusion constraints.`,
+        )
+    }
+
+    /**
+     * Drops exclusion constraint.
+     */
+    async dropExclusionConstraint(
+        tableOrName: Table | string,
+        exclusionOrName: TableExclusion | string,
+    ): Promise<void> {
+        throw new TypeORMError(
+            `SqlServer does not support exclusion constraints.`,
+        )
+    }
+
+    /**
+     * Drops exclusion constraints.
+     */
+    async dropExclusionConstraints(
+        tableOrName: Table | string,
+        exclusionConstraints: TableExclusion[],
+    ): Promise<void> {
+        throw new TypeORMError(
+            `SqlServer does not support exclusion constraints.`,
+        )
+    }
+
+    /**
+     * Creates a new foreign key.
+     */
+    async createForeignKey(
+        tableOrName: Table | string,
+        foreignKey: TableForeignKey,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const metadata = this.connection.hasMetadata(table.name)
+            ? this.connection.getMetadata(table.name)
+            : undefined
+
+        if (
+            metadata &&
+            metadata.treeParentRelation &&
+            metadata.treeParentRelation!.isTreeParent &&
+            metadata.foreignKeys.find(
+                (foreignKey) => foreignKey.onDelete !== "NO ACTION",
+            )
+        )
+            throw new TypeORMError(
+                "SqlServer does not support options in TreeParent.",
+            )
+
+        // new FK may be passed without name. In this case we generate FK name manually.
+        if (!foreignKey.name)
+            foreignKey.name = this.connection.namingStrategy.foreignKeyName(
+                table,
+                foreignKey.columnNames,
+                this.getTablePath(foreignKey),
+                foreignKey.referencedColumnNames,
+            )
+
+        const up = this.createForeignKeySql(table, foreignKey)
+        const down = this.dropForeignKeySql(table, foreignKey)
+        await this.executeQueries(up, down)
+        table.addForeignKey(foreignKey)
+    }
+
+    /**
+     * Creates a new foreign keys.
+     */
+    async createForeignKeys(
+        tableOrName: Table | string,
+        foreignKeys: TableForeignKey[],
+    ): Promise<void> {
+        const promises = foreignKeys.map((foreignKey) =>
+            this.createForeignKey(tableOrName, foreignKey),
+        )
+        await Promise.all(promises)
+    }
+
+    /**
+     * Drops a foreign key from the table.
+     */
+    async dropForeignKey(
+        tableOrName: Table | string,
+        foreignKeyOrName: TableForeignKey | string,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName)
+            ? foreignKeyOrName
+            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName)
+        if (!foreignKey)
+            throw new TypeORMError(
+                `Supplied foreign key was not found in table ${table.name}`,
+            )
+
+        const up = this.dropForeignKeySql(table, foreignKey)
+        const down = this.createForeignKeySql(table, foreignKey)
+        await this.executeQueries(up, down)
+        table.removeForeignKey(foreignKey)
+    }
+
+    /**
+     * Drops a foreign keys from the table.
+     */
+    async dropForeignKeys(
+        tableOrName: Table | string,
+        foreignKeys: TableForeignKey[],
+    ): Promise<void> {
+        const promises = foreignKeys.map((foreignKey) =>
+            this.dropForeignKey(tableOrName, foreignKey),
+        )
+        await Promise.all(promises)
+    }
+
+    /**
+     * Creates a new index.
+     */
+    async createIndex(
+        tableOrName: Table | string,
+        index: TableIndex,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+
+        // new index may be passed without name. In this case we generate index name manually.
+        if (!index.name) index.name = this.generateIndexName(table, index)
+
+        const up = this.createIndexSql(table, index)
+        const down = this.dropIndexSql(table, index)
+        await this.executeQueries(up, down)
+        table.addIndex(index)
+    }
+
+    /**
+     * Creates a new indices
+     */
+    async createIndices(
+        tableOrName: Table | string,
+        indices: TableIndex[],
+    ): Promise<void> {
+        const promises = indices.map((index) =>
+            this.createIndex(tableOrName, index),
+        )
+        await Promise.all(promises)
+    }
+
+    /**
+     * Drops an index.
+     */
+    async dropIndex(
+        tableOrName: Table | string,
+        indexOrName: TableIndex | string,
+    ): Promise<void> {
+        const table = InstanceChecker.isTable(tableOrName)
+            ? tableOrName
+            : await this.getCachedTable(tableOrName)
+        const index = InstanceChecker.isTableIndex(indexOrName)
+            ? indexOrName
+            : table.indices.find((i) => i.name === indexOrName)
+        if (!index)
+            throw new TypeORMError(
+                `Supplied index was not found in table ${table.name}`,
+            )
+
+        // old index may be passed without name. In this case we generate index name manually.
+        if (!index.name) index.name = this.generateIndexName(table, index)
+
+        const up = this.dropIndexSql(table, index)
+        const down = this.createIndexSql(table, index)
+        await this.executeQueries(up, down)
+        table.removeIndex(index)
+    }
+
+    /**
+     * Drops an indices from the table.
+     */
+    async dropIndices(
+        tableOrName: Table | string,
+        indices: TableIndex[],
+    ): Promise<void> {
+        const promises = indices.map((index) =>
+            this.dropIndex(tableOrName, index),
+        )
+        await Promise.all(promises)
+    }
+
+    /**
+     * Clears all table contents.
+     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
+     */
+    async clearTable(tablePath: string): Promise<void> {
+        await this.query(`TRUNCATE TABLE ${this.escapePath(tablePath)}`)
+    }
+
+    /**
+     * Removes all tables from the currently connected database.
+     */
+    async clearDatabase(database?: string): Promise<void> {
+        if (database) {
+            const isDatabaseExist = await this.hasDatabase(database)
+            if (!isDatabaseExist) return Promise.resolve()
+        }
+
+        const isAnotherTransactionActive = this.isTransactionActive
+        if (!isAnotherTransactionActive) await this.startTransaction()
+        try {
+            let allViewsSql = database
+                ? `SELECT * FROM "${database}"."INFORMATION_SCHEMA"."VIEWS"`
+                : `SELECT * FROM "INFORMATION_SCHEMA"."VIEWS"`
+            const allViewsResults: ObjectLiteral[] = await this.query(
+                allViewsSql,
+            )
+
+            await Promise.all(
+                allViewsResults.map((viewResult) => {
+                    // 'DROP VIEW' does not allow specifying the database name as a prefix to the object name.
+                    const dropTableSql = `DROP VIEW "${viewResult["TABLE_SCHEMA"]}"."${viewResult["TABLE_NAME"]}"`
+                    return this.query(dropTableSql)
+                }),
+            )
+
+            let allTablesSql = database
+                ? `SELECT * FROM "${database}"."INFORMATION_SCHEMA"."TABLES" WHERE "TABLE_TYPE" = 'BASE TABLE'`
+                : `SELECT * FROM "INFORMATION_SCHEMA"."TABLES" WHERE "TABLE_TYPE" = 'BASE TABLE'`
+            const allTablesResults: ObjectLiteral[] = await this.query(
+                allTablesSql,
+            )
+
+            if (allTablesResults.length > 0) {
+                const tablesByCatalog: {
+                    [key: string]: {
+                        TABLE_NAME: string
+                        TABLE_SCHEMA: string
+                    }[]
+                } = allTablesResults.reduce(
+                    (c, { TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME }) => {
+                        c[TABLE_CATALOG] = c[TABLE_CATALOG] || []
+                        c[TABLE_CATALOG].push({ TABLE_SCHEMA, TABLE_NAME })
+                        return c
+                    },
+                    {},
+                )
+
+                const foreignKeysSql = Object.entries(tablesByCatalog)
+                    .map(([TABLE_CATALOG, tables]) => {
+                        const conditions = tables
+                            .map(({ TABLE_SCHEMA, TABLE_NAME }) => {
+                                return `("fk"."referenced_object_id" = OBJECT_ID('"${TABLE_CATALOG}"."${TABLE_SCHEMA}"."${TABLE_NAME}"'))`
+                            })
+                            .join(" OR ")
+
+                        return `
+                        SELECT DISTINCT '${TABLE_CATALOG}' AS                                              "TABLE_CATALOG",
+                                        OBJECT_SCHEMA_NAME("fk"."parent_object_id",
+                                                           DB_ID('${TABLE_CATALOG}')) AS                   "TABLE_SCHEMA",
+                                        OBJECT_NAME("fk"."parent_object_id", DB_ID('${TABLE_CATALOG}')) AS "TABLE_NAME",
+                                        "fk"."name" AS                                                     "CONSTRAINT_NAME"
+                        FROM "${TABLE_CATALOG}"."sys"."foreign_keys" AS "fk"
+                        WHERE (${conditions})
+                    `
+                    })
+                    .join(" UNION ALL ")
+
+                const foreignKeys: {
+                    TABLE_CATALOG: string
+                    TABLE_SCHEMA: string
+                    TABLE_NAME: string
+                    CONSTRAINT_NAME: string
+                }[] = await this.query(foreignKeysSql)
+
+                await Promise.all(
+                    foreignKeys.map(
+                        async ({
+                            TABLE_CATALOG,
+                            TABLE_SCHEMA,
+                            TABLE_NAME,
+                            CONSTRAINT_NAME,
+                        }) => {
+                            // Disable the constraint first.
+                            await this.query(
+                                `ALTER TABLE "${TABLE_CATALOG}"."${TABLE_SCHEMA}"."${TABLE_NAME}" ` +
+                                    `NOCHECK CONSTRAINT "${CONSTRAINT_NAME}"`,
+                            )
+
+                            await this.query(
+                                `ALTER TABLE "${TABLE_CATALOG}"."${TABLE_SCHEMA}"."${TABLE_NAME}" ` +
+                                    `DROP CONSTRAINT "${CONSTRAINT_NAME}" -- FROM CLEAR`,
+                            )
+                        },
+                    ),
+                )
+
+                await Promise.all(
+                    allTablesResults.map((tablesResult) => {
+                        if (tablesResult["TABLE_NAME"].startsWith("#")) {
+                            // don't try to drop temporary tables
+                            return
+                        }
+
+                        const dropTableSql = `DROP TABLE "${tablesResult["TABLE_CATALOG"]}"."${tablesResult["TABLE_SCHEMA"]}"."${tablesResult["TABLE_NAME"]}"`
+                        return this.query(dropTableSql)
+                    }),
+                )
+            }
+
+            if (!isAnotherTransactionActive) await this.commitTransaction()
+        } catch (error) {
+            try {
+                // we throw original error even if rollback thrown an error
+                if (!isAnotherTransactionActive)
+                    await this.rollbackTransaction()
+            } catch (rollbackError) {}
+            throw error
+        }
+    }
+
+    // -------------------------------------------------------------------------
+    // Protected Methods
+    // -------------------------------------------------------------------------
+
+    protected async loadViews(viewPaths?: string[]): Promise<View[]> {
+        const hasTable = await this.hasTable(this.getTypeormMetadataTableName())
+        if (!hasTable) {
+            return []
+        }
+
+        if (!viewPaths) {
+            viewPaths = []
+        }
+
+        const currentSchema = await this.getCurrentSchema()
+        const currentDatabase = await this.getCurrentDatabase()
+
+        const dbNames = viewPaths
+            .map((viewPath) => this.driver.parseTableName(viewPath).database)
+            .filter((database) => database)
+
+        if (
+            this.driver.database &&
+            !dbNames.find((dbName) => dbName === this.driver.database)
+        )
+            dbNames.push(this.driver.database)
+
+        const viewsCondition = viewPaths
+            .map((viewPath) => {
+                let { schema, tableName: name } =
+                    this.driver.parseTableName(viewPath)
+
+                if (!schema) {
+                    schema = currentSchema
+                }
+                return `("T"."SCHEMA" = '${schema}' AND "T"."NAME" = '${name}')`
+            })
+            .join(" OR ")
+
+        const query = dbNames
+            .map((dbName) => {
+                return (
+                    `SELECT "T".*, "V"."CHECK_OPTION" FROM ${this.escapePath(
+                        this.getTypeormMetadataTableName(),
+                    )} "t" ` +
+                    `INNER JOIN "${dbName}"."INFORMATION_SCHEMA"."VIEWS" "V" ON "V"."TABLE_SCHEMA" = "T"."SCHEMA" AND "v"."TABLE_NAME" = "T"."NAME" WHERE "T"."TYPE" = '${
+                        MetadataTableType.VIEW
+                    }' ${viewsCondition ? `AND (${viewsCondition})` : ""}`
+                )
+            })
+            .join(" UNION ALL ")
+
+        const dbViews = await this.query(query)
+        return dbViews.map((dbView: any) => {
+            const view = new View()
+            const db =
+                dbView["TABLE_CATALOG"] === currentDatabase
+                    ? undefined
+                    : dbView["TABLE_CATALOG"]
+            const schema =
+                dbView["schema"] === currentSchema &&
+                !this.driver.options.schema
+                    ? undefined
+                    : dbView["schema"]
+            view.database = dbView["TABLE_CATALOG"]
+            view.schema = dbView["schema"]
+            view.name = this.driver.buildTableName(dbView["name"], schema, db)
+            view.expression = dbView["value"]
+            return view
+        })
+    }
+
+    /**
+     * Loads all tables (with given names) from the database and creates a Table from them.
+     */
+    protected async loadTables(tableNames?: string[]): Promise<Table[]> {
+        // if no tables given then no need to proceed
+        if (tableNames && tableNames.length === 0) {
+            return []
+        }
+
+        const currentSchema = await this.getCurrentSchema()
+        const currentDatabase = await this.getCurrentDatabase()
+
+        const dbTables: {
+            TABLE_CATALOG: string
+            TABLE_SCHEMA: string
+            TABLE_NAME: string
+        }[] = []
+
+        if (!tableNames) {
+            const databasesSql =
+                `SELECT DISTINCT "name" ` +
+                `FROM "master"."dbo"."sysdatabases" ` +
+                `WHERE "name" NOT IN ('master', 'model', 'msdb')`
+            const dbDatabases: { name: string }[] = await this.query(
+                databasesSql,
+            )
+
+            const tablesSql = dbDatabases
+                .map(({ name }) => {
+                    return `
+                    SELECT DISTINCT
+                        "TABLE_CATALOG", "TABLE_SCHEMA", "TABLE_NAME"
+                    FROM "${name}"."INFORMATION_SCHEMA"."TABLES"
+                    WHERE
+                      "TABLE_TYPE" = 'BASE TABLE'
+                      AND
+                      "TABLE_CATALOG" = '${name}'
+                      AND
+                      ISNULL(Objectproperty(Object_id("TABLE_CATALOG" + '.' + "TABLE_SCHEMA" + '.' + "TABLE_NAME"), 'IsMSShipped'), 0) = 0
+                `
+                })
+                .join(" UNION ALL ")
+
+            dbTables.push(...(await this.query(tablesSql)))
+        } else {
+            const tableNamesByCatalog = tableNames
+                .map((tableName) => this.driver.parseTableName(tableName))
+                .reduce((c, { database, ...other }) => {
+                    database = database || currentDatabase
+                    c[database] = c[database] || []
+                    c[database].push({
+                        schema: other.schema || currentSchema,
+                        tableName: other.tableName,
+                    })
+                    return c
+                }, {} as { [key: string]: { schema: string; tableName: string }[] })
+
+            const tablesSql = Object.entries(tableNamesByCatalog)
+                .map(([database, tables]) => {
+                    const tablesCondition = tables
+                        .map(({ schema, tableName }) => {
+                            return `("TABLE_SCHEMA" = '${schema}' AND "TABLE_NAME" = '${tableName}')`
+                        })
+                        .join(" OR ")
+
+                    return `
+                    SELECT DISTINCT
+                        "TABLE_CATALOG", "TABLE_SCHEMA", "TABLE_NAME"
+                    FROM "${database}"."INFORMATION_SCHEMA"."TABLES"
+                    WHERE
+                          "TABLE_TYPE" = 'BASE TABLE' AND
+                          "TABLE_CATALOG" = '${database}' AND
+                          ${tablesCondition}
+                `
+                })
+                .join(" UNION ALL ")
+
+            dbTables.push(...(await this.query(tablesSql)))
+        }
+
+        // if tables were not found in the db, no need to proceed
+        if (dbTables.length === 0) {
+            return []
+        }
+
+        const dbTablesByCatalog = dbTables.reduce(
+            (c, { TABLE_CATALOG, ...other }) => {
+                c[TABLE_CATALOG] = c[TABLE_CATALOG] || []
+                c[TABLE_CATALOG].push(other)
+                return c
+            },
+            {} as {
+                [key: string]: { TABLE_NAME: string; TABLE_SCHEMA: string }[]
+            },
+        )
+
+        const columnsSql = Object.entries(dbTablesByCatalog)
+            .map(([TABLE_CATALOG, tables]) => {
+                const condition = tables
+                    .map(
+                        ({ TABLE_SCHEMA, TABLE_NAME }) =>
+                            `("TABLE_SCHEMA" = '${TABLE_SCHEMA}' AND "TABLE_NAME" = '${TABLE_NAME}')`,
+                    )
+                    .join("OR")
+
+                return (
+                    `SELECT "COLUMNS".*, "cc"."is_persisted", "cc"."definition" ` +
+                    `FROM "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."COLUMNS" ` +
+                    `LEFT JOIN "sys"."computed_columns" "cc" ON COL_NAME("cc"."object_id", "cc"."column_id") = "column_name" ` +
+                    `WHERE (${condition})`
+                )
+            })
+            .join(" UNION ALL ")
+
+        const constraintsSql = Object.entries(dbTablesByCatalog)
+            .map(([TABLE_CATALOG, tables]) => {
+                const conditions = tables
+                    .map(
+                        ({ TABLE_NAME, TABLE_SCHEMA }) =>
+                            `("columnUsages"."TABLE_SCHEMA" = '${TABLE_SCHEMA}' AND "columnUsages"."TABLE_NAME" = '${TABLE_NAME}')`,
+                    )
+                    .join(" OR ")
+
+                return (
+                    `SELECT "columnUsages".*, "tableConstraints"."CONSTRAINT_TYPE", "chk"."definition" ` +
+                    `FROM "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."CONSTRAINT_COLUMN_USAGE" "columnUsages" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."TABLE_CONSTRAINTS" "tableConstraints" ` +
+                    `ON ` +
+                    `"tableConstraints"."CONSTRAINT_NAME" = "columnUsages"."CONSTRAINT_NAME" AND ` +
+                    `"tableConstraints"."TABLE_SCHEMA" = "columnUsages"."TABLE_SCHEMA" AND ` +
+                    `"tableConstraints"."TABLE_NAME" = "columnUsages"."TABLE_NAME" ` +
+                    `LEFT JOIN "${TABLE_CATALOG}"."sys"."check_constraints" "chk" ` +
+                    `ON ` +
+                    `"chk"."object_id" = OBJECT_ID("columnUsages"."TABLE_CATALOG" + '.' + "columnUsages"."TABLE_SCHEMA" + '.' + "columnUsages"."CONSTRAINT_NAME") ` +
+                    `WHERE ` +
+                    `(${conditions}) AND ` +
+                    `"tableConstraints"."CONSTRAINT_TYPE" IN ('PRIMARY KEY', 'UNIQUE', 'CHECK')`
+                )
+            })
+            .join(" UNION ALL ")
+
+        const foreignKeysSql = Object.entries(dbTablesByCatalog)
+            .map(([TABLE_CATALOG, tables]) => {
+                const conditions = tables
+                    .map(
+                        ({ TABLE_NAME, TABLE_SCHEMA }) =>
+                            `("s1"."name" = '${TABLE_SCHEMA}' AND "t1"."name" = '${TABLE_NAME}')`,
+                    )
+                    .join(" OR ")
+
+                return (
+                    `SELECT "fk"."name" AS "FK_NAME", '${TABLE_CATALOG}' AS "TABLE_CATALOG", "s1"."name" AS "TABLE_SCHEMA", "t1"."name" AS "TABLE_NAME", ` +
+                    `"col1"."name" AS "COLUMN_NAME", "s2"."name" AS "REF_SCHEMA", "t2"."name" AS "REF_TABLE", "col2"."name" AS "REF_COLUMN", ` +
+                    `"fk"."delete_referential_action_desc" AS "ON_DELETE", "fk"."update_referential_action_desc" AS "ON_UPDATE" ` +
+                    `FROM "${TABLE_CATALOG}"."sys"."foreign_keys" "fk" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."sys"."foreign_key_columns" "fkc" ON "fkc"."constraint_object_id" = "fk"."object_id" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."sys"."tables" "t1" ON "t1"."object_id" = "fk"."parent_object_id" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."sys"."schemas" "s1" ON "s1"."schema_id" = "t1"."schema_id" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."sys"."tables" "t2" ON "t2"."object_id" = "fk"."referenced_object_id" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."sys"."schemas" "s2" ON "s2"."schema_id" = "t2"."schema_id" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."sys"."columns" "col1" ON "col1"."column_id" = "fkc"."parent_column_id" AND "col1"."object_id" = "fk"."parent_object_id" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."sys"."columns" "col2" ON "col2"."column_id" = "fkc"."referenced_column_id" AND "col2"."object_id" = "fk"."referenced_object_id" ` +
+                    `WHERE (${conditions})`
+                )
+            })
+            .join(" UNION ALL ")
+
+        const identityColumnsSql = Object.entries(dbTablesByCatalog)
+            .map(([TABLE_CATALOG, tables]) => {
+                const conditions = tables
+                    .map(
+                        ({ TABLE_NAME, TABLE_SCHEMA }) =>
+                            `("TABLE_SCHEMA" = '${TABLE_SCHEMA}' AND "TABLE_NAME" = '${TABLE_NAME}')`,
+                    )
+                    .join(" OR ")
+
+                return (
+                    `SELECT "TABLE_CATALOG", "TABLE_SCHEMA", "COLUMN_NAME", "TABLE_NAME" ` +
+                    `FROM "${TABLE_CATALOG}"."INFORMATION_SCHEMA"."COLUMNS" ` +
+                    `WHERE ` +
+                    `EXISTS(SELECT 1 FROM "${TABLE_CATALOG}"."sys"."columns" "S" WHERE OBJECT_ID("TABLE_CATALOG" + '.' + "TABLE_SCHEMA" + '.' + "TABLE_NAME") = "S"."OBJECT_ID" AND "COLUMN_NAME" = "S"."NAME" AND "S"."is_identity" = 1) AND ` +
+                    `(${conditions})`
+                )
+            })
+            .join(" UNION ALL ")
+
+        const dbCollationsSql = `SELECT "NAME", "COLLATION_NAME" FROM "sys"."databases"`
+
+        const indicesSql = Object.entries(dbTablesByCatalog)
+            .map(([TABLE_CATALOG, tables]) => {
+                const conditions = tables
+                    .map(
+                        ({ TABLE_NAME, TABLE_SCHEMA }) =>
+                            `("s"."name" = '${TABLE_SCHEMA}' AND "t"."name" = '${TABLE_NAME}')`,
+                    )
+                    .join(" OR ")
+
+                return (
+                    `SELECT '${TABLE_CATALOG}' AS "TABLE_CATALOG", "s"."name" AS "TABLE_SCHEMA", "t"."name" AS "TABLE_NAME", ` +
+                    `"ind"."name" AS "INDEX_NAME", "col"."name" AS "COLUMN_NAME", "ind"."is_unique" AS "IS_UNIQUE", "ind"."filter_definition" as "CONDITION" ` +
+                    `FROM "${TABLE_CATALOG}"."sys"."indexes" "ind" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."sys"."index_columns" "ic" ON "ic"."object_id" = "ind"."object_id" AND "ic"."index_id" = "ind"."index_id" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."sys"."columns" "col" ON "col"."object_id" = "ic"."object_id" AND "col"."column_id" = "ic"."column_id" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."sys"."tables" "t" ON "t"."object_id" = "ind"."object_id" ` +
+                    `INNER JOIN "${TABLE_CATALOG}"."sys"."schemas" "s" ON "s"."schema_id" = "t"."schema_id" ` +
+                    `WHERE ` +
+                    `"ind"."is_primary_key" = 0 AND "ind"."is_unique_constraint" = 0 AND "t"."is_ms_shipped" = 0 AND ` +
+                    `(${conditions})`
+                )
+            })
+            .join(" UNION ALL ")
+
+        const [
+            dbColumns,
+            dbConstraints,
+            dbForeignKeys,
+            dbIdentityColumns,
+            dbCollations,
+            dbIndices,
+        ]: ObjectLiteral[][] = await Promise.all([
+            this.query(columnsSql),
+            this.query(constraintsSql),
+            this.query(foreignKeysSql),
+            this.query(identityColumnsSql),
+            this.query(dbCollationsSql),
+            this.query(indicesSql),
+        ])
+
+        // create table schemas for loaded tables
+        return await Promise.all(
+            dbTables.map(async (dbTable) => {
+                const table = new Table()
+
+                const getSchemaFromKey = (dbObject: any, key: string) => {
+                    return dbObject[key] === currentSchema &&
+                        (!this.driver.options.schema ||
+                            this.driver.options.schema === currentSchema)
+                        ? undefined
+                        : dbObject[key]
+                }
+
+                // We do not need to join schema and database names, when db or schema is by default.
+                const db =
+                    dbTable["TABLE_CATALOG"] === currentDatabase
+                        ? undefined
+                        : dbTable["TABLE_CATALOG"]
+                const schema = getSchemaFromKey(dbTable, "TABLE_SCHEMA")
+                table.database = dbTable["TABLE_CATALOG"]
+                table.schema = dbTable["TABLE_SCHEMA"]
+                table.name = this.driver.buildTableName(
+                    dbTable["TABLE_NAME"],
+                    schema,
+                    db,
+                )
+
+                const defaultCollation = dbCollations.find(
+                    (dbCollation) =>
+                        dbCollation["NAME"] === dbTable["TABLE_CATALOG"],
+                )!
+
+                // create columns from the loaded columns
+                table.columns = await Promise.all(
+                    dbColumns
+                        .filter(
+                            (dbColumn) =>
+                                dbColumn["TABLE_NAME"] ===
+                                    dbTable["TABLE_NAME"] &&
+                                dbColumn["TABLE_SCHEMA"] ===
+                                    dbTable["TABLE_SCHEMA"] &&
+                                dbColumn["TABLE_CATALOG"] ===
+                                    dbTable["TABLE_CATALOG"],
+                        )
+                        .map(async (dbColumn) => {
+                            const columnConstraints = dbConstraints.filter(
+                                (dbConstraint) =>
+                                    dbConstraint["TABLE_NAME"] ===
+                                        dbColumn["TABLE_NAME"] &&
+                                    dbConstraint["TABLE_SCHEMA"] ===
+                                        dbColumn["TABLE_SCHEMA"] &&
+                                    dbConstraint["TABLE_CATALOG"] ===
+                                        dbColumn["TABLE_CATALOG"] &&
+                                    dbConstraint["COLUMN_NAME"] ===
+                                        dbColumn["COLUMN_NAME"],
+                            )
+
+                            const uniqueConstraints = columnConstraints.filter(
+                                (constraint) =>
+                                    constraint["CONSTRAINT_TYPE"] === "UNIQUE",
+                            )
+                            const isConstraintComposite =
+                                uniqueConstraints.every((uniqueConstraint) => {
+                                    return dbConstraints.some(
+                                        (dbConstraint) =>
+                                            dbConstraint["CONSTRAINT_TYPE"] ===
+                                                "UNIQUE" &&
+                                            dbConstraint["CONSTRAINT_NAME"] ===
+                                                uniqueConstraint[
+                                                    "CONSTRAINT_NAME"
+                                                ] &&
+                                            dbConstraint["TABLE_SCHEMA"] ===
+                                                dbColumn["TABLE_SCHEMA"] &&
+                                            dbConstraint["TABLE_CATALOG"] ===
+                                                dbColumn["TABLE_CATALOG"] &&
+                                            dbConstraint["COLUMN_NAME"] !==
+                                                dbColumn["COLUMN_NAME"],
+                                    )
+                                })
+
+                            const isGenerated = !!dbIdentityColumns.find(
+                                (column) =>
+                                    column["TABLE_NAME"] ===
+                                        dbColumn["TABLE_NAME"] &&
+                                    column["TABLE_SCHEMA"] ===
+                                        dbColumn["TABLE_SCHEMA"] &&
+                                    column["TABLE_CATALOG"] ===
+                                        dbColumn["TABLE_CATALOG"] &&
+                                    column["COLUMN_NAME"] ===
+                                        dbColumn["COLUMN_NAME"],
+                            )
+
+                            const tableColumn = new TableColumn()
+                            tableColumn.name = dbColumn["COLUMN_NAME"]
+                            tableColumn.type =
+                                dbColumn["DATA_TYPE"].toLowerCase()
+
+                            // check only columns that have length property
+                            if (
+                                this.driver.withLengthColumnTypes.indexOf(
+                                    tableColumn.type as ColumnType,
+                                ) !== -1 &&
+                                dbColumn["CHARACTER_MAXIMUM_LENGTH"]
+                            ) {
+                                const length =
+                                    dbColumn[
+                                        "CHARACTER_MAXIMUM_LENGTH"
+                                    ].toString()
+                                if (length === "-1") {
+                                    tableColumn.length = "MAX"
+                                } else {
+                                    tableColumn.length =
+                                        !this.isDefaultColumnLength(
+                                            table,
+                                            tableColumn,
+                                            length,
+                                        )
+                                            ? length
+                                            : ""
+                                }
+                            }
+
+                            if (
+                                tableColumn.type === "decimal" ||
+                                tableColumn.type === "numeric"
+                            ) {
+                                if (
+                                    dbColumn["NUMERIC_PRECISION"] !== null &&
+                                    !this.isDefaultColumnPrecision(
+                                        table,
+                                        tableColumn,
+                                        dbColumn["NUMERIC_PRECISION"],
+                                    )
+                                )
+                                    tableColumn.precision =
+                                        dbColumn["NUMERIC_PRECISION"]
+                                if (
+                                    dbColumn["NUMERIC_SCALE"] !== null &&
+                                    !this.isDefaultColumnScale(
+                                        table,
+                                        tableColumn,
+                                        dbColumn["NUMERIC_SCALE"],
+                                    )
+                                )
+                                    tableColumn.scale =
+                                        dbColumn["NUMERIC_SCALE"]
+                            }
+
+                            if (tableColumn.type === "nvarchar") {
+                                // Check if this is an enum
+                                const columnCheckConstraints =
+                                    columnConstraints.filter(
+                                        (constraint) =>
+                                            constraint["CONSTRAINT_TYPE"] ===
+                                            "CHECK",
+                                    )
+                                if (columnCheckConstraints.length) {
+                                    // const isEnumRegexp = new RegExp("^\\(\\[" + tableColumn.name + "\\]='[^']+'(?: OR \\[" + tableColumn.name + "\\]='[^']+')*\\)$");
+                                    for (const checkConstraint of columnCheckConstraints) {
+                                        if (
+                                            this.isEnumCheckConstraint(
+                                                checkConstraint[
+                                                    "CONSTRAINT_NAME"
+                                                ],
+                                            )
+                                        ) {
+                                            // This is an enum constraint, make column into an enum
+                                            tableColumn.enum = []
+                                            const enumValueRegexp = new RegExp(
+                                                "\\[" +
+                                                    tableColumn.name +
+                                                    "\\]='([^']+)'",
+                                                "g",
+                                            )
+                                            let result
+                                            while (
+                                                (result = enumValueRegexp.exec(
+                                                    checkConstraint[
+                                                        "definition"
+                                                    ],
+                                                )) !== null
+                                            ) {
+                                                tableColumn.enum.unshift(
+                                                    result[1],
+                                                )
+                                            }
+                                            // Skip other column constraints
+                                            break
+                                        }
+                                    }
+                                }
+                            }
+
+                            const primaryConstraint = columnConstraints.find(
+                                (constraint) =>
+                                    constraint["CONSTRAINT_TYPE"] ===
+                                    "PRIMARY KEY",
+                            )
+                            if (primaryConstraint) {
+                                tableColumn.isPrimary = true
+                                // find another columns involved in primary key constraint
+                                const anotherPrimaryConstraints =
+                                    dbConstraints.filter(
+                                        (constraint) =>
+                                            constraint["TABLE_NAME"] ===
+                                                dbColumn["TABLE_NAME"] &&
+                                            constraint["TABLE_SCHEMA"] ===
+                                                dbColumn["TABLE_SCHEMA"] &&
+                                            constraint["TABLE_CATALOG"] ===
+                                                dbColumn["TABLE_CATALOG"] &&
+                                            constraint["COLUMN_NAME"] !==
+                                                dbColumn["COLUMN_NAME"] &&
+                                            constraint["CONSTRAINT_TYPE"] ===
+                                                "PRIMARY KEY",
+                                    )
+
+                                // collect all column names
+                                const columnNames =
+                                    anotherPrimaryConstraints.map(
+                                        (constraint) =>
+                                            constraint["COLUMN_NAME"],
+                                    )
+                                columnNames.push(dbColumn["COLUMN_NAME"])
+
+                                // build default primary key constraint name
+                                const pkName =
+                                    this.connection.namingStrategy.primaryKeyName(
+                                        table,
+                                        columnNames,
+                                    )
+
+                                // if primary key has user-defined constraint name, write it in table column
+                                if (
+                                    primaryConstraint["CONSTRAINT_NAME"] !==
+                                    pkName
+                                ) {
+                                    tableColumn.primaryKeyConstraintName =
+                                        primaryConstraint["CONSTRAINT_NAME"]
+                                }
+                            }
+
+                            tableColumn.default =
+                                dbColumn["COLUMN_DEFAULT"] !== null &&
+                                dbColumn["COLUMN_DEFAULT"] !== undefined
+                                    ? this.removeParenthesisFromDefault(
+                                          dbColumn["COLUMN_DEFAULT"],
+                                      )
+                                    : undefined
+                            tableColumn.isNullable =
+                                dbColumn["IS_NULLABLE"] === "YES"
+                            tableColumn.isUnique =
+                                uniqueConstraints.length > 0 &&
+                                !isConstraintComposite
+                            tableColumn.isGenerated = isGenerated
+                            if (isGenerated)
+                                tableColumn.generationStrategy = "increment"
+                            if (tableColumn.default === "newsequentialid()") {
+                                tableColumn.isGenerated = true
+                                tableColumn.generationStrategy = "uuid"
+                                tableColumn.default = undefined
+                            }
+
+                            // todo: unable to get default charset
+                            // tableColumn.charset = dbColumn["CHARACTER_SET_NAME"];
+                            if (dbColumn["COLLATION_NAME"])
+                                tableColumn.collation =
+                                    dbColumn["COLLATION_NAME"] ===
+                                    defaultCollation["COLLATION_NAME"]
+                                        ? undefined
+                                        : dbColumn["COLLATION_NAME"]
+
+                            if (
+                                tableColumn.type === "datetime2" ||
+                                tableColumn.type === "time" ||
+                                tableColumn.type === "datetimeoffset"
+                            ) {
+                                tableColumn.precision =
+                                    !this.isDefaultColumnPrecision(
+                                        table,
+                                        tableColumn,
+                                        dbColumn["DATETIME_PRECISION"],
+                                    )
+                                        ? dbColumn["DATETIME_PRECISION"]
+                                        : undefined
+                            }
+
+                            if (
+                                dbColumn["is_persisted"] !== null &&
+                                dbColumn["is_persisted"] !== undefined &&
+                                dbColumn["definition"]
+                            ) {
+                                tableColumn.generatedType =
+                                    dbColumn["is_persisted"] === true
+                                        ? "STORED"
+                                        : "VIRTUAL"
+                                // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.
+                                const asExpressionQuery =
+                                    this.selectTypeormMetadataSql({
+                                        database: dbTable["TABLE_CATALOG"],
+                                        schema: dbTable["TABLE_SCHEMA"],
+                                        table: dbTable["TABLE_NAME"],
+                                        type: MetadataTableType.GENERATED_COLUMN,
+                                        name: tableColumn.name,
+                                    })
+
+                                const results = await this.query(
+                                    asExpressionQuery.query,
+                                    asExpressionQuery.parameters,
+                                )
+                                if (results[0] && results[0].value) {
+                                    tableColumn.asExpression = results[0].value
+                                } else {
+                                    tableColumn.asExpression = ""
+                                }
+                            }
+
+                            return tableColumn
+                        }),
+                )
+
+                // find unique constraints of table, group them by constraint name and build TableUnique.
+                const tableUniqueConstraints = OrmUtils.uniq(
+                    dbConstraints.filter(
+                        (dbConstraint) =>
+                            dbConstraint["TABLE_NAME"] ===
+                                dbTable["TABLE_NAME"] &&
+                            dbConstraint["TABLE_SCHEMA"] ===
+                                dbTable["TABLE_SCHEMA"] &&
+                            dbConstraint["TABLE_CATALOG"] ===
+                                dbTable["TABLE_CATALOG"] &&
+                            dbConstraint["CONSTRAINT_TYPE"] === "UNIQUE",
+                    ),
+                    (dbConstraint) => dbConstraint["CONSTRAINT_NAME"],
+                )
+
+                table.uniques = tableUniqueConstraints.map((constraint) => {
+                    const uniques = dbConstraints.filter(
+                        (dbC) =>
+                            dbC["CONSTRAINT_NAME"] ===
+                            constraint["CONSTRAINT_NAME"],
+                    )
+                    return new TableUnique({
+                        name: constraint["CONSTRAINT_NAME"],
+                        columnNames: uniques.map((u) => u["COLUMN_NAME"]),
+                    })
+                })
+
+                // find check constraints of table, group them by constraint name and build TableCheck.
+                const tableCheckConstraints = OrmUtils.uniq(
+                    dbConstraints.filter(
+                        (dbConstraint) =>
+                            dbConstraint["TABLE_NAME"] ===
+                                dbTable["TABLE_NAME"] &&
+                            dbConstraint["TABLE_SCHEMA"] ===
+                                dbTable["TABLE_SCHEMA"] &&
+                            dbConstraint["TABLE_CATALOG"] ===
+                                dbTable["TABLE_CATALOG"] &&
+                            dbConstraint["CONSTRAINT_TYPE"] === "CHECK",
+                    ),
+                    (dbConstraint) => dbConstraint["CONSTRAINT_NAME"],
+                )
+
+                table.checks = tableCheckConstraints
+                    .filter(
+                        (constraint) =>
+                            !this.isEnumCheckConstraint(
+                                constraint["CONSTRAINT_NAME"],
+                            ),
+                    )
+                    .map((constraint) => {
+                        const checks = dbConstraints.filter(
+                            (dbC) =>
+                                dbC["CONSTRAINT_NAME"] ===
+                                constraint["CONSTRAINT_NAME"],
+                        )
+                        return new TableCheck({
+                            name: constraint["CONSTRAINT_NAME"],
+                            columnNames: checks.map((c) => c["COLUMN_NAME"]),
+                            expression: constraint["definition"],
+                        })
+                    })
+
+                // find foreign key constraints of table, group them by constraint name and build TableForeignKey.
+                const tableForeignKeyConstraints = OrmUtils.uniq(
+                    dbForeignKeys.filter(
+                        (dbForeignKey) =>
+                            dbForeignKey["TABLE_NAME"] ===
+                                dbTable["TABLE_NAME"] &&
+                            dbForeignKey["TABLE_SCHEMA"] ===
+                                dbTable["TABLE_SCHEMA"] &&
+                            dbForeignKey["TABLE_CATALOG"] ===
+                                dbTable["TABLE_CATALOG"],
+                    ),
+                    (dbForeignKey) => dbForeignKey["FK_NAME"],
+                )
+
+                table.foreignKeys = tableForeignKeyConstraints.map(
+                    (dbForeignKey) => {
+                        const foreignKeys = dbForeignKeys.filter(
+                            (dbFk) =>
+                                dbFk["FK_NAME"] === dbForeignKey["FK_NAME"],
+                        )
+
+                        // if referenced table located in currently used db and schema, we don't need to concat db and schema names to table name.
+                        const db =
+                            dbForeignKey["TABLE_CATALOG"] === currentDatabase
+                                ? undefined
+                                : dbForeignKey["TABLE_CATALOG"]
+                        const schema = getSchemaFromKey(
+                            dbForeignKey,
+                            "REF_SCHEMA",
+                        )
+                        const referencedTableName = this.driver.buildTableName(
+                            dbForeignKey["REF_TABLE"],
+                            schema,
+                            db,
+                        )
+
+                        return new TableForeignKey({
+                            name: dbForeignKey["FK_NAME"],
+                            columnNames: foreignKeys.map(
+                                (dbFk) => dbFk["COLUMN_NAME"],
+                            ),
+                            referencedDatabase: dbForeignKey["TABLE_CATALOG"],
+                            referencedSchema: dbForeignKey["REF_SCHEMA"],
+                            referencedTableName: referencedTableName,
+                            referencedColumnNames: foreignKeys.map(
+                                (dbFk) => dbFk["REF_COLUMN"],
+                            ),
+                            onDelete: dbForeignKey["ON_DELETE"].replace(
+                                "_",
+                                " ",
+                            ), // SqlServer returns NO_ACTION, instead of NO ACTION
+                            onUpdate: dbForeignKey["ON_UPDATE"].replace(
+                                "_",
+                                " ",
+                            ), // SqlServer returns NO_ACTION, instead of NO ACTION
+                        })
+                    },
+                )
+
+                // find index constraints of table, group them by constraint name and build TableIndex.
+                const tableIndexConstraints = OrmUtils.uniq(
+                    dbIndices.filter(
+                        (dbIndex) =>
+                            dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] &&
+                            dbIndex["TABLE_SCHEMA"] ===
+                                dbTable["TABLE_SCHEMA"] &&
+                            dbIndex["TABLE_CATALOG"] ===
+                                dbTable["TABLE_CATALOG"],
+                    ),
+                    (dbIndex) => dbIndex["INDEX_NAME"],
+                )
+
+                table.indices = tableIndexConstraints.map((constraint) => {
+                    const indices = dbIndices.filter((index) => {
+                        return (
+                            index["TABLE_CATALOG"] ===
+                                constraint["TABLE_CATALOG"] &&
+                            index["TABLE_SCHEMA"] ===
+                                constraint["TABLE_SCHEMA"] &&
+                            index["TABLE_NAME"] === constraint["TABLE_NAME"] &&
+                            index["INDEX_NAME"] === constraint["INDEX_NAME"]
+                        )
+                    })
+                    return new TableIndex(<TableIndexOptions>{
+                        table: table,
+                        name: constraint["INDEX_NAME"],
+                        columnNames: indices.map((i) => i["COLUMN_NAME"]),
+                        isUnique: constraint["IS_UNIQUE"],
+                        where: constraint["CONDITION"],
+                    })
+                })
+
+                return table
+            }),
+        )
+    }
+
+    /**
+     * Builds and returns SQL for create table.
+     */
+    protected createTableSql(table: Table, createForeignKeys?: boolean): Query {
+        const columnDefinitions = table.columns
+            .map((column) =>
+                this.buildCreateColumnSql(table, column, false, true),
+            )
+            .join(", ")
+        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`
+
+        table.columns
+            .filter((column) => column.isUnique)
+            .forEach((column) => {
+                const isUniqueExist = table.uniques.some(
+                    (unique) =>
+                        unique.columnNames.length === 1 &&
+                        unique.columnNames[0] === column.name,
+                )
+                if (!isUniqueExist)
+                    table.uniques.push(
+                        new TableUnique({
+                            name: this.connection.namingStrategy.uniqueConstraintName(
+                                table,
+                                [column.name],
+                            ),
+                            columnNames: [column.name],
+                        }),
+                    )
+            })
+
+        if (table.uniques.length > 0) {
+            const uniquesSql = table.uniques
+                .map((unique) => {
+                    const uniqueName = unique.name
+                        ? unique.name
+                        : this.connection.namingStrategy.uniqueConstraintName(
+                              table,
+                              unique.columnNames,
+                          )
+                    const columnNames = unique.columnNames
+                        .map((columnName) => `"${columnName}"`)
+                        .join(", ")
+                    return `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`
+                })
+                .join(", ")
+
+            sql += `, ${uniquesSql}`
+        }
+
+        if (table.checks.length > 0) {
+            const checksSql = table.checks
+                .map((check) => {
+                    const checkName = check.name
+                        ? check.name
+                        : this.connection.namingStrategy.checkConstraintName(
+                              table,
+                              check.expression!,
+                          )
+                    return `CONSTRAINT "${checkName}" CHECK (${check.expression})`
+                })
+                .join(", ")
+
+            sql += `, ${checksSql}`
+        }
+
+        if (table.foreignKeys.length > 0 && createForeignKeys) {
+            const foreignKeysSql = table.foreignKeys
+                .map((fk) => {
+                    const columnNames = fk.columnNames
+                        .map((columnName) => `"${columnName}"`)
+                        .join(", ")
+                    if (!fk.name)
+                        fk.name = this.connection.namingStrategy.foreignKeyName(
+                            table,
+                            fk.columnNames,
+                            this.getTablePath(fk),
+                            fk.referencedColumnNames,
+                        )
+                    const referencedColumnNames = fk.referencedColumnNames
+                        .map((columnName) => `"${columnName}"`)
+                        .join(", ")
+
+                    let constraint = `CONSTRAINT "${
+                        fk.name
+                    }" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(
+                        this.getTablePath(fk),
+                    )} (${referencedColumnNames})`
+                    if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`
+                    if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`
+
+                    return constraint
+                })
+                .join(", ")
+
+            sql += `, ${foreignKeysSql}`
+        }
+
+        const primaryColumns = table.columns.filter(
+            (column) => column.isPrimary,
+        )
+        if (primaryColumns.length > 0) {
+            const primaryKeyName = primaryColumns[0].primaryKeyConstraintName
+                ? primaryColumns[0].primaryKeyConstraintName
+                : this.connection.namingStrategy.primaryKeyName(
+                      table,
+                      primaryColumns.map((column) => column.name),
+                  )
+
+            const columnNames = primaryColumns
+                .map((column) => `"${column.name}"`)
+                .join(", ")
+            sql += `, CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNames})`
+        }
+
+        sql += `)`
+
+        return new Query(sql)
+    }
+
+    /**
+     * Builds drop table sql.
+     */
+    protected dropTableSql(
+        tableOrName: Table | string,
+        ifExist?: boolean,
+    ): Query {
+        const query = ifExist
+            ? `DROP TABLE IF EXISTS ${this.escapePath(tableOrName)}`
+            : `DROP TABLE ${this.escapePath(tableOrName)}`
+        return new Query(query)
+    }
+
+    protected createViewSql(view: View): Query {
+        const parsedName = this.driver.parseTableName(view)
+
+        // Can't use `escapePath` here because `CREATE VIEW` does not accept database names.
+        const viewIdentifier = parsedName.schema
+            ? `"${parsedName.schema}"."${parsedName.tableName}"`
+            : `"${parsedName.tableName}"`
+
+        if (typeof view.expression === "string") {
+            return new Query(
+                `CREATE VIEW ${viewIdentifier} AS ${view.expression}`,
+            )
+        } else {
+            return new Query(
+                `CREATE VIEW ${viewIdentifier} AS ${view
+                    .expression(this.connection)
+                    .getQuery()}`,
+            )
+        }
+    }
+
+    protected async insertViewDefinitionSql(view: View): Promise<Query> {
+        const parsedTableName = this.driver.parseTableName(view)
+
+        if (!parsedTableName.schema) {
+            parsedTableName.schema = await this.getCurrentSchema()
+        }
+
+        const expression =
+            typeof view.expression === "string"
+                ? view.expression.trim()
+                : view.expression(this.connection).getQuery()
+        return this.insertTypeormMetadataSql({
+            type: MetadataTableType.VIEW,
+            database: parsedTableName.database,
+            schema: parsedTableName.schema,
+            name: parsedTableName.tableName,
+            value: expression,
+        })
+    }
+
+    /**
+     * Builds drop view sql.
+     */
+    protected dropViewSql(viewOrPath: View | string): Query {
+        return new Query(`DROP VIEW ${this.escapePath(viewOrPath)}`)
+    }
+
+    /**
+     * Builds remove view sql.
+     */
+    protected async deleteViewDefinitionSql(
+        viewOrPath: View | string,
+    ): Promise<Query> {
+        const parsedTableName = this.driver.parseTableName(viewOrPath)
+
+        if (!parsedTableName.schema) {
+            parsedTableName.schema = await this.getCurrentSchema()
+        }
+
+        return this.deleteTypeormMetadataSql({
+            type: MetadataTableType.VIEW,
+            database: parsedTableName.database,
+            schema: parsedTableName.schema,
+            name: parsedTableName.tableName,
+        })
+    }
+
+    /**
+     * Builds create index sql.
+     */
+    protected createIndexSql(table: Table, index: TableIndex): Query {
+        const columns = index.columnNames
+            .map((columnName) => `"${columnName}"`)
+            .join(", ")
+        return new Query(
+            `CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX "${
+                index.name
+            }" ON ${this.escapePath(table)} (${columns}) ${
+                index.where ? "WHERE " + index.where : ""
+            }`,
+        )
+    }
+
+    /**
+     * Builds drop index sql.
+     */
+    protected dropIndexSql(
+        table: Table,
+        indexOrName: TableIndex | string,
+    ): Query {
+        let indexName = InstanceChecker.isTableIndex(indexOrName)
+            ? indexOrName.name
+            : indexOrName
+        return new Query(
+            `DROP INDEX "${indexName}" ON ${this.escapePath(table)}`,
+        )
+    }
+
+    /**
+     * Builds create primary key sql.
+     */
+    protected createPrimaryKeySql(
+        table: Table,
+        columnNames: string[],
+        constraintName?: string,
+    ): Query {
+        const primaryKeyName = constraintName
+            ? constraintName
+            : this.connection.namingStrategy.primaryKeyName(table, columnNames)
+
+        const columnNamesString = columnNames
+            .map((columnName) => `"${columnName}"`)
+            .join(", ")
+        return new Query(
+            `ALTER TABLE ${this.escapePath(
+                table,
+            )} ADD CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNamesString})`,
+        )
+    }
+
+    /**
+     * Builds drop primary key sql.
+     */
+    protected dropPrimaryKeySql(table: Table): Query {
+        const columnNames = table.primaryColumns.map((column) => column.name)
+        const constraintName = table.primaryColumns[0].primaryKeyConstraintName
+        const primaryKeyName = constraintName
+            ? constraintName
+            : this.connection.namingStrategy.primaryKeyName(table, columnNames)
+
+        return new Query(
+            `ALTER TABLE ${this.escapePath(
+                table,
+            )} DROP CONSTRAINT "${primaryKeyName}"`,
+        )
+    }
+
+    /**
+     * Builds create unique constraint sql.
+     */
+    protected createUniqueConstraintSql(
+        table: Table,
+        uniqueConstraint: TableUnique,
+    ): Query {
+        const columnNames = uniqueConstraint.columnNames
+            .map((column) => `"` + column + `"`)
+            .join(", ")
+        return new Query(
+            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${
+                uniqueConstraint.name
+            }" UNIQUE (${columnNames})`,
+        )
+    }
+
+    /**
+     * Builds drop unique constraint sql.
+     */
+    protected dropUniqueConstraintSql(
+        table: Table,
+        uniqueOrName: TableUnique | string,
+    ): Query {
+        const uniqueName = InstanceChecker.isTableUnique(uniqueOrName)
+            ? uniqueOrName.name
+            : uniqueOrName
+        return new Query(
+            `ALTER TABLE ${this.escapePath(
+                table,
+            )} DROP CONSTRAINT "${uniqueName}"`,
+        )
+    }
+
+    /**
+     * Builds create check constraint sql.
+     */
+    protected createCheckConstraintSql(
+        table: Table,
+        checkConstraint: TableCheck,
+    ): Query {
+        return new Query(
+            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${
+                checkConstraint.name
+            }" CHECK (${checkConstraint.expression})`,
+        )
+    }
+
+    /**
+     * Builds drop check constraint sql.
+     */
+    protected dropCheckConstraintSql(
+        table: Table,
+        checkOrName: TableCheck | string,
+    ): Query {
+        const checkName = InstanceChecker.isTableCheck(checkOrName)
+            ? checkOrName.name
+            : checkOrName
+        return new Query(
+            `ALTER TABLE ${this.escapePath(
+                table,
+            )} DROP CONSTRAINT "${checkName}"`,
+        )
+    }
+
+    /**
+     * Builds create foreign key sql.
+     */
+    protected createForeignKeySql(
+        table: Table,
+        foreignKey: TableForeignKey,
+    ): Query {
+        const columnNames = foreignKey.columnNames
+            .map((column) => `"` + column + `"`)
+            .join(", ")
+        const referencedColumnNames = foreignKey.referencedColumnNames
+            .map((column) => `"` + column + `"`)
+            .join(",")
+        let sql =
+            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${
+                foreignKey.name
+            }" FOREIGN KEY (${columnNames}) ` +
+            `REFERENCES ${this.escapePath(
+                this.getTablePath(foreignKey),
+            )}(${referencedColumnNames})`
+        if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`
+        if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`
+
+        return new Query(sql)
+    }
+
+    /**
+     * Builds drop foreign key sql.
+     */
+    protected dropForeignKeySql(
+        table: Table,
+        foreignKeyOrName: TableForeignKey | string,
+    ): Query {
+        const foreignKeyName = InstanceChecker.isTableForeignKey(
+            foreignKeyOrName,
+        )
+            ? foreignKeyOrName.name
+            : foreignKeyOrName
+        return new Query(
+            `ALTER TABLE ${this.escapePath(
+                table,
+            )} DROP CONSTRAINT "${foreignKeyName}"`,
+        )
+    }
+
+    /**
+     * Escapes given table or View path.
+     */
+    protected escapePath(target: Table | View | string): string {
+        const { database, schema, tableName } =
+            this.driver.parseTableName(target)
+
+        if (database && database !== this.driver.database) {
+            if (schema && schema !== this.driver.searchSchema) {
+                return `"${database}"."${schema}"."${tableName}"`
+            }
+
+            return `"${database}".."${tableName}"`
+        }
+
+        if (schema && schema !== this.driver.searchSchema) {
+            return `"${schema}"."${tableName}"`
+        }
+
+        return `"${tableName}"`
+    }
+
+    /**
+     * Concat database name and schema name to the foreign key name.
+     * Needs because FK name is relevant to the schema and database.
+     */
+    protected buildForeignKeyName(
+        fkName: string,
+        schemaName: string | undefined,
+        dbName: string | undefined,
+    ): string {
+        let joinedFkName = fkName
+        if (schemaName && schemaName !== this.driver.searchSchema)
+            joinedFkName = schemaName + "." + joinedFkName
+        if (dbName && dbName !== this.driver.database)
+            joinedFkName = dbName + "." + joinedFkName
+
+        return joinedFkName
+    }
+
+    /**
+     * Removes parenthesis around default value.
+     * Sql server returns default value with parenthesis around, e.g.
+     *  ('My text') - for string
+     *  ((1)) - for number
+     *  (newsequentialId()) - for function
+     */
+    protected removeParenthesisFromDefault(defaultValue: string): any {
+        if (defaultValue.substr(0, 1) !== "(") return defaultValue
+        const normalizedDefault = defaultValue.substr(
+            1,
+            defaultValue.lastIndexOf(")") - 1,
+        )
+        return this.removeParenthesisFromDefault(normalizedDefault)
+    }
+
+    /**
+     * Builds a query for create column.
+     */
+    protected buildCreateColumnSql(
+        table: Table,
+        column: TableColumn,
+        skipIdentity: boolean,
+        createDefault: boolean,
+        skipEnum?: boolean,
+    ) {
+        let c = `"${column.name}" ${this.connection.driver.createFullType(
+            column,
+        )}`
+
+        if (!skipEnum && column.enum) {
+            const expression = this.getEnumExpression(column)
+            const checkName =
+                this.connection.namingStrategy.checkConstraintName(
+                    table,
+                    expression,
+                    true,
+                )
+            c += ` CONSTRAINT ${checkName} CHECK(${expression})`
+        }
+
+        if (column.collation) c += " COLLATE " + column.collation
+
+        if (column.asExpression) {
+            c += ` AS (${column.asExpression})`
+            if (column.generatedType === "STORED") {
+                c += ` PERSISTED`
+
+                // NOT NULL can be specified for computed columns only if PERSISTED is also specified
+                if (column.isNullable !== true) c += " NOT NULL"
+            }
+        } else {
+            if (column.isNullable !== true) c += " NOT NULL"
+        }
+
+        if (
+            column.isGenerated === true &&
+            column.generationStrategy === "increment" &&
+            !skipIdentity
+        )
+            // don't use skipPrimary here since updates can update already exist primary without auto inc.
+            c += " IDENTITY(1,1)"
+
+        if (
+            column.default !== undefined &&
+            column.default !== null &&
+            createDefault
+        ) {
+            // we create named constraint to be able to delete this constraint when column been dropped
+            const defaultName =
+                this.connection.namingStrategy.defaultConstraintName(
+                    table,
+                    column.name,
+                )
+            c += ` CONSTRAINT "${defaultName}" DEFAULT ${column.default}`
+        }
+
+        if (
+            column.isGenerated &&
+            column.generationStrategy === "uuid" &&
+            !column.default
+        ) {
+            // we create named constraint to be able to delete this constraint when column been dropped
+            const defaultName =
+                this.connection.namingStrategy.defaultConstraintName(
+                    table,
+                    column.name,
+                )
+            c += ` CONSTRAINT "${defaultName}" DEFAULT NEWSEQUENTIALID()`
+        }
+        return c
+    }
+
+    private getEnumExpression(column: TableColumn) {
+        if (!column.enum) {
+            throw new Error(`Enum is not defined in column ${column.name}`)
+        }
+        return (
+            column.name +
+            " IN (" +
+            column.enum.map((val) => "'" + val + "'").join(",") +
+            ")"
+        )
+    }
+
+    protected isEnumCheckConstraint(name: string): boolean {
+        return name.indexOf("CHK_") !== -1 && name.indexOf("_ENUM") !== -1
+    }
+
+    /**
+     * Converts MssqlParameter into real mssql parameter type.
+     */
+    protected mssqlParameterToNativeParameter(parameter: MssqlParameter): any {
+        switch (this.driver.normalizeType({ type: parameter.type as any })) {
+            case "bit":
+                return this.driver.mssql.Bit
+            case "bigint":
+                return this.driver.mssql.BigInt
+            case "decimal":
+                return this.driver.mssql.Decimal(...parameter.params)
+            case "float":
+                return this.driver.mssql.Float
+            case "int":
+                return this.driver.mssql.Int
+            case "money":
+                return this.driver.mssql.Money
+            case "numeric":
+                return this.driver.mssql.Numeric(...parameter.params)
+            case "smallint":
+                return this.driver.mssql.SmallInt
+            case "smallmoney":
+                return this.driver.mssql.SmallMoney
+            case "real":
+                return this.driver.mssql.Real
+            case "tinyint":
+                return this.driver.mssql.TinyInt
+            case "char":
+                if (
+                    this.driver.options.options
+                        ?.disableAsciiToUnicodeParamConversion
+                ) {
+                    return this.driver.mssql.Char(...parameter.params)
+                }
+                return this.driver.mssql.NChar(...parameter.params)
+            case "nchar":
+                return this.driver.mssql.NChar(...parameter.params)
+            case "text":
+                if (
+                    this.driver.options.options
+                        ?.disableAsciiToUnicodeParamConversion
+                ) {
+                    return this.driver.mssql.Text
+                }
+                return this.driver.mssql.Ntext
+            case "ntext":
+                return this.driver.mssql.Ntext
+            case "varchar":
+                if (
+                    this.driver.options.options
+                        ?.disableAsciiToUnicodeParamConversion
+                ) {
+                    return this.driver.mssql.VarChar(...parameter.params)
+                }
+                return this.driver.mssql.NVarChar(...parameter.params)
+            case "nvarchar":
+                return this.driver.mssql.NVarChar(...parameter.params)
+            case "xml":
+                return this.driver.mssql.Xml
+            case "time":
+                return this.driver.mssql.Time(...parameter.params)
+            case "date":
+                return this.driver.mssql.Date
+            case "datetime":
+                return this.driver.mssql.DateTime
+            case "datetime2":
+                return this.driver.mssql.DateTime2(...parameter.params)
+            case "datetimeoffset":
+                return this.driver.mssql.DateTimeOffset(...parameter.params)
+            case "smalldatetime":
+                return this.driver.mssql.SmallDateTime
+            case "uniqueidentifier":
+                return this.driver.mssql.UniqueIdentifier
+            case "variant":
+                return this.driver.mssql.Variant
+            case "binary":
+                return this.driver.mssql.Binary
+            case "varbinary":
+                return this.driver.mssql.VarBinary(...parameter.params)
+            case "image":
+                return this.driver.mssql.Image
+            case "udt":
+                return this.driver.mssql.UDT
+            case "rowversion":
+                return this.driver.mssql.RowVersion
+        }
+    }
+
+    /**
+     * Converts string literal of isolation level to enum.
+     * The underlying mssql driver requires an enum for the isolation level.
+     */
+    convertIsolationLevel(isolation: IsolationLevel) {
+        const ISOLATION_LEVEL = this.driver.mssql.ISOLATION_LEVEL
+        switch (isolation) {
+            case "READ UNCOMMITTED":
+                return ISOLATION_LEVEL.READ_UNCOMMITTED
+            case "REPEATABLE READ":
+                return ISOLATION_LEVEL.REPEATABLE_READ
+            case "SERIALIZABLE":
+                return ISOLATION_LEVEL.SERIALIZABLE
+
+            case "READ COMMITTED":
+            default:
+                return ISOLATION_LEVEL.READ_COMMITTED
+        }
+    }
+
+    /**
+     * Change table comment.
+     */
+    changeTableComment(
+        tableOrName: Table | string,
+        comment?: string,
+    ): Promise<void> {
+        throw new TypeORMError(
+            `sqlserver driver does not support change table comment.`,
+        )
+    }
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.d.ts b/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..67ad91b5c8304514e7d1c59e1856f332fc36d71b
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.d.ts
@@ -0,0 +1,10 @@
+export interface AzureActiveDirectoryAccessTokenAuthentication {
+    type: "azure-active-directory-access-token";
+    options: {
+        /**
+         * A user need to provide `token` which they retrieved else where
+         * to forming the connection.
+         */
+        token: string;
+    };
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.js b/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.js
new file mode 100644
index 0000000000000000000000000000000000000000..70aae3f70d6ac966983665985864512fd3155f40
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+
+//# sourceMappingURL=AzureActiveDirectoryAccessTokenAuthentication.js.map
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.js.map b/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..87cf9b0842566dc29df22cbe6ac89becaae030c1
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.ts"],"names":[],"mappings":"","file":"AzureActiveDirectoryAccessTokenAuthentication.js","sourcesContent":["export interface AzureActiveDirectoryAccessTokenAuthentication {\n    type: \"azure-active-directory-access-token\"\n    options: {\n        /**\n         * A user need to provide `token` which they retrieved else where\n         * to forming the connection.\n         */\n        token: string\n    }\n}\n"],"sourceRoot":"../../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.ts b/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8f8bfa72d4735a82eceb33da72d34f0e064112ff
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryAccessTokenAuthentication.ts
@@ -0,0 +1,10 @@
+export interface AzureActiveDirectoryAccessTokenAuthentication {
+    type: "azure-active-directory-access-token"
+    options: {
+        /**
+         * A user need to provide `token` which they retrieved else where
+         * to forming the connection.
+         */
+        token: string
+    }
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.d.ts b/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0c49fcd98570e31c3dddec4ee01ffddfe7a87fe3
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.d.ts
@@ -0,0 +1,12 @@
+export interface AzureActiveDirectoryDefaultAuthentication {
+    /**
+     * This uses DefaultAzureCredential from @azure/identity to try multiple methods of authentication
+     */
+    type: "azure-active-directory-default";
+    options: {
+        /**
+         * The clientId of the user you want to log in with, mapped to the managedIdentityClientId in tedious
+         */
+        clientId?: string;
+    };
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.js b/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.js
new file mode 100644
index 0000000000000000000000000000000000000000..dd12464b2dc3249ab69425d6dde0484d976d0e2e
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+
+//# sourceMappingURL=AzureActiveDirectoryDefaultAuthentication.js.map
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.js.map b/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..a2784dc69b0ad8802fd81b12f87c0a717ee72f1e
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.ts"],"names":[],"mappings":"","file":"AzureActiveDirectoryDefaultAuthentication.js","sourcesContent":["export interface AzureActiveDirectoryDefaultAuthentication {\n    /**\n     * This uses DefaultAzureCredential from @azure/identity to try multiple methods of authentication\n     */\n    type: \"azure-active-directory-default\"\n    options: {\n        /**\n         * The clientId of the user you want to log in with, mapped to the managedIdentityClientId in tedious\n         */\n        clientId?: string\n    }\n}\n"],"sourceRoot":"../../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.ts b/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f6def689f03d3a9870138b68fc49c266afc770c7
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryDefaultAuthentication.ts
@@ -0,0 +1,12 @@
+export interface AzureActiveDirectoryDefaultAuthentication {
+    /**
+     * This uses DefaultAzureCredential from @azure/identity to try multiple methods of authentication
+     */
+    type: "azure-active-directory-default"
+    options: {
+        /**
+         * The clientId of the user you want to log in with, mapped to the managedIdentityClientId in tedious
+         */
+        clientId?: string
+    }
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.d.ts b/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..69e86a5bf8a4c986eeee7d2b318a5419fe49fb12
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.d.ts
@@ -0,0 +1,20 @@
+export interface AzureActiveDirectoryMsiAppServiceAuthentication {
+    type: "azure-active-directory-msi-app-service";
+    options: {
+        /**
+         * If you user want to connect to an Azure app service using a specific client account
+         * they need to provide `clientId` associate to their created identity.
+         *
+         * This is optional for retrieve token from azure web app service
+         */
+        clientId?: string;
+        /**
+         * A msi app service environment need to provide `msiEndpoint` for retriving the accesstoken.
+         */
+        msiEndpoint?: string;
+        /**
+         * A msi app service environment need to provide `msiSecret` for retrieved the accesstoken.
+         */
+        msiSecret?: string;
+    };
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.js b/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.js
new file mode 100644
index 0000000000000000000000000000000000000000..4dff2ff385e4de7639b871165affe0ef1fed9687
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+
+//# sourceMappingURL=AzureActiveDirectoryMsiAppServiceAuthentication.js.map
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.js.map b/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..6682a6ccfc4e792f07fe0a0a4698140e372cf14b
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.ts"],"names":[],"mappings":"","file":"AzureActiveDirectoryMsiAppServiceAuthentication.js","sourcesContent":["export interface AzureActiveDirectoryMsiAppServiceAuthentication {\n    type: \"azure-active-directory-msi-app-service\"\n    options: {\n        /**\n         * If you user want to connect to an Azure app service using a specific client account\n         * they need to provide `clientId` associate to their created identity.\n         *\n         * This is optional for retrieve token from azure web app service\n         */\n        clientId?: string\n        /**\n         * A msi app service environment need to provide `msiEndpoint` for retriving the accesstoken.\n         */\n        msiEndpoint?: string\n        /**\n         * A msi app service environment need to provide `msiSecret` for retrieved the accesstoken.\n         */\n        msiSecret?: string\n    }\n}\n"],"sourceRoot":"../../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.ts b/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.ts
new file mode 100644
index 0000000000000000000000000000000000000000..88424e8860999c29d39810da2181d4ea7bfdde00
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryMsiAppServiceAuthentication.ts
@@ -0,0 +1,20 @@
+export interface AzureActiveDirectoryMsiAppServiceAuthentication {
+    type: "azure-active-directory-msi-app-service"
+    options: {
+        /**
+         * If you user want to connect to an Azure app service using a specific client account
+         * they need to provide `clientId` associate to their created identity.
+         *
+         * This is optional for retrieve token from azure web app service
+         */
+        clientId?: string
+        /**
+         * A msi app service environment need to provide `msiEndpoint` for retriving the accesstoken.
+         */
+        msiEndpoint?: string
+        /**
+         * A msi app service environment need to provide `msiSecret` for retrieved the accesstoken.
+         */
+        msiSecret?: string
+    }
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.d.ts b/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7eb4f929946b4f72cafd5cc295383b6a1e567526
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.d.ts
@@ -0,0 +1,16 @@
+export interface AzureActiveDirectoryMsiVmAuthentication {
+    type: "azure-active-directory-msi-vm";
+    options: {
+        /**
+         * If you user want to connect to an Azure app service using a specific client account
+         * they need to provide `clientId` associate to their created identity.
+         *
+         * This is optional for retrieve token from azure web app service
+         */
+        clientId?: string;
+        /**
+         * A user need to provide `msiEndpoint` for retrieving the accesstoken.
+         */
+        msiEndpoint?: string;
+    };
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.js b/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.js
new file mode 100644
index 0000000000000000000000000000000000000000..54963fc1e8068ce6bc6657c662e2af5febf497a3
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+
+//# sourceMappingURL=AzureActiveDirectoryMsiVmAuthentication.js.map
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.js.map b/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..a4014f49b9a90eb6770172a70b601ad8d31bdeda
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.ts"],"names":[],"mappings":"","file":"AzureActiveDirectoryMsiVmAuthentication.js","sourcesContent":["export interface AzureActiveDirectoryMsiVmAuthentication {\n    type: \"azure-active-directory-msi-vm\"\n    options: {\n        /**\n         * If you user want to connect to an Azure app service using a specific client account\n         * they need to provide `clientId` associate to their created identity.\n         *\n         * This is optional for retrieve token from azure web app service\n         */\n        clientId?: string\n        /**\n         * A user need to provide `msiEndpoint` for retrieving the accesstoken.\n         */\n        msiEndpoint?: string\n    }\n}\n"],"sourceRoot":"../../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.ts b/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.ts
new file mode 100644
index 0000000000000000000000000000000000000000..36c6d59be04b9de19ecc29f75d2b011fc812506a
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryMsiVmAuthentication.ts
@@ -0,0 +1,16 @@
+export interface AzureActiveDirectoryMsiVmAuthentication {
+    type: "azure-active-directory-msi-vm"
+    options: {
+        /**
+         * If you user want to connect to an Azure app service using a specific client account
+         * they need to provide `clientId` associate to their created identity.
+         *
+         * This is optional for retrieve token from azure web app service
+         */
+        clientId?: string
+        /**
+         * A user need to provide `msiEndpoint` for retrieving the accesstoken.
+         */
+        msiEndpoint?: string
+    }
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.d.ts b/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dc4a42058c7e6729826b3323e702ecd5316ee967
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.d.ts
@@ -0,0 +1,17 @@
+export interface AzureActiveDirectoryPasswordAuthentication {
+    type: "azure-active-directory-password";
+    options: {
+        /**
+         * A user need to provide `userName` associate to their account.
+         */
+        userName: string;
+        /**
+         * A user need to provide `password` associate to their account.
+         */
+        password: string;
+        /**
+         * Optional parameter for specific Azure tenant ID
+         */
+        domain: string;
+    };
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.js b/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.js
new file mode 100644
index 0000000000000000000000000000000000000000..ac52e337767d08f895a265766d0226e24213a449
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+
+//# sourceMappingURL=AzureActiveDirectoryPasswordAuthentication.js.map
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.js.map b/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..d1bd2888ee2d78e6b70321287d79e8631f55eb98
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.ts"],"names":[],"mappings":"","file":"AzureActiveDirectoryPasswordAuthentication.js","sourcesContent":["export interface AzureActiveDirectoryPasswordAuthentication {\n    type: \"azure-active-directory-password\"\n    options: {\n        /**\n         * A user need to provide `userName` associate to their account.\n         */\n        userName: string\n        /**\n         * A user need to provide `password` associate to their account.\n         */\n        password: string\n\n        /**\n         * Optional parameter for specific Azure tenant ID\n         */\n        domain: string\n    }\n}\n"],"sourceRoot":"../../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.ts b/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.ts
new file mode 100644
index 0000000000000000000000000000000000000000..900fce47903053b27dd68d9b405a96c48e2b4103
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryPasswordAuthentication.ts
@@ -0,0 +1,18 @@
+export interface AzureActiveDirectoryPasswordAuthentication {
+    type: "azure-active-directory-password"
+    options: {
+        /**
+         * A user need to provide `userName` associate to their account.
+         */
+        userName: string
+        /**
+         * A user need to provide `password` associate to their account.
+         */
+        password: string
+
+        /**
+         * Optional parameter for specific Azure tenant ID
+         */
+        domain: string
+    }
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.d.ts b/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..48f5499d00da52f7d559a063dbd6862c92aad581
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.d.ts
@@ -0,0 +1,17 @@
+export interface AzureActiveDirectoryServicePrincipalSecret {
+    type: "azure-active-directory-service-principal-secret";
+    options: {
+        /**
+         * Application (`client`) ID from your registered Azure application
+         */
+        clientId: string;
+        /**
+         * The created `client secret` for this registered Azure application
+         */
+        clientSecret: string;
+        /**
+         * Directory (`tenant`) ID from your registered Azure application
+         */
+        tenantId: string;
+    };
+}
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.js b/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.js
new file mode 100644
index 0000000000000000000000000000000000000000..2c15c5be63f95bc97389d553bf897d89fd9b9d2a
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+
+//# sourceMappingURL=AzureActiveDirectoryServicePrincipalSecret.js.map
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.js.map b/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..83bd73e35032740b488e5d7397e1e30867c98861
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.ts"],"names":[],"mappings":"","file":"AzureActiveDirectoryServicePrincipalSecret.js","sourcesContent":["export interface AzureActiveDirectoryServicePrincipalSecret {\n    type: \"azure-active-directory-service-principal-secret\"\n    options: {\n        /**\n         * Application (`client`) ID from your registered Azure application\n         */\n        clientId: string\n        /**\n         * The created `client secret` for this registered Azure application\n         */\n        clientSecret: string\n        /**\n         * Directory (`tenant`) ID from your registered Azure application\n         */\n        tenantId: string\n    }\n}\n"],"sourceRoot":"../../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.ts b/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bf7476ebde0210fc9035c24522e9ddccf9483afe
--- /dev/null
+++ b/driver/sqlserver/authentication/AzureActiveDirectoryServicePrincipalSecret.ts
@@ -0,0 +1,17 @@
+export interface AzureActiveDirectoryServicePrincipalSecret {
+    type: "azure-active-directory-service-principal-secret"
+    options: {
+        /**
+         * Application (`client`) ID from your registered Azure application
+         */
+        clientId: string
+        /**
+         * The created `client secret` for this registered Azure application
+         */
+        clientSecret: string
+        /**
+         * Directory (`tenant`) ID from your registered Azure application
+         */
+        tenantId: string
+    }
+}
diff --git a/driver/sqlserver/authentication/DefaultAuthentication.d.ts b/driver/sqlserver/authentication/DefaultAuthentication.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8af25b3fb3caf746a90b12b0c3ef9853b32bc951
--- /dev/null
+++ b/driver/sqlserver/authentication/DefaultAuthentication.d.ts
@@ -0,0 +1,13 @@
+export interface DefaultAuthentication {
+    type: "default";
+    options: {
+        /**
+         * User name to use for sql server login.
+         */
+        userName?: string;
+        /**
+         * Password to use for sql server login.
+         */
+        password?: string;
+    };
+}
diff --git a/driver/sqlserver/authentication/DefaultAuthentication.js b/driver/sqlserver/authentication/DefaultAuthentication.js
new file mode 100644
index 0000000000000000000000000000000000000000..6e66323603680186a1b039b362230ebd4fd88aab
--- /dev/null
+++ b/driver/sqlserver/authentication/DefaultAuthentication.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+
+//# sourceMappingURL=DefaultAuthentication.js.map
diff --git a/driver/sqlserver/authentication/DefaultAuthentication.js.map b/driver/sqlserver/authentication/DefaultAuthentication.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..2ecf25725e086825a8368fa319dac3f8446ce894
--- /dev/null
+++ b/driver/sqlserver/authentication/DefaultAuthentication.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/authentication/DefaultAuthentication.ts"],"names":[],"mappings":"","file":"DefaultAuthentication.js","sourcesContent":["export interface DefaultAuthentication {\n    type: \"default\"\n    options: {\n        /**\n         * User name to use for sql server login.\n         */\n        userName?: string\n        /**\n         * Password to use for sql server login.\n         */\n        password?: string\n    }\n}\n"],"sourceRoot":"../../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/authentication/DefaultAuthentication.ts b/driver/sqlserver/authentication/DefaultAuthentication.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fca62232f12629b9ad837127aa8f45e3c5ced2b9
--- /dev/null
+++ b/driver/sqlserver/authentication/DefaultAuthentication.ts
@@ -0,0 +1,13 @@
+export interface DefaultAuthentication {
+    type: "default"
+    options: {
+        /**
+         * User name to use for sql server login.
+         */
+        userName?: string
+        /**
+         * Password to use for sql server login.
+         */
+        password?: string
+    }
+}
diff --git a/driver/sqlserver/authentication/NtlmAuthentication.d.ts b/driver/sqlserver/authentication/NtlmAuthentication.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcf09994e2114589bd8403b4ba2877d53260d63f
--- /dev/null
+++ b/driver/sqlserver/authentication/NtlmAuthentication.d.ts
@@ -0,0 +1,19 @@
+export interface NtlmAuthentication {
+    type: "ntlm";
+    options: {
+        /**
+         * User name from your windows account.
+         */
+        userName: string;
+        /**
+         * Password from your windows account.
+         */
+        password: string;
+        /**
+         * Once you set domain for ntlm authentication type, driver will connect to SQL Server using domain login.
+         *
+         * This is necessary for forming a connection using ntlm type
+         */
+        domain: string;
+    };
+}
diff --git a/driver/sqlserver/authentication/NtlmAuthentication.js b/driver/sqlserver/authentication/NtlmAuthentication.js
new file mode 100644
index 0000000000000000000000000000000000000000..2b1bef09fca17828cba9e21d7442fd71440a657b
--- /dev/null
+++ b/driver/sqlserver/authentication/NtlmAuthentication.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+
+//# sourceMappingURL=NtlmAuthentication.js.map
diff --git a/driver/sqlserver/authentication/NtlmAuthentication.js.map b/driver/sqlserver/authentication/NtlmAuthentication.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..54f087c9ea9411d90f4990dceb277c4174bd52fe
--- /dev/null
+++ b/driver/sqlserver/authentication/NtlmAuthentication.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../../src/driver/sqlserver/authentication/NtlmAuthentication.ts"],"names":[],"mappings":"","file":"NtlmAuthentication.js","sourcesContent":["export interface NtlmAuthentication {\n    type: \"ntlm\"\n    options: {\n        /**\n         * User name from your windows account.\n         */\n        userName: string\n        /**\n         * Password from your windows account.\n         */\n        password: string\n        /**\n         * Once you set domain for ntlm authentication type, driver will connect to SQL Server using domain login.\n         *\n         * This is necessary for forming a connection using ntlm type\n         */\n        domain: string\n    }\n}\n"],"sourceRoot":"../../.."}
\ No newline at end of file
diff --git a/driver/sqlserver/authentication/NtlmAuthentication.ts b/driver/sqlserver/authentication/NtlmAuthentication.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1bff98c8415c76671b8a4e84ae6c3e518fbb268e
--- /dev/null
+++ b/driver/sqlserver/authentication/NtlmAuthentication.ts
@@ -0,0 +1,19 @@
+export interface NtlmAuthentication {
+    type: "ntlm"
+    options: {
+        /**
+         * User name from your windows account.
+         */
+        userName: string
+        /**
+         * Password from your windows account.
+         */
+        password: string
+        /**
+         * Once you set domain for ntlm authentication type, driver will connect to SQL Server using domain login.
+         *
+         * This is necessary for forming a connection using ntlm type
+         */
+        domain: string
+    }
+}
diff --git a/query-builder/DeleteQueryBuilder.js b/query-builder/DeleteQueryBuilder.js
index 02293a25fc59cc533040e1fe112f835328ed61d4..fbccdd1d40bfd4ef287063e6b299a672b4ae3d60 100644
--- a/query-builder/DeleteQueryBuilder.js
+++ b/query-builder/DeleteQueryBuilder.js
@@ -186,6 +186,9 @@ class DeleteQueryBuilder extends QueryBuilder_1.QueryBuilder {
         if (returningExpression === "") {
             return `DELETE FROM ${tableName}${whereExpression}`;
         }
+        if (this.connection.driver.options.type === "mssql") {
+            return `DELETE FROM ${tableName} OUTPUT ${returningExpression}${whereExpression}`;
+        }
         return `DELETE FROM ${tableName}${whereExpression} RETURNING ${returningExpression}`;
     }
 }
diff --git a/query-builder/InsertQueryBuilder.js b/query-builder/InsertQueryBuilder.js
index fc0fb4965254f3f8ad1cbb5f2a82b3cf5f9c3a7e..bc3fae43bfb9f5be5abb9b9b2924cbbfcbdcbb69 100644
--- a/query-builder/InsertQueryBuilder.js
+++ b/query-builder/InsertQueryBuilder.js
@@ -83,10 +83,18 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
             }
             if (this.expressionMap.updateEntity === true &&
                 this.expressionMap.mainAlias.hasMetadata) {
-                this.expressionMap.extraReturningColumns =
-                    this.expressionMap.mainAlias.metadata.getInsertionReturningColumns();
+                if (!(valueSets.length > 1 &&
+                    this.connection.driver.options.type === "oracle")) {
+                    this.expressionMap.extraReturningColumns =
+                        this.expressionMap.mainAlias.metadata.getInsertionReturningColumns();
+                }
                 returningColumns.push(...this.expressionMap.extraReturningColumns.filter((c) => !returningColumns.includes(c)));
             }
+            if (returningColumns.length > 0 &&
+                this.connection.driver.options.type === "mssql") {
+                declareSql = this.connection.driver.buildTableVariableDeclaration("@OutputTable", returningColumns);
+                selectOutputSql = `SELECT * FROM @OutputTable`;
+            }
             // console.timeEnd(".prepare returning statement");
             // execute query
             // console.time(".getting query and parameters");
@@ -238,13 +246,17 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
     createInsertExpression() {
         const tableName = this.getTableName(this.getMainTableName());
         const valuesExpression = this.createValuesExpression(); // its important to get values before returning expression because oracle rely on native parameters and ordering of them is important
-        const returningExpression = this.createReturningExpression("insert");
+        const returningExpression = this.connection.driver.options.type === "oracle" &&
+            this.getValueSets().length > 1
+            ? null
+            : this.createReturningExpression("insert"); // oracle doesnt support returning with multi-row insert
         const columnsExpression = this.createColumnNamesExpression();
         let query = "INSERT ";
         if (this.expressionMap.onUpdate?.upsertType === "primary-key") {
             query = "UPSERT ";
         }
-        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver)) {
+        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) ||
+            this.connection.driver.options.type === "aurora-mysql") {
             query += `${this.expressionMap.onIgnore ? " IGNORE " : ""}`;
         }
         query += `INTO ${tableName}`;
@@ -258,16 +270,30 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
         }
         else {
             if (!valuesExpression &&
-                DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver))
+                (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) ||
+                    this.connection.driver.options.type === "aurora-mysql"))
                 // special syntax for mysql DEFAULT VALUES insertion
                 query += "()";
         }
+        // add OUTPUT expression
+        if (returningExpression &&
+            this.connection.driver.options.type === "mssql") {
+            query += ` OUTPUT ${returningExpression}`;
+        }
         // add VALUES expression
         if (valuesExpression) {
-            query += ` VALUES ${valuesExpression}`;
+            if ((this.connection.driver.options.type === "oracle" ||
+                this.connection.driver.options.type === "sap") &&
+                this.getValueSets().length > 1) {
+                query += ` ${valuesExpression}`;
+            }
+            else {
+                query += ` VALUES ${valuesExpression}`;
+            }
         }
         else {
-            if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver)) {
+            if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) ||
+                this.connection.driver.options.type === "aurora-mysql") {
                 // special syntax for mysql DEFAULT VALUES insertion
                 query += " VALUES ()";
             }
@@ -314,7 +340,15 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
                         updatePart.push(...this.expressionMap
                             .mainAlias.metadata.columns.filter((column) => column.isUpdateDate &&
                             !overwrite?.includes(column.databaseName) &&
-                            !DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver))
+                            !((this.connection.driver.options
+                                .type === "oracle" &&
+                                this.getValueSets().length >
+                                    1) ||
+                                DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) ||
+                                this.connection.driver.options
+                                    .type === "sap" ||
+                                this.connection.driver.options
+                                    .type === "spanner"))
                             .map((column) => `${this.escape(column.databaseName)} = DEFAULT`));
                         query += updatePart.join(", ");
                         query += " ";
@@ -358,9 +392,22 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
         // add RETURNING expression
         if (returningExpression &&
             (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver) ||
+                this.connection.driver.options.type === "oracle" ||
+                this.connection.driver.options.type === "cockroachdb" ||
                 DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver))) {
             query += ` RETURNING ${returningExpression}`;
         }
+        // Inserting a specific value for an auto-increment primary key in mssql requires enabling IDENTITY_INSERT
+        // IDENTITY_INSERT can only be enabled for tables where there is an IDENTITY column and only if there is a value to be inserted (i.e. supplying DEFAULT is prohibited if IDENTITY_INSERT is enabled)
+        if (this.connection.driver.options.type === "mssql" &&
+            this.expressionMap.mainAlias.hasMetadata &&
+            this.expressionMap
+                .mainAlias.metadata.columns.filter((column) => this.expressionMap.insertColumns.length > 0
+                ? this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1
+                : column.isInsert)
+                .some((column) => this.isOverridingAutoIncrementBehavior(column))) {
+            query = `SET IDENTITY_INSERT ${tableName} ON; ${query}; SET IDENTITY_INSERT ${tableName} OFF`;
+        }
         return query;
     }
     /**
@@ -378,10 +425,16 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
                 return false;
             }
             // if user did not specified such list then return all columns except auto-increment one
+            // for Oracle we return auto-increment column as well because Oracle does not support DEFAULT VALUES expression
             if (column.isGenerated &&
                 column.generationStrategy === "increment" &&
+                !(this.connection.driver.options.type === "spanner") &&
+                !(this.connection.driver.options.type === "oracle") &&
                 !DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) &&
-                !DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver))
+                !DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) &&
+                !(this.connection.driver.options.type === "aurora-mysql") &&
+                !(this.connection.driver.options.type === "mssql" &&
+                    this.isOverridingAutoIncrementBehavior(column)))
                 return false;
             return true;
         });
@@ -422,7 +475,17 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
             valueSets.forEach((valueSet, valueSetIndex) => {
                 columns.forEach((column, columnIndex) => {
                     if (columnIndex === 0) {
-                        expression += "(";
+                        if (this.connection.driver.options.type === "oracle" &&
+                            valueSets.length > 1) {
+                            expression += " SELECT ";
+                        }
+                        else if (this.connection.driver.options.type === "sap" &&
+                            valueSets.length > 1) {
+                            expression += " SELECT ";
+                        }
+                        else {
+                            expression += "(";
+                        }
                     }
                     // extract real value from the entity
                     let value = column.getEntityValue(valueSet);
@@ -478,7 +541,11 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
                         // if value for this column was not provided then insert default value
                     }
                     else if (value === undefined) {
-                        if (DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver)) {
+                        if ((this.connection.driver.options.type === "oracle" &&
+                            valueSets.length > 1) ||
+                            DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) ||
+                            this.connection.driver.options.type === "sap" ||
+                            this.connection.driver.options.type === "spanner") {
                             // unfortunately sqlite does not support DEFAULT expression in INSERT queries
                             if (column.default !== undefined &&
                                 column.default !== null) {
@@ -493,6 +560,10 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
                         else {
                             expression += "DEFAULT";
                         }
+                    }
+                    else if (value === null &&
+                        this.connection.driver.options.type === "spanner") {
+                        expression += "NULL";
                         // support for SQL expressions in queries
                     }
                     else if (typeof value === "function") {
@@ -500,11 +571,15 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
                         // just any other regular value
                     }
                     else {
+                        if (this.connection.driver.options.type === "mssql")
+                            value = this.connection.driver.parametrizeValue(column, value);
                         // we need to store array values in a special class to make sure parameter replacement will work correctly
                         // if (value instanceof Array)
                         //     value = new ArrayParameter(value);
                         const paramName = this.createParameter(value);
-                        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) &&
+                        if ((DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) ||
+                            this.connection.driver.options.type ===
+                                "aurora-mysql") &&
                             this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
                             const useLegacy = this.connection.driver.options.legacySpatialSupport;
                             const geomFromText = useLegacy
@@ -526,16 +601,48 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
                                 expression += `ST_GeomFromGeoJSON(${paramName})::${column.type}`;
                             }
                         }
+                        else if (this.connection.driver.options.type === "mssql" &&
+                            this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
+                            expression +=
+                                column.type +
+                                    "::STGeomFromText(" +
+                                    paramName +
+                                    ", " +
+                                    (column.srid || "0") +
+                                    ")";
+                        }
                         else {
                             expression += paramName;
                         }
                     }
                     if (columnIndex === columns.length - 1) {
                         if (valueSetIndex === valueSets.length - 1) {
-                            expression += ")";
+                            if (this.connection.driver.options.type ===
+                                "oracle" &&
+                                valueSets.length > 1) {
+                                expression += " FROM DUAL ";
+                            }
+                            else if (this.connection.driver.options.type === "sap" &&
+                                valueSets.length > 1) {
+                                expression += " FROM dummy ";
+                            }
+                            else {
+                                expression += ")";
+                            }
                         }
                         else {
-                            expression += "), ";
+                            if (this.connection.driver.options.type ===
+                                "oracle" &&
+                                valueSets.length > 1) {
+                                expression += " FROM DUAL UNION ALL ";
+                            }
+                            else if (this.connection.driver.options.type === "sap" &&
+                                valueSets.length > 1) {
+                                expression += " FROM dummy UNION ALL ";
+                            }
+                            else {
+                                expression += "), ";
+                            }
                         }
                     }
                     else {
@@ -564,12 +671,19 @@ class InsertQueryBuilder extends QueryBuilder_1.QueryBuilder {
                         // if value for this column was not provided then insert default value
                     }
                     else if (value === undefined) {
-                        if (DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver)) {
+                        if ((this.connection.driver.options.type === "oracle" &&
+                            valueSets.length > 1) ||
+                            DriverUtils_1.DriverUtils.isSQLiteFamily(this.connection.driver) ||
+                            this.connection.driver.options.type === "sap" ||
+                            this.connection.driver.options.type === "spanner") {
                             expression += "NULL";
                         }
                         else {
                             expression += "DEFAULT";
                         }
+                    }
+                    else if (value === null &&
+                        this.connection.driver.options.type === "spanner") {
                         // just any other regular value
                     }
                     else {
diff --git a/query-builder/QueryBuilder.js b/query-builder/QueryBuilder.js
index 9eecc2702e266e2d64046813057ed083537aed81..2df381142abd9f139ab3c5be5f47f29d90f8a074 100644
--- a/query-builder/QueryBuilder.js
+++ b/query-builder/QueryBuilder.js
@@ -602,9 +602,42 @@ class QueryBuilder {
             let columnsExpression = columns
                 .map((column) => {
                 const name = this.escape(column.databaseName);
-                return name;
+                if (driver.options.type === "mssql") {
+                    if (this.expressionMap.queryType === "insert" ||
+                        this.expressionMap.queryType === "update" ||
+                        this.expressionMap.queryType === "soft-delete" ||
+                        this.expressionMap.queryType === "restore") {
+                        return "INSERTED." + name;
+                    }
+                    else {
+                        return (this.escape(this.getMainTableName()) +
+                            "." +
+                            name);
+                    }
+                }
+                else {
+                    return name;
+                }
             })
                 .join(", ");
+            if (driver.options.type === "oracle") {
+                columnsExpression +=
+                    " INTO " +
+                        columns
+                            .map((column) => {
+                            return this.createParameter({
+                                type: driver.columnTypeToNativeParameter(column.type),
+                                dir: driver.oracle.BIND_OUT,
+                            });
+                        })
+                            .join(", ");
+            }
+            if (driver.options.type === "mssql") {
+                if (this.expressionMap.queryType === "insert" ||
+                    this.expressionMap.queryType === "update") {
+                    columnsExpression += " INTO @OutputTable";
+                }
+            }
             return columnsExpression;
         }
         else if (typeof this.expressionMap.returning === "string") {
@@ -693,7 +726,8 @@ class QueryBuilder {
             case "equal":
                 return `${condition.parameters[0]} = ${condition.parameters[1]}`;
             case "ilike":
-                if (driver.options.type === "postgres") {
+                if (driver.options.type === "postgres" ||
+                    driver.options.type === "cockroachdb") {
                     return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`;
                 }
                 return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`;
@@ -709,6 +743,9 @@ class QueryBuilder {
                     .slice(1)
                     .join(", ")})`;
             case "any":
+                if (driver.options.type === "cockroachdb") {
+                    return `${condition.parameters[0]}::STRING = ANY(${condition.parameters[1]}::STRING[])`;
+                }
                 return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`;
             case "isNull":
                 return `${condition.parameters[0]} IS NULL`;
diff --git a/query-builder/SelectQueryBuilder.js b/query-builder/SelectQueryBuilder.js
index 3079188f413787c784164ae9ef0da5db09e3e697..8eda00e651cf2c73592f72586c9c1964d33182b3 100644
--- a/query-builder/SelectQueryBuilder.js
+++ b/query-builder/SelectQueryBuilder.js
@@ -483,6 +483,14 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
      * Enables time travelling for the current query (only supported by cockroach currently)
      */
     timeTravelQuery(timeTravelFn) {
+        if (this.connection.driver.options.type === "cockroachdb") {
+            if (timeTravelFn === undefined) {
+                this.expressionMap.timeTravel = "follower_read_timestamp()";
+            }
+            else {
+                this.expressionMap.timeTravel = timeTravelFn;
+            }
+        }
         return this;
     }
     /**
@@ -1335,7 +1343,33 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
             offset = this.expressionMap.skip;
             limit = this.expressionMap.take;
         }
-        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver)) {
+        if (this.connection.driver.options.type === "mssql") {
+            // Due to a limitation in SQL Server's parser implementation it does not support using
+            // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the
+            // user does not request one we insert a dummy ORDER BY that does nothing and should
+            // have no effect on the query planner or on the order of the results returned.
+            // https://dba.stackexchange.com/a/193799
+            let prefix = "";
+            if ((limit || offset) &&
+                Object.keys(this.expressionMap.allOrderBys).length <= 0) {
+                prefix = " ORDER BY (SELECT NULL)";
+            }
+            if (limit && offset)
+                return (prefix +
+                    " OFFSET " +
+                    offset +
+                    " ROWS FETCH NEXT " +
+                    limit +
+                    " ROWS ONLY");
+            if (limit)
+                return (prefix + " OFFSET 0 ROWS FETCH NEXT " + limit + " ROWS ONLY");
+            if (offset)
+                return prefix + " OFFSET " + offset + " ROWS";
+        }
+        else if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) ||
+            this.connection.driver.options.type === "aurora-mysql" ||
+            this.connection.driver.options.type === "sap" ||
+            this.connection.driver.options.type === "spanner") {
             if (limit && offset)
                 return " LIMIT " + limit + " OFFSET " + offset;
             if (limit)
@@ -1351,6 +1385,18 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
             if (offset)
                 return " LIMIT -1 OFFSET " + offset;
         }
+        else if (this.connection.driver.options.type === "oracle") {
+            if (limit && offset)
+                return (" OFFSET " +
+                    offset +
+                    " ROWS FETCH NEXT " +
+                    limit +
+                    " ROWS ONLY");
+            if (limit)
+                return " FETCH NEXT " + limit + " ROWS ONLY";
+            if (offset)
+                return " OFFSET " + offset + " ROWS";
+        }
         else {
             if (limit && offset)
                 return " LIMIT " + limit + " OFFSET " + offset;
@@ -1370,6 +1416,16 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
      *      ON U.ID=O.OrderID
      */
     createTableLockExpression() {
+        if (this.connection.driver.options.type === "mssql") {
+            switch (this.expressionMap.lockMode) {
+                case "pessimistic_read":
+                    return " WITH (HOLDLOCK, ROWLOCK)";
+                case "pessimistic_write":
+                    return " WITH (UPDLOCK, ROWLOCK)";
+                case "dirty_read":
+                    return " WITH (NOLOCK)";
+            }
+        }
         return "";
     }
     /**
@@ -1379,7 +1435,8 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
         const driver = this.connection.driver;
         let lockTablesClause = "";
         if (this.expressionMap.lockTables) {
-            if (!DriverUtils_1.DriverUtils.isPostgresFamily(driver)) {
+            if (!(DriverUtils_1.DriverUtils.isPostgresFamily(driver) ||
+                driver.options.type === "cockroachdb")) {
                 throw new error_1.TypeORMError("Lock tables not supported in selected driver");
             }
             if (this.expressionMap.lockTables.length < 1) {
@@ -1396,7 +1453,8 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
         }
         switch (this.expressionMap.lockMode) {
             case "pessimistic_read":
-                if (driver.options.type === "mysql") {
+                if (driver.options.type === "mysql" ||
+                    driver.options.type === "aurora-mysql") {
                     if (DriverUtils_1.DriverUtils.isReleaseVersionOrGreater(driver, "8.0.0")) {
                         return (" FOR SHARE" + lockTablesClause + onLockExpression);
                     }
@@ -1410,16 +1468,28 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
                 else if (DriverUtils_1.DriverUtils.isPostgresFamily(driver)) {
                     return " FOR SHARE" + lockTablesClause + onLockExpression;
                 }
+                else if (driver.options.type === "oracle") {
+                    return " FOR UPDATE";
+                }
+                else if (driver.options.type === "mssql") {
+                    return "";
+                }
                 else {
                     throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                 }
             case "pessimistic_write":
-                if (DriverUtils_1.DriverUtils.isMySQLFamily(driver)) {
+                if (DriverUtils_1.DriverUtils.isMySQLFamily(driver) ||
+                    driver.options.type === "aurora-mysql" ||
+                    driver.options.type === "oracle") {
                     return " FOR UPDATE" + onLockExpression;
                 }
-                else if (DriverUtils_1.DriverUtils.isPostgresFamily(driver)) {
+                else if (DriverUtils_1.DriverUtils.isPostgresFamily(driver) ||
+                    driver.options.type === "cockroachdb") {
                     return " FOR UPDATE" + lockTablesClause + onLockExpression;
                 }
+                else if (driver.options.type === "mssql") {
+                    return "";
+                }
                 else {
                     throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                 }
@@ -1434,7 +1504,8 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
                     throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                 }
             case "pessimistic_write_or_fail":
-                if (DriverUtils_1.DriverUtils.isPostgresFamily(driver)) {
+                if (DriverUtils_1.DriverUtils.isPostgresFamily(driver) ||
+                    driver.options.type === "cockroachdb") {
                     return " FOR UPDATE" + lockTablesClause + " NOWAIT";
                 }
                 else if (DriverUtils_1.DriverUtils.isMySQLFamily(driver)) {
@@ -1444,7 +1515,8 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
                     throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                 }
             case "for_no_key_update":
-                if (DriverUtils_1.DriverUtils.isPostgresFamily(driver)) {
+                if (DriverUtils_1.DriverUtils.isPostgresFamily(driver) ||
+                    driver.options.type === "cockroachdb") {
                     return (" FOR NO KEY UPDATE" +
                         lockTablesClause +
                         onLockExpression);
@@ -1515,9 +1587,9 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
                 selectionPath = `(${column.query(escapedAliasName)})`;
             }
             if (this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
-                if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver)) {
-                    const useLegacy = this.connection.driver
-                        .options.legacySpatialSupport;
+                if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) ||
+                    this.connection.driver.options.type === "aurora-mysql") {
+                    const useLegacy = this.connection.driver.options.legacySpatialSupport;
                     const asText = useLegacy ? "AsText" : "ST_AsText";
                     selectionPath = `${asText}(${selectionPath})`;
                 }
@@ -1529,6 +1601,8 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
                     else {
                         selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;
                     }
+                if (this.connection.driver.options.type === "mssql")
+                    selectionPath = `${selectionPath}.ToString()`;
             }
             const selections = this.expressionMap.selects.filter((select) => select.selection === aliasName + "." + column.propertyPath);
             if (selections.length) {
@@ -1579,7 +1653,8 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
             return "COUNT(1)";
         }
         // For everything else, we'll need to do some hackery to get the correct count values.
-        if (DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
+        if (this.connection.driver.options.type === "cockroachdb" ||
+            DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
             // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function
             // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT
             return ("COUNT(DISTINCT(" +
@@ -1597,6 +1672,30 @@ class SelectQueryBuilder extends QueryBuilder_1.QueryBuilder {
                     .join(", ") +
                 ")");
         }
+        if (this.connection.driver.options.type === "mssql") {
+            // SQL Server has gotta be different from everyone else.  They don't support
+            // distinct counting multiple columns & they don't have the same operator
+            // characteristic for concatenating, so we gotta use the `CONCAT` function.
+            // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.
+            const columnsExpression = primaryColumns
+                .map((primaryColumn) => `${distinctAlias}.${this.escape(primaryColumn.databaseName)}`)
+                .join(", '|;|', ");
+            if (primaryColumns.length === 1) {
+                return `COUNT(DISTINCT(${columnsExpression}))`;
+            }
+            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;
+        }
+        if (this.connection.driver.options.type === "spanner") {
+            // spanner also has gotta be different from everyone else.
+            // they do not support concatenation of different column types without casting them to string
+            if (primaryColumns.length === 1) {
+                return `COUNT(DISTINCT(${distinctAlias}.${this.escape(primaryColumns[0].databaseName)}))`;
+            }
+            const columnsExpression = primaryColumns
+                .map((primaryColumn) => `CAST(${distinctAlias}.${this.escape(primaryColumn.databaseName)} AS STRING)`)
+                .join(", '|;|', ");
+            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;
+        }
         // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.
         // Per the SQL spec, this is the canonical string concatenation mechanism which is most
         // likely to work across servers implementing the SQL standard.
diff --git a/query-builder/UpdateQueryBuilder.js b/query-builder/UpdateQueryBuilder.js
index 3efd35980867cfd0a703ce22be93b37e759276ac..3bf106b0bf9bf1b5bf61d5f3eb4ebfe7f635baa8 100644
--- a/query-builder/UpdateQueryBuilder.js
+++ b/query-builder/UpdateQueryBuilder.js
@@ -72,6 +72,11 @@ class UpdateQueryBuilder extends QueryBuilder_1.QueryBuilder {
                     returningResultsEntityUpdator.getUpdationReturningColumns();
                 returningColumns.push(...this.expressionMap.extraReturningColumns.filter((c) => !returningColumns.includes(c)));
             }
+            if (returningColumns.length > 0 &&
+                this.connection.driver.options.type === "mssql") {
+                declareSql = this.connection.driver.buildTableVariableDeclaration("@OutputTable", returningColumns);
+                selectOutputSql = `SELECT * FROM @OutputTable`;
+            }
             // execute update query
             const [updateSql, parameters] = this.getQueryAndParameters();
             const statements = [declareSql, updateSql, selectOutputSql];
@@ -328,10 +333,21 @@ class UpdateQueryBuilder extends QueryBuilder_1.QueryBuilder {
                             " = " +
                             value());
                     }
+                    else if ((this.connection.driver.options.type === "sap" ||
+                        this.connection.driver.options.type ===
+                            "spanner") &&
+                        value === null) {
+                        updateColumnAndValues.push(this.escape(column.databaseName) + " = NULL");
+                    }
                     else {
+                        if (this.connection.driver.options.type === "mssql") {
+                            value = this.connection.driver.parametrizeValue(column, value);
+                        }
                         const paramName = this.createParameter(value);
                         let expression = null;
-                        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) &&
+                        if ((DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) ||
+                            this.connection.driver.options.type ===
+                                "aurora-mysql") &&
                             this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
                             const useLegacy = this.connection.driver.options.legacySpatialSupport;
                             const geomFromText = useLegacy
@@ -353,6 +369,17 @@ class UpdateQueryBuilder extends QueryBuilder_1.QueryBuilder {
                                 expression = `ST_GeomFromGeoJSON(${paramName})::${column.type}`;
                             }
                         }
+                        else if (this.connection.driver.options.type ===
+                            "mssql" &&
+                            this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {
+                            expression =
+                                column.type +
+                                    "::STGeomFromText(" +
+                                    paramName +
+                                    ", " +
+                                    (column.srid || "0") +
+                                    ")";
+                        }
                         else {
                             expression = paramName;
                         }
@@ -385,6 +412,11 @@ class UpdateQueryBuilder extends QueryBuilder_1.QueryBuilder {
                     // support for SQL expressions in update query
                     updateColumnAndValues.push(this.escape(key) + " = " + value());
                 }
+                else if ((this.connection.driver.options.type === "sap" ||
+                    this.connection.driver.options.type === "spanner") &&
+                    value === null) {
+                    updateColumnAndValues.push(this.escape(key) + " = NULL");
+                }
                 else {
                     // we need to store array values in a special class to make sure parameter replacement will work correctly
                     // if (value instanceof Array)
@@ -403,6 +435,9 @@ class UpdateQueryBuilder extends QueryBuilder_1.QueryBuilder {
         if (returningExpression === "") {
             return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression}`; // todo: how do we replace aliases in where to nothing?
         }
+        if (this.connection.driver.options.type === "mssql") {
+            return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")} OUTPUT ${returningExpression}${whereExpression}`;
+        }
         return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(", ")}${whereExpression} RETURNING ${returningExpression}`;
     }
     /**
@@ -436,7 +471,8 @@ class UpdateQueryBuilder extends QueryBuilder_1.QueryBuilder {
     createLimitExpression() {
         let limit = this.expressionMap.limit;
         if (limit) {
-            if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver)) {
+            if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) ||
+                this.connection.driver.options.type === "aurora-mysql") {
                 return " LIMIT " + limit;
             }
             else {
